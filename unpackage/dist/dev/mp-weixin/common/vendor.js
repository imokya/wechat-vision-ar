"use strict";
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns$1 = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const LINEFEED = "\n";
const SLOT_DEFAULT_NAME = "d";
const ON_SHOW = "onShow";
const ON_HIDE = "onHide";
const ON_LAUNCH = "onLaunch";
const ON_ERROR = "onError";
const ON_THEME_CHANGE = "onThemeChange";
const ON_PAGE_NOT_FOUND = "onPageNotFound";
const ON_UNHANDLE_REJECTION = "onUnhandledRejection";
const ON_LOAD = "onLoad";
const ON_READY = "onReady";
const ON_UNLOAD = "onUnload";
const ON_INIT = "onInit";
const ON_SAVE_EXIT_STATE = "onSaveExitState";
const ON_RESIZE = "onResize";
const ON_BACK_PRESS = "onBackPress";
const ON_PAGE_SCROLL = "onPageScroll";
const ON_TAB_ITEM_TAP = "onTabItemTap";
const ON_REACH_BOTTOM = "onReachBottom";
const ON_PULL_DOWN_REFRESH = "onPullDownRefresh";
const ON_SHARE_TIMELINE = "onShareTimeline";
const ON_ADD_TO_FAVORITES = "onAddToFavorites";
const ON_SHARE_APP_MESSAGE = "onShareAppMessage";
const ON_NAVIGATION_BAR_BUTTON_TAP = "onNavigationBarButtonTap";
const ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED = "onNavigationBarSearchInputClicked";
const ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED = "onNavigationBarSearchInputChanged";
const ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED = "onNavigationBarSearchInputConfirmed";
const ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED = "onNavigationBarSearchInputFocusChanged";
const customizeRE = /:/g;
function customizeEvent(str) {
  return camelize(str.replace(customizeRE, "-"));
}
function hasLeadingSlash(str) {
  return str.indexOf("/") === 0;
}
function addLeadingSlash(str) {
  return hasLeadingSlash(str) ? str : "/" + str;
}
const invokeArrayFns = (fns, arg) => {
  let ret;
  for (let i = 0; i < fns.length; i++) {
    ret = fns[i](arg);
  }
  return ret;
};
function once(fn, ctx = null) {
  let res;
  return (...args) => {
    if (fn) {
      res = fn.apply(ctx, args);
      fn = null;
    }
    return res;
  };
}
function getValueByDataPath(obj, path) {
  if (!isString(path)) {
    return;
  }
  path = path.replace(/\[(\d+)\]/g, ".$1");
  const parts = path.split(".");
  let key = parts[0];
  if (!obj) {
    obj = {};
  }
  if (parts.length === 1) {
    return obj[key];
  }
  return getValueByDataPath(obj[key], parts.slice(1).join("."));
}
function sortObject(obj) {
  let sortObj = {};
  if (isPlainObject(obj)) {
    Object.keys(obj).sort().forEach((key) => {
      const _key = key;
      sortObj[_key] = obj[_key];
    });
  }
  return !Object.keys(sortObj) ? obj : sortObj;
}
const encode = encodeURIComponent;
function stringifyQuery(obj, encodeStr = encode) {
  const res = obj ? Object.keys(obj).map((key) => {
    let val = obj[key];
    if (typeof val === void 0 || val === null) {
      val = "";
    } else if (isPlainObject(val)) {
      val = JSON.stringify(val);
    }
    return encodeStr(key) + "=" + encodeStr(val);
  }).filter((x) => x.length > 0).join("&") : null;
  return res ? `?${res}` : "";
}
const PAGE_HOOKS = [
  ON_INIT,
  ON_LOAD,
  ON_SHOW,
  ON_HIDE,
  ON_UNLOAD,
  ON_BACK_PRESS,
  ON_PAGE_SCROLL,
  ON_TAB_ITEM_TAP,
  ON_REACH_BOTTOM,
  ON_PULL_DOWN_REFRESH,
  ON_SHARE_TIMELINE,
  ON_SHARE_APP_MESSAGE,
  ON_ADD_TO_FAVORITES,
  ON_SAVE_EXIT_STATE,
  ON_NAVIGATION_BAR_BUTTON_TAP,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED
];
function isRootHook(name) {
  return PAGE_HOOKS.indexOf(name) > -1;
}
const UniLifecycleHooks = [
  ON_SHOW,
  ON_HIDE,
  ON_LAUNCH,
  ON_ERROR,
  ON_THEME_CHANGE,
  ON_PAGE_NOT_FOUND,
  ON_UNHANDLE_REJECTION,
  ON_INIT,
  ON_LOAD,
  ON_READY,
  ON_UNLOAD,
  ON_RESIZE,
  ON_BACK_PRESS,
  ON_PAGE_SCROLL,
  ON_TAB_ITEM_TAP,
  ON_REACH_BOTTOM,
  ON_PULL_DOWN_REFRESH,
  ON_SHARE_TIMELINE,
  ON_ADD_TO_FAVORITES,
  ON_SHARE_APP_MESSAGE,
  ON_SAVE_EXIT_STATE,
  ON_NAVIGATION_BAR_BUTTON_TAP,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED
];
const MINI_PROGRAM_PAGE_RUNTIME_HOOKS = /* @__PURE__ */ (() => {
  return {
    onPageScroll: 1,
    onShareAppMessage: 1 << 1,
    onShareTimeline: 1 << 2
  };
})();
let vueApp;
const createVueAppHooks = [];
function onCreateVueApp(hook) {
  if (vueApp) {
    return hook(vueApp);
  }
  createVueAppHooks.push(hook);
}
function invokeCreateVueAppHook(app) {
  vueApp = app;
  createVueAppHooks.forEach((hook) => hook(app));
}
const E = function() {
};
E.prototype = {
  on: function(name, callback, ctx) {
    var e = this.e || (this.e = {});
    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx
    });
    return this;
  },
  once: function(name, callback, ctx) {
    var self2 = this;
    function listener() {
      self2.off(name, listener);
      callback.apply(ctx, arguments);
    }
    listener._ = callback;
    return this.on(name, listener, ctx);
  },
  emit: function(name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;
    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }
    return this;
  },
  off: function(name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];
    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }
    liveEvents.length ? e[name] = liveEvents : delete e[name];
    return this;
  }
};
var E$1 = E;
const LOCALE_ZH_HANS = "zh-Hans";
const LOCALE_ZH_HANT = "zh-Hant";
const LOCALE_EN = "en";
const LOCALE_FR = "fr";
const LOCALE_ES = "es";
function include(str, parts) {
  return !!parts.find((part) => str.indexOf(part) !== -1);
}
function startsWith(str, parts) {
  return parts.find((part) => str.indexOf(part) === 0);
}
function normalizeLocale(locale, messages) {
  if (!locale) {
    return;
  }
  locale = locale.trim().replace(/_/g, "-");
  if (messages && messages[locale]) {
    return locale;
  }
  locale = locale.toLowerCase();
  if (locale === "chinese") {
    return LOCALE_ZH_HANS;
  }
  if (locale.indexOf("zh") === 0) {
    if (locale.indexOf("-hans") > -1) {
      return LOCALE_ZH_HANS;
    }
    if (locale.indexOf("-hant") > -1) {
      return LOCALE_ZH_HANT;
    }
    if (include(locale, ["-tw", "-hk", "-mo", "-cht"])) {
      return LOCALE_ZH_HANT;
    }
    return LOCALE_ZH_HANS;
  }
  const lang = startsWith(locale, [LOCALE_EN, LOCALE_FR, LOCALE_ES]);
  if (lang) {
    return lang;
  }
}
function getBaseSystemInfo() {
  return wx.getSystemInfoSync();
}
function validateProtocolFail(name, msg) {
  console.warn(`${name}: ${msg}`);
}
function validateProtocol(name, data, protocol, onFail) {
  if (!onFail) {
    onFail = validateProtocolFail;
  }
  for (const key in protocol) {
    const errMsg = validateProp$1(key, data[key], protocol[key], !hasOwn(data, key));
    if (isString(errMsg)) {
      onFail(name, errMsg);
    }
  }
}
function validateProtocols(name, args, protocol, onFail) {
  if (!protocol) {
    return;
  }
  if (!isArray(protocol)) {
    return validateProtocol(name, args[0] || /* @__PURE__ */ Object.create(null), protocol, onFail);
  }
  const len = protocol.length;
  const argsLen = args.length;
  for (let i = 0; i < len; i++) {
    const opts = protocol[i];
    const data = /* @__PURE__ */ Object.create(null);
    if (argsLen > i) {
      data[opts.name] = args[i];
    }
    validateProtocol(name, data, { [opts.name]: opts }, onFail);
  }
}
function validateProp$1(name, value, prop, isAbsent) {
  if (!isPlainObject(prop)) {
    prop = { type: prop };
  }
  const { type, required, validator } = prop;
  if (required && isAbsent) {
    return 'Missing required args: "' + name + '"';
  }
  if (value == null && !required) {
    return;
  }
  if (type != null) {
    let isValid = false;
    const types = isArray(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType$1(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      return getInvalidTypeMessage$1(name, value, expectedTypes);
    }
  }
  if (validator) {
    return validator(value);
  }
}
const isSimpleType$1 = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol");
function assertType$1(value, type) {
  let valid;
  const expectedType = getType$1(type);
  if (isSimpleType$1(expectedType)) {
    const t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject(value);
  } else if (expectedType === "Array") {
    valid = isArray(value);
  } else {
    {
      valid = value instanceof type;
    }
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage$1(name, value, expectedTypes) {
  let message = `Invalid args: type check failed for args "${name}". Expected ${expectedTypes.map(capitalize).join(", ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue$1(value, expectedType);
  const receivedValue = styleValue$1(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable$1(expectedType) && !isBoolean$1(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable$1(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function getType$1(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : "";
}
function styleValue$1(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable$1(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean$1(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
function tryCatch(fn) {
  return function() {
    try {
      return fn.apply(fn, arguments);
    } catch (e) {
      console.error(e);
    }
  };
}
let invokeCallbackId = 1;
const invokeCallbacks = {};
function addInvokeCallback(id, name, callback, keepAlive = false) {
  invokeCallbacks[id] = {
    name,
    keepAlive,
    callback
  };
  return id;
}
function invokeCallback(id, res, extras) {
  if (typeof id === "number") {
    const opts = invokeCallbacks[id];
    if (opts) {
      if (!opts.keepAlive) {
        delete invokeCallbacks[id];
      }
      return opts.callback(res, extras);
    }
  }
  return res;
}
const API_SUCCESS = "success";
const API_FAIL = "fail";
const API_COMPLETE = "complete";
function getApiCallbacks(args) {
  const apiCallbacks = {};
  for (const name in args) {
    const fn = args[name];
    if (isFunction(fn)) {
      apiCallbacks[name] = tryCatch(fn);
      delete args[name];
    }
  }
  return apiCallbacks;
}
function normalizeErrMsg$1(errMsg, name) {
  if (!errMsg || errMsg.indexOf(":fail") === -1) {
    return name + ":ok";
  }
  return name + errMsg.substring(errMsg.indexOf(":fail"));
}
function createAsyncApiCallback(name, args = {}, { beforeAll, beforeSuccess } = {}) {
  if (!isPlainObject(args)) {
    args = {};
  }
  const { success, fail, complete } = getApiCallbacks(args);
  const hasSuccess = isFunction(success);
  const hasFail = isFunction(fail);
  const hasComplete = isFunction(complete);
  const callbackId = invokeCallbackId++;
  addInvokeCallback(callbackId, name, (res) => {
    res = res || {};
    res.errMsg = normalizeErrMsg$1(res.errMsg, name);
    isFunction(beforeAll) && beforeAll(res);
    if (res.errMsg === name + ":ok") {
      isFunction(beforeSuccess) && beforeSuccess(res, args);
      hasSuccess && success(res);
    } else {
      hasFail && fail(res);
    }
    hasComplete && complete(res);
  });
  return callbackId;
}
const HOOK_SUCCESS = "success";
const HOOK_FAIL = "fail";
const HOOK_COMPLETE = "complete";
const globalInterceptors = {};
const scopedInterceptors = {};
function wrapperHook(hook) {
  return function(data) {
    return hook(data) || data;
  };
}
function queue$1(hooks, data) {
  let promise = false;
  for (let i = 0; i < hooks.length; i++) {
    const hook = hooks[i];
    if (promise) {
      promise = Promise.resolve(wrapperHook(hook));
    } else {
      const res = hook(data);
      if (isPromise(res)) {
        promise = Promise.resolve(res);
      }
      if (res === false) {
        return {
          then() {
          },
          catch() {
          }
        };
      }
    }
  }
  return promise || {
    then(callback) {
      return callback(data);
    },
    catch() {
    }
  };
}
function wrapperOptions(interceptors2, options = {}) {
  [HOOK_SUCCESS, HOOK_FAIL, HOOK_COMPLETE].forEach((name) => {
    const hooks = interceptors2[name];
    if (!isArray(hooks)) {
      return;
    }
    const oldCallback = options[name];
    options[name] = function callbackInterceptor(res) {
      queue$1(hooks, res).then((res2) => {
        return isFunction(oldCallback) && oldCallback(res2) || res2;
      });
    };
  });
  return options;
}
function wrapperReturnValue(method, returnValue) {
  const returnValueHooks = [];
  if (isArray(globalInterceptors.returnValue)) {
    returnValueHooks.push(...globalInterceptors.returnValue);
  }
  const interceptor = scopedInterceptors[method];
  if (interceptor && isArray(interceptor.returnValue)) {
    returnValueHooks.push(...interceptor.returnValue);
  }
  returnValueHooks.forEach((hook) => {
    returnValue = hook(returnValue) || returnValue;
  });
  return returnValue;
}
function getApiInterceptorHooks(method) {
  const interceptor = /* @__PURE__ */ Object.create(null);
  Object.keys(globalInterceptors).forEach((hook) => {
    if (hook !== "returnValue") {
      interceptor[hook] = globalInterceptors[hook].slice();
    }
  });
  const scopedInterceptor = scopedInterceptors[method];
  if (scopedInterceptor) {
    Object.keys(scopedInterceptor).forEach((hook) => {
      if (hook !== "returnValue") {
        interceptor[hook] = (interceptor[hook] || []).concat(scopedInterceptor[hook]);
      }
    });
  }
  return interceptor;
}
function invokeApi(method, api, options, params) {
  const interceptor = getApiInterceptorHooks(method);
  if (interceptor && Object.keys(interceptor).length) {
    if (isArray(interceptor.invoke)) {
      const res = queue$1(interceptor.invoke, options);
      return res.then((options2) => {
        return api(wrapperOptions(interceptor, options2), ...params);
      });
    } else {
      return api(wrapperOptions(interceptor, options), ...params);
    }
  }
  return api(options, ...params);
}
function hasCallback(args) {
  if (isPlainObject(args) && [API_SUCCESS, API_FAIL, API_COMPLETE].find((cb) => isFunction(args[cb]))) {
    return true;
  }
  return false;
}
function handlePromise(promise) {
  return promise;
}
function promisify$1(name, fn) {
  return (args = {}, ...rest) => {
    if (hasCallback(args)) {
      return wrapperReturnValue(name, invokeApi(name, fn, args, rest));
    }
    return wrapperReturnValue(name, handlePromise(new Promise((resolve, reject) => {
      invokeApi(name, fn, extend(args, { success: resolve, fail: reject }), rest);
    })));
  };
}
function formatApiArgs(args, options) {
  const params = args[0];
  if (!options || !isPlainObject(options.formatArgs) && isPlainObject(params)) {
    return;
  }
  const formatArgs = options.formatArgs;
  const keys = Object.keys(formatArgs);
  for (let i = 0; i < keys.length; i++) {
    const name = keys[i];
    const formatterOrDefaultValue = formatArgs[name];
    if (isFunction(formatterOrDefaultValue)) {
      const errMsg = formatterOrDefaultValue(args[0][name], params);
      if (isString(errMsg)) {
        return errMsg;
      }
    } else {
      if (!hasOwn(params, name)) {
        params[name] = formatterOrDefaultValue;
      }
    }
  }
}
function invokeSuccess(id, name, res) {
  return invokeCallback(id, extend(res || {}, { errMsg: name + ":ok" }));
}
function invokeFail(id, name, errMsg, errRes) {
  return invokeCallback(id, extend({ errMsg: name + ":fail" + (errMsg ? " " + errMsg : "") }, errRes));
}
function beforeInvokeApi(name, args, protocol, options) {
  {
    validateProtocols(name, args, protocol);
  }
  if (options && options.beforeInvoke) {
    const errMsg2 = options.beforeInvoke(args);
    if (isString(errMsg2)) {
      return errMsg2;
    }
  }
  const errMsg = formatApiArgs(args, options);
  if (errMsg) {
    return errMsg;
  }
}
function normalizeErrMsg(errMsg) {
  if (!errMsg || isString(errMsg)) {
    return errMsg;
  }
  if (errMsg.stack) {
    console.error(errMsg.message + LINEFEED + errMsg.stack);
    return errMsg.message;
  }
  return errMsg;
}
function wrapperTaskApi(name, fn, protocol, options) {
  return (args) => {
    const id = createAsyncApiCallback(name, args, options);
    const errMsg = beforeInvokeApi(name, [args], protocol, options);
    if (errMsg) {
      return invokeFail(id, name, errMsg);
    }
    return fn(args, {
      resolve: (res) => invokeSuccess(id, name, res),
      reject: (errMsg2, errRes) => invokeFail(id, name, normalizeErrMsg(errMsg2), errRes)
    });
  };
}
function wrapperSyncApi(name, fn, protocol, options) {
  return (...args) => {
    const errMsg = beforeInvokeApi(name, args, protocol, options);
    if (errMsg) {
      throw new Error(errMsg);
    }
    return fn.apply(null, args);
  };
}
function wrapperAsyncApi(name, fn, protocol, options) {
  return wrapperTaskApi(name, fn, protocol, options);
}
function defineSyncApi(name, fn, protocol, options) {
  return wrapperSyncApi(name, fn, protocol, options);
}
function defineAsyncApi(name, fn, protocol, options) {
  return promisify$1(name, wrapperAsyncApi(name, fn, protocol, options));
}
const API_UPX2PX = "upx2px";
const Upx2pxProtocol = [
  {
    name: "upx",
    type: [Number, String],
    required: true
  }
];
const EPS = 1e-4;
const BASE_DEVICE_WIDTH = 750;
let isIOS = false;
let deviceWidth = 0;
let deviceDPR = 0;
function checkDeviceWidth() {
  const { platform, pixelRatio, windowWidth } = getBaseSystemInfo();
  deviceWidth = windowWidth;
  deviceDPR = pixelRatio;
  isIOS = platform === "ios";
}
const upx2px = defineSyncApi(API_UPX2PX, (number, newDeviceWidth) => {
  if (deviceWidth === 0) {
    checkDeviceWidth();
  }
  number = Number(number);
  if (number === 0) {
    return 0;
  }
  let width = newDeviceWidth || deviceWidth;
  let result = number / BASE_DEVICE_WIDTH * width;
  if (result < 0) {
    result = -result;
  }
  result = Math.floor(result + EPS);
  if (result === 0) {
    if (deviceDPR === 1 || !isIOS) {
      result = 1;
    } else {
      result = 0.5;
    }
  }
  return number < 0 ? -result : result;
}, Upx2pxProtocol);
const API_ADD_INTERCEPTOR = "addInterceptor";
const API_REMOVE_INTERCEPTOR = "removeInterceptor";
const AddInterceptorProtocol = [
  {
    name: "method",
    type: [String, Object],
    required: true
  }
];
const RemoveInterceptorProtocol = AddInterceptorProtocol;
function mergeInterceptorHook(interceptors2, interceptor) {
  Object.keys(interceptor).forEach((hook) => {
    if (isFunction(interceptor[hook])) {
      interceptors2[hook] = mergeHook(interceptors2[hook], interceptor[hook]);
    }
  });
}
function removeInterceptorHook(interceptors2, interceptor) {
  if (!interceptors2 || !interceptor) {
    return;
  }
  Object.keys(interceptor).forEach((name) => {
    const hooks = interceptors2[name];
    const hook = interceptor[name];
    if (isArray(hooks) && isFunction(hook)) {
      remove(hooks, hook);
    }
  });
}
function mergeHook(parentVal, childVal) {
  const res = childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}
function dedupeHooks(hooks) {
  const res = [];
  for (let i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res;
}
const addInterceptor = defineSyncApi(API_ADD_INTERCEPTOR, (method, interceptor) => {
  if (isString(method) && isPlainObject(interceptor)) {
    mergeInterceptorHook(scopedInterceptors[method] || (scopedInterceptors[method] = {}), interceptor);
  } else if (isPlainObject(method)) {
    mergeInterceptorHook(globalInterceptors, method);
  }
}, AddInterceptorProtocol);
const removeInterceptor = defineSyncApi(API_REMOVE_INTERCEPTOR, (method, interceptor) => {
  if (isString(method)) {
    if (isPlainObject(interceptor)) {
      removeInterceptorHook(scopedInterceptors[method], interceptor);
    } else {
      delete scopedInterceptors[method];
    }
  } else if (isPlainObject(method)) {
    removeInterceptorHook(globalInterceptors, method);
  }
}, RemoveInterceptorProtocol);
const interceptors = {};
const API_ON = "$on";
const OnProtocol = [
  {
    name: "event",
    type: String,
    required: true
  },
  {
    name: "callback",
    type: Function,
    required: true
  }
];
const API_ONCE = "$once";
const OnceProtocol = OnProtocol;
const API_OFF = "$off";
const OffProtocol = [
  {
    name: "event",
    type: [String, Array]
  },
  {
    name: "callback",
    type: Function
  }
];
const API_EMIT = "$emit";
const EmitProtocol = [
  {
    name: "event",
    type: String,
    required: true
  }
];
const emitter = new E$1();
const $on = defineSyncApi(API_ON, (name, callback) => {
  emitter.on(name, callback);
  return () => emitter.off(name, callback);
}, OnProtocol);
const $once = defineSyncApi(API_ONCE, (name, callback) => {
  emitter.once(name, callback);
  return () => emitter.off(name, callback);
}, OnceProtocol);
const $off = defineSyncApi(API_OFF, (name, callback) => {
  if (!name) {
    emitter.e = {};
    return;
  }
  if (!isArray(name))
    name = [name];
  name.forEach((n) => emitter.off(n, callback));
}, OffProtocol);
const $emit = defineSyncApi(API_EMIT, (name, ...args) => {
  emitter.emit(name, ...args);
}, EmitProtocol);
let cid;
let cidErrMsg;
let enabled;
function normalizePushMessage(message) {
  try {
    return JSON.parse(message);
  } catch (e) {
  }
  return message;
}
function invokePushCallback(args) {
  if (args.type === "enabled") {
    enabled = true;
  } else if (args.type === "clientId") {
    cid = args.cid;
    cidErrMsg = args.errMsg;
    invokeGetPushCidCallbacks(cid, args.errMsg);
  } else if (args.type === "pushMsg") {
    const message = {
      type: "receive",
      data: normalizePushMessage(args.message)
    };
    for (let i = 0; i < onPushMessageCallbacks.length; i++) {
      const callback = onPushMessageCallbacks[i];
      callback(message);
      if (message.stopped) {
        break;
      }
    }
  } else if (args.type === "click") {
    onPushMessageCallbacks.forEach((callback) => {
      callback({
        type: "click",
        data: normalizePushMessage(args.message)
      });
    });
  }
}
const getPushCidCallbacks = [];
function invokeGetPushCidCallbacks(cid2, errMsg) {
  getPushCidCallbacks.forEach((callback) => {
    callback(cid2, errMsg);
  });
  getPushCidCallbacks.length = 0;
}
const API_GET_PUSH_CLIENT_ID = "getPushClientId";
const getPushClientId = defineAsyncApi(API_GET_PUSH_CLIENT_ID, (_, { resolve, reject }) => {
  Promise.resolve().then(() => {
    if (typeof enabled === "undefined") {
      enabled = false;
      cid = "";
      cidErrMsg = "unipush is not enabled";
    }
    getPushCidCallbacks.push((cid2, errMsg) => {
      if (cid2) {
        resolve({ cid: cid2 });
      } else {
        reject(errMsg);
      }
    });
    if (typeof cid !== "undefined") {
      invokeGetPushCidCallbacks(cid, cidErrMsg);
    }
  });
});
const onPushMessageCallbacks = [];
const onPushMessage = (fn) => {
  if (onPushMessageCallbacks.indexOf(fn) === -1) {
    onPushMessageCallbacks.push(fn);
  }
};
const offPushMessage = (fn) => {
  if (!fn) {
    onPushMessageCallbacks.length = 0;
  } else {
    const index2 = onPushMessageCallbacks.indexOf(fn);
    if (index2 > -1) {
      onPushMessageCallbacks.splice(index2, 1);
    }
  }
};
const SYNC_API_RE = /^\$|getLocale|setLocale|sendNativeEvent|restoreGlobal|requireGlobal|getCurrentSubNVue|getMenuButtonBoundingClientRect|^report|interceptors|Interceptor$|getSubNVueById|requireNativePlugin|upx2px|hideKeyboard|canIUse|^create|Sync$|Manager$|base64ToArrayBuffer|arrayBufferToBase64|getDeviceInfo|getAppBaseInfo|getWindowInfo|getSystemSetting|getAppAuthorizeSetting/;
const CONTEXT_API_RE = /^create|Manager$/;
const CONTEXT_API_RE_EXC = ["createBLEConnection"];
const ASYNC_API = ["createBLEConnection"];
const CALLBACK_API_RE = /^on|^off/;
function isContextApi(name) {
  return CONTEXT_API_RE.test(name) && CONTEXT_API_RE_EXC.indexOf(name) === -1;
}
function isSyncApi(name) {
  return SYNC_API_RE.test(name) && ASYNC_API.indexOf(name) === -1;
}
function isCallbackApi(name) {
  return CALLBACK_API_RE.test(name) && name !== "onPush";
}
function shouldPromise(name) {
  if (isContextApi(name) || isSyncApi(name) || isCallbackApi(name)) {
    return false;
  }
  return true;
}
if (!Promise.prototype.finally) {
  Promise.prototype.finally = function(onfinally) {
    const promise = this.constructor;
    return this.then((value) => promise.resolve(onfinally && onfinally()).then(() => value), (reason) => promise.resolve(onfinally && onfinally()).then(() => {
      throw reason;
    }));
  };
}
function promisify(name, api) {
  if (!shouldPromise(name)) {
    return api;
  }
  if (!isFunction(api)) {
    return api;
  }
  return function promiseApi(options = {}, ...rest) {
    if (isFunction(options.success) || isFunction(options.fail) || isFunction(options.complete)) {
      return wrapperReturnValue(name, invokeApi(name, api, options, rest));
    }
    return wrapperReturnValue(name, handlePromise(new Promise((resolve, reject) => {
      invokeApi(name, api, extend({}, options, {
        success: resolve,
        fail: reject
      }), rest);
    })));
  };
}
const CALLBACKS = ["success", "fail", "cancel", "complete"];
function initWrapper(protocols2) {
  function processCallback(methodName, method, returnValue) {
    return function(res) {
      return method(processReturnValue(methodName, res, returnValue));
    };
  }
  function processArgs(methodName, fromArgs, argsOption = {}, returnValue = {}, keepFromArgs = false) {
    if (isPlainObject(fromArgs)) {
      const toArgs = keepFromArgs === true ? fromArgs : {};
      if (isFunction(argsOption)) {
        argsOption = argsOption(fromArgs, toArgs) || {};
      }
      for (const key in fromArgs) {
        if (hasOwn(argsOption, key)) {
          let keyOption = argsOption[key];
          if (isFunction(keyOption)) {
            keyOption = keyOption(fromArgs[key], fromArgs, toArgs);
          }
          if (!keyOption) {
            console.warn(`\u5FAE\u4FE1\u5C0F\u7A0B\u5E8F ${methodName} \u6682\u4E0D\u652F\u6301 ${key}`);
          } else if (isString(keyOption)) {
            toArgs[keyOption] = fromArgs[key];
          } else if (isPlainObject(keyOption)) {
            toArgs[keyOption.name ? keyOption.name : key] = keyOption.value;
          }
        } else if (CALLBACKS.indexOf(key) !== -1) {
          const callback = fromArgs[key];
          if (isFunction(callback)) {
            toArgs[key] = processCallback(methodName, callback, returnValue);
          }
        } else {
          if (!keepFromArgs && !hasOwn(toArgs, key)) {
            toArgs[key] = fromArgs[key];
          }
        }
      }
      return toArgs;
    } else if (isFunction(fromArgs)) {
      fromArgs = processCallback(methodName, fromArgs, returnValue);
    }
    return fromArgs;
  }
  function processReturnValue(methodName, res, returnValue, keepReturnValue = false) {
    if (isFunction(protocols2.returnValue)) {
      res = protocols2.returnValue(methodName, res);
    }
    return processArgs(methodName, res, returnValue, {}, keepReturnValue);
  }
  return function wrapper(methodName, method) {
    if (!hasOwn(protocols2, methodName)) {
      return method;
    }
    const protocol = protocols2[methodName];
    if (!protocol) {
      return function() {
        console.error(`\u5FAE\u4FE1\u5C0F\u7A0B\u5E8F \u6682\u4E0D\u652F\u6301${methodName}`);
      };
    }
    return function(arg1, arg2) {
      let options = protocol;
      if (isFunction(protocol)) {
        options = protocol(arg1);
      }
      arg1 = processArgs(methodName, arg1, options.args, options.returnValue);
      const args = [arg1];
      if (typeof arg2 !== "undefined") {
        args.push(arg2);
      }
      const returnValue = wx[options.name || methodName].apply(wx, args);
      if (isSyncApi(methodName)) {
        return processReturnValue(methodName, returnValue, options.returnValue, isContextApi(methodName));
      }
      return returnValue;
    };
  };
}
const getLocale = () => {
  const app = getApp({ allowDefault: true });
  if (app && app.$vm) {
    return app.$vm.$locale;
  }
  return normalizeLocale(wx.getSystemInfoSync().language) || LOCALE_EN;
};
const setLocale = (locale) => {
  const app = getApp();
  if (!app) {
    return false;
  }
  const oldLocale = app.$vm.$locale;
  if (oldLocale !== locale) {
    app.$vm.$locale = locale;
    onLocaleChangeCallbacks.forEach((fn) => fn({ locale }));
    return true;
  }
  return false;
};
const onLocaleChangeCallbacks = [];
const onLocaleChange = (fn) => {
  if (onLocaleChangeCallbacks.indexOf(fn) === -1) {
    onLocaleChangeCallbacks.push(fn);
  }
};
if (typeof global !== "undefined") {
  global.getLocale = getLocale;
}
const baseApis = {
  $on,
  $off,
  $once,
  $emit,
  upx2px,
  interceptors,
  addInterceptor,
  removeInterceptor,
  onCreateVueApp,
  invokeCreateVueAppHook,
  getLocale,
  setLocale,
  onLocaleChange,
  getPushClientId,
  onPushMessage,
  offPushMessage,
  invokePushCallback
};
function initUni(api, protocols2) {
  const wrapper = initWrapper(protocols2);
  const UniProxyHandlers = {
    get(target, key) {
      if (hasOwn(target, key)) {
        return target[key];
      }
      if (hasOwn(api, key)) {
        return promisify(key, api[key]);
      }
      if (hasOwn(baseApis, key)) {
        return promisify(key, baseApis[key]);
      }
      return promisify(key, wrapper(key, wx[key]));
    }
  };
  return new Proxy({}, UniProxyHandlers);
}
function initGetProvider(providers) {
  return function getProvider2({ service, success, fail, complete }) {
    let res;
    if (providers[service]) {
      res = {
        errMsg: "getProvider:ok",
        service,
        provider: providers[service]
      };
      isFunction(success) && success(res);
    } else {
      res = {
        errMsg: "getProvider:fail:\u670D\u52A1[" + service + "]\u4E0D\u5B58\u5728"
      };
      isFunction(fail) && fail(res);
    }
    isFunction(complete) && complete(res);
  };
}
const UUID_KEY = "__DC_STAT_UUID";
let deviceId;
function useDeviceId(global2 = wx) {
  return function addDeviceId(_, toRes) {
    deviceId = deviceId || global2.getStorageSync(UUID_KEY);
    if (!deviceId) {
      deviceId = Date.now() + "" + Math.floor(Math.random() * 1e7);
      wx.setStorage({
        key: UUID_KEY,
        data: deviceId
      });
    }
    toRes.deviceId = deviceId;
  };
}
function addSafeAreaInsets(fromRes, toRes) {
  if (fromRes.safeArea) {
    const safeArea = fromRes.safeArea;
    toRes.safeAreaInsets = {
      top: safeArea.top,
      left: safeArea.left,
      right: fromRes.windowWidth - safeArea.right,
      bottom: fromRes.screenHeight - safeArea.bottom
    };
  }
}
function populateParameters(fromRes, toRes) {
  const { brand = "", model = "", system = "", language = "", theme, version: version2, platform, fontSizeSetting, SDKVersion, pixelRatio, deviceOrientation } = fromRes;
  let osName = "";
  let osVersion = "";
  {
    osName = system.split(" ")[0] || "";
    osVersion = system.split(" ")[1] || "";
  }
  let hostVersion = version2;
  let deviceType = getGetDeviceType(fromRes, model);
  let deviceBrand = getDeviceBrand(brand);
  let _hostName = getHostName(fromRes);
  let _deviceOrientation = deviceOrientation;
  let _devicePixelRatio = pixelRatio;
  let _SDKVersion = SDKVersion;
  const hostLanguage = language.replace(/_/g, "-");
  const parameters = {
    appId: "",
    appName: "wechat-vision-ar",
    appVersion: "1.0.0",
    appVersionCode: "100",
    appLanguage: getAppLanguage(hostLanguage),
    uniCompileVersion: "3.5.3",
    uniRuntimeVersion: "3.5.3",
    uniPlatform: "mp-weixin",
    deviceBrand,
    deviceModel: model,
    deviceType,
    devicePixelRatio: _devicePixelRatio,
    deviceOrientation: _deviceOrientation,
    osName: osName.toLocaleLowerCase(),
    osVersion,
    hostTheme: theme,
    hostVersion,
    hostLanguage,
    hostName: _hostName,
    hostSDKVersion: _SDKVersion,
    hostFontSizeSetting: fontSizeSetting,
    windowTop: 0,
    windowBottom: 0,
    osLanguage: void 0,
    osTheme: void 0,
    ua: void 0,
    hostPackageName: void 0,
    browserName: void 0,
    browserVersion: void 0
  };
  extend(toRes, parameters);
}
function getGetDeviceType(fromRes, model) {
  let deviceType = fromRes.deviceType || "phone";
  {
    const deviceTypeMaps = {
      ipad: "pad",
      windows: "pc",
      mac: "pc"
    };
    const deviceTypeMapsKeys = Object.keys(deviceTypeMaps);
    const _model = model.toLocaleLowerCase();
    for (let index2 = 0; index2 < deviceTypeMapsKeys.length; index2++) {
      const _m = deviceTypeMapsKeys[index2];
      if (_model.indexOf(_m) !== -1) {
        deviceType = deviceTypeMaps[_m];
        break;
      }
    }
  }
  return deviceType;
}
function getDeviceBrand(brand) {
  let deviceBrand = brand;
  if (deviceBrand) {
    deviceBrand = deviceBrand.toLocaleLowerCase();
  }
  return deviceBrand;
}
function getAppLanguage(defaultLanguage) {
  return getLocale ? getLocale() : defaultLanguage;
}
function getHostName(fromRes) {
  const _platform = "WeChat";
  let _hostName = fromRes.hostName || _platform;
  {
    if (fromRes.environment) {
      _hostName = fromRes.environment;
    } else if (fromRes.host && fromRes.host.env) {
      _hostName = fromRes.host.env;
    }
  }
  return _hostName;
}
const getSystemInfo = {
  returnValue: (fromRes, toRes) => {
    addSafeAreaInsets(fromRes, toRes);
    useDeviceId()(fromRes, toRes);
    populateParameters(fromRes, toRes);
  }
};
const getSystemInfoSync = getSystemInfo;
const redirectTo = {};
const previewImage = {
  args(fromArgs, toArgs) {
    let currentIndex = parseInt(fromArgs.current);
    if (isNaN(currentIndex)) {
      return;
    }
    const urls = fromArgs.urls;
    if (!isArray(urls)) {
      return;
    }
    const len = urls.length;
    if (!len) {
      return;
    }
    if (currentIndex < 0) {
      currentIndex = 0;
    } else if (currentIndex >= len) {
      currentIndex = len - 1;
    }
    if (currentIndex > 0) {
      toArgs.current = urls[currentIndex];
      toArgs.urls = urls.filter((item, index2) => index2 < currentIndex ? item !== urls[currentIndex] : true);
    } else {
      toArgs.current = urls[0];
    }
    return {
      indicator: false,
      loop: false
    };
  }
};
const showActionSheet = {
  args(fromArgs, toArgs) {
    toArgs.alertText = fromArgs.title;
  }
};
const getDeviceInfo = {
  returnValue: (fromRes, toRes) => {
    const { brand, model } = fromRes;
    let deviceType = getGetDeviceType(fromRes, model);
    let deviceBrand = getDeviceBrand(brand);
    useDeviceId()(fromRes, toRes);
    toRes = sortObject(extend(toRes, {
      deviceType,
      deviceBrand,
      deviceModel: model
    }));
  }
};
const getAppBaseInfo = {
  returnValue: (fromRes, toRes) => {
    const { version: version2, language, SDKVersion, theme } = fromRes;
    let _hostName = getHostName(fromRes);
    let hostLanguage = language.replace(/_/g, "-");
    toRes = sortObject(extend(toRes, {
      hostVersion: version2,
      hostLanguage,
      hostName: _hostName,
      hostSDKVersion: SDKVersion,
      hostTheme: theme,
      appId: "",
      appName: "wechat-vision-ar",
      appVersion: "1.0.0",
      appVersionCode: "100",
      appLanguage: getAppLanguage(hostLanguage)
    }));
  }
};
const getWindowInfo = {
  returnValue: (fromRes, toRes) => {
    addSafeAreaInsets(fromRes, toRes);
    toRes = sortObject(extend(toRes, {
      windowTop: 0,
      windowBottom: 0
    }));
  }
};
const getAppAuthorizeSetting = {
  returnValue: function(fromRes, toRes) {
    const { locationReducedAccuracy } = fromRes;
    toRes.locationAccuracy = "unsupported";
    if (locationReducedAccuracy === true) {
      toRes.locationAccuracy = "reduced";
    } else if (locationReducedAccuracy === false) {
      toRes.locationAccuracy = "full";
    }
  }
};
const mocks$1 = ["__route__", "__wxExparserNodeId__", "__wxWebviewId__"];
const getProvider = initGetProvider({
  oauth: ["weixin"],
  share: ["weixin"],
  payment: ["wxpay"],
  push: ["weixin"]
});
function initComponentMocks(component) {
  const res = /* @__PURE__ */ Object.create(null);
  mocks$1.forEach((name) => {
    res[name] = component[name];
  });
  return res;
}
function createSelectorQuery() {
  const query = wx.createSelectorQuery();
  const oldIn = query.in;
  query.in = function newIn(component) {
    return oldIn.call(this, initComponentMocks(component));
  };
  return query;
}
var shims = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  getProvider,
  createSelectorQuery
});
var protocols = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  redirectTo,
  previewImage,
  getSystemInfo,
  getSystemInfoSync,
  showActionSheet,
  getDeviceInfo,
  getAppBaseInfo,
  getWindowInfo,
  getAppAuthorizeSetting
});
var index = initUni(shims, protocols);
function warn(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn) {
    if (this.active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else {
      warn(`cannot run an inactive effect scope.`);
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.active = false;
    }
  }
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo = { effect: activeEffect, target, type, key };
    trackEffects(dep, eventInfo);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (activeEffect.onTrack) {
      activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo = { target, type, key, newValue, oldValue, oldTarget };
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0], eventInfo);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects), eventInfo);
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray(dep) ? dep : [...dep];
  for (const effect of effects) {
    if (effect.computed) {
      triggerEffect(effect, debuggerEventExtraInfo);
    }
  }
  for (const effect of effects) {
    if (!effect.computed) {
      triggerEffect(effect, debuggerEventExtraInfo);
    }
  }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
  if (effect !== activeEffect || effect.allowRecurse) {
    if (effect.onTrigger) {
      effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));
    }
    if (effect.scheduler) {
      effect.scheduler();
    } else {
      effect.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol));
const get = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow && !isReadonly(value)) {
      if (!isShallow(value)) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get,
  set: set$1,
  deleteProperty,
  has,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    {
      warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    {
      warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ extend({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = isMap(target) ? new Map(target) : new Set(target);
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()), {
        target: ref2,
        type: "get",
        key: "value"
      });
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      });
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this.__v_isShallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this.__v_isShallow ? newVal : toReactive(newVal);
      triggerRefValue(this, newVal);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = () => {
      console.warn("Write operation failed: computed value is readonly");
    };
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function warn$1(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [
      msg + args.join(""),
      instance && instance.proxy,
      trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
      trace
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
const ErrorTypeStrings = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = ErrorTypeStrings[type] || type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    const info = ErrorTypeStrings[type] || type;
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      console.error(err);
    } else {
      console.error(err);
    }
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function hasQueueJob(job) {
  return queue.indexOf(job) > -1;
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queueCb(cb, activeQueue, pendingQueue, index2) {
  if (!isArray(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index2 + 1 : index2)) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      if (checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
        continue;
      }
      activePreFlushCbs[preFlushIndex]();
    }
    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    flushPreFlushCbs(seen, parentJob);
  }
}
function flushPostFlushCbs(seen) {
  flushPreFlushCbs();
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  {
    seen = seen || /* @__PURE__ */ new Map();
  }
  flushPreFlushCbs(seen);
  queue.sort((a, b) => getId(a) - getId(b));
  const check = (job) => checkRecursiveUpdates(seen, job);
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (check(job)) {
          continue;
        }
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count = seen.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      warn$1(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
function emit(event, ...args) {
}
function devtoolsComponentEmit(component, event, params) {
  emit("component:emit", component.appContext.app, component, event, params);
}
function emit$1(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  {
    const { emitsOptions, propsOptions: [propsOptions] } = instance;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
          warn$1(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`);
        }
      } else {
        const validator = emitsOptions[event];
        if (isFunction(validator)) {
          const isValid = validator(...rawArgs);
          if (!isValid) {
            warn$1(`Invalid event arguments: event validation failed for event "${event}".`);
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => a.trim());
    }
    if (number) {
      args = rawArgs.map(toNumber);
    }
  }
  {
    devtoolsComponentEmit(instance, event, args);
  }
  {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
      warn$1(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event)}" instead of "${event}".`);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, null);
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  cache.set(comp, normalized);
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  instance && instance.type.__scopeId || null;
  return prev;
}
function provide(key, value) {
  if (!currentInstance) {
    {
      warn$1(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
    if (currentInstance.type.mpType === "app") {
      currentInstance.appContext.app.provide(key, value);
    }
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else {
      warn$1(`injection "${String(key)}" not found.`);
    }
  } else {
    warn$1(`inject() can only be used inside setup() or functional components.`);
  }
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if (!isFunction(cb)) {
    warn$1(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  if (!cb) {
    if (immediate !== void 0) {
      warn$1(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    if (deep !== void 0) {
      warn$1(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
  }
  const warnInvalidSource = (s) => {
    warn$1(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
  };
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else {
        warnInvalidSource(s);
      }
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
    warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    scheduler = () => {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        job();
      }
    };
  }
  const effect = new ReactiveEffect(getter, scheduler);
  {
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  return () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    if (isRootHook(type)) {
      target = target.root;
    }
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else {
    const apiName = toHandlerKey((ErrorTypeStrings[type] || type.replace(/^on/, "")).replace(/ hook$/, ""));
    warn$1(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().`);
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn$1("Do not use built-in directive ids as custom directive id: " + name);
  }
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
  $: (i) => i,
  $el: (i) => i.__$el || (i.__$el = {}),
  $data: (i) => i.data,
  $props: (i) => shallowReadonly(i.props),
  $attrs: (i) => shallowReadonly(i.attrs),
  $slots: (i) => shallowReadonly(i.slots),
  $refs: (i) => shallowReadonly(i.refs),
  $parent: (i) => getPublicInstance(i.parent),
  $root: (i) => getPublicInstance(i.root),
  $emit: (i) => i.emit,
  $options: (i) => resolveMergedOptions(i),
  $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
  $watch: (i) => instanceWatch.bind(i)
});
const isReservedPrefix = (key) => key === "_" || key === "$";
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    if (key === "__isVue") {
      return true;
    }
    if (setupState !== EMPTY_OBJ && setupState.__isScriptSetup && hasOwn(setupState, key)) {
      return setupState[key];
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else if (currentRenderingInstance && (!isString(key) || key.indexOf("__v") !== 0)) {
      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
        warn$1(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
      } else if (instance === currentRenderingInstance) {
        warn$1(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
      }
    }
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      warn$1(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      warn$1(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`, instance);
      return false;
    } else {
      if (key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || setupState !== EMPTY_OBJ && hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
{
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn$1(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
  };
}
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      set: NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const { ctx, propsOptions: [propsOptions] } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn$1(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}
function createDuplicateChecker() {
  const cache = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions$1(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = createDuplicateChecker();
  {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        }
        {
          checkDuplicateProperties("Methods", key);
        }
      } else {
        warn$1(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
      }
    }
  }
  if (dataOptions) {
    if (!isFunction(dataOptions)) {
      warn$1(`The data option must be a function. Plain object usage is no longer supported.`);
    }
    const data = dataOptions.call(publicThis, publicThis);
    if (isPromise(data)) {
      warn$1(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
    }
    if (!isObject(data)) {
      warn$1(`data() should return an object.`);
    } else {
      instance.data = reactive(data);
      {
        for (const key in data) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (get2 === NOOP) {
        warn$1(`Computed property "${key}" has no getter.`);
      }
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : () => {
        warn$1(`Write operation failed: computed property "${key}" is readonly.`);
      };
      const c = computed$1({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
      {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  {
    if (provideOptions) {
      const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
  }
  {
    if (created) {
      callHook$1(created, instance, "c");
    }
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
  if (instance.ctx.$onApplyOptions) {
    instance.ctx.$onApplyOptions(options, instance, publicThis);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        {
          warn$1(`injected property "${key}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
        }
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
    {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(isArray(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    } else {
      warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      } else {
        warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else {
    warn$1(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  cache.set(base, resolved);
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions(to, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
      warn$1(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray$1,
  created: mergeAsArray$1,
  beforeMount: mergeAsArray$1,
  mounted: mergeAsArray$1,
  beforeUpdate: mergeAsArray$1,
  updated: mergeAsArray$1,
  beforeDestroy: mergeAsArray$1,
  beforeUnmount: mergeAsArray$1,
  destroyed: mergeAsArray$1,
  unmounted: mergeAsArray$1,
  activated: mergeAsArray$1,
  deactivated: mergeAsArray$1,
  errorCaptured: mergeAsArray$1,
  serverPrefetch: mergeAsArray$1,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray$1(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(extend(/* @__PURE__ */ Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray$1(to[key], from[key]);
  }
  return merged;
}
function initProps$1(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (!(instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
  {
    validateProps(rawProps || {}, props, instance);
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, EMPTY_ARR);
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if (!isString(raw[i])) {
        warn$1(`props must be strings when using array syntax.`, raw[i]);
      }
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (!isObject(raw)) {
      warn$1(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : opt;
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  cache.set(comp, res);
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  } else {
    warn$1(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options = instance.propsOptions[0];
  for (const key in options) {
    let opt = options[key];
    if (opt == null)
      continue;
    validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
  }
}
function validateProp(name, value, prop, isAbsent) {
  const { type, required, validator } = prop;
  if (required && isAbsent) {
    warn$1('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  if (type != null && type !== true) {
    let isValid = false;
    const types = isArray(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn$1(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value)) {
    warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject(value);
  } else if (expectedType === "Array") {
    valid = isArray(value);
  } else if (expectedType === "null") {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      warn$1(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    const app = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
        {
          warn$1(`app.config cannot be replaced. Modify individual options instead.`);
        }
      },
      use(plugin2, ...options) {
        if (installedPlugins.has(plugin2)) {
          warn$1(`Plugin has already been applied to target app.`);
        } else if (plugin2 && isFunction(plugin2.install)) {
          installedPlugins.add(plugin2);
          plugin2.install(app, ...options);
        } else if (isFunction(plugin2)) {
          installedPlugins.add(plugin2);
          plugin2(app, ...options);
        } else {
          warn$1(`A plugin must either be a function or an object with an "install" function.`);
        }
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else {
            warn$1("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
          }
        }
        return app;
      },
      component(name, component) {
        {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if (context.components[name]) {
          warn$1(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if (context.directives[name]) {
          warn$1(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app;
      },
      mount() {
      },
      unmount() {
      },
      provide(key, value) {
        if (key in context.provides) {
          warn$1(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
        }
        context.provides[key] = value;
        return app;
      }
    };
    return app;
  };
}
const queuePostRenderEffect = queuePostFlushCb;
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = createDevRenderContext(instance);
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
function validateComponentName(name, config) {
  const appIsNativeTag = config.isNativeTag || NO;
  if (isBuiltInTag(name) || appIsNativeTag(name)) {
    warn$1("Do not use built-in or reserved HTML elements as component id: " + name);
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps$1(instance, props, isStateful, isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component2 = instance.type;
  {
    if (Component2.name) {
      validateComponentName(Component2.name, instance.appContext.config);
    }
    if (Component2.components) {
      const names = Object.keys(Component2.components);
      for (let i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }
    if (Component2.directives) {
      const names = Object.keys(Component2.directives);
      for (let i = 0; i < names.length; i++) {
        validateDirectiveName(names[i]);
      }
    }
    if (Component2.compilerOptions && isRuntimeOnly()) {
      warn$1(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  {
    exposePropsOnRenderContext(instance);
  }
  const { setup } = Component2;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [shallowReadonly(instance.props), setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      {
        warn$1(`setup() returned a Promise, but the version of Vue you are using does not support it yet.`);
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    if (isVNode(setupResult)) {
      warn$1(`setup() should not return VNodes directly - return a render function instead.`);
    }
    {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (setupResult !== void 0) {
    warn$1(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
  }
  finishComponentSetup(instance, isSSR);
}
let compile;
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component2 = instance.type;
  if (!instance.render) {
    instance.render = Component2.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions$1(instance);
    resetTracking();
    unsetCurrentInstance();
  }
  if (!Component2.render && instance.render === NOOP && !isSSR) {
    if (Component2.template) {
      warn$1(`Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
    } else {
      warn$1(`Component is missing template or render function.`);
    }
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    },
    set() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    if (instance.exposed) {
      warn$1(`expose() should be called only once per setup().`);
    }
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return Object.freeze({
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      get slots() {
        return shallowReadonly(instance.slots);
      },
      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },
      expose
    });
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        }
        return instance.proxy[key];
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component2, includeInferred = true) {
  return isFunction(Component2) ? Component2.displayName || Component2.name : Component2.name || includeInferred && Component2.__name;
}
function formatComponentName(instance, Component2, isRoot = false) {
  let name = getComponentName(Component2);
  if (!name && Component2.__file) {
    const match = Component2.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component2) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
const computed$1 = (getterOrOptions, debugOptions) => {
  return computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
const version = "3.2.37";
function unwrapper(target) {
  return unref(target);
}
const ARRAYTYPE = "[object Array]";
const OBJECTTYPE = "[object Object]";
function diff(current, pre) {
  const result = {};
  syncKeys(current, pre);
  _diff(current, pre, "", result);
  return result;
}
function syncKeys(current, pre) {
  current = unwrapper(current);
  if (current === pre)
    return;
  const rootCurrentType = toTypeString(current);
  const rootPreType = toTypeString(pre);
  if (rootCurrentType == OBJECTTYPE && rootPreType == OBJECTTYPE) {
    for (let key in pre) {
      const currentValue = current[key];
      if (currentValue === void 0) {
        current[key] = null;
      } else {
        syncKeys(currentValue, pre[key]);
      }
    }
  } else if (rootCurrentType == ARRAYTYPE && rootPreType == ARRAYTYPE) {
    if (current.length >= pre.length) {
      pre.forEach((item, index2) => {
        syncKeys(current[index2], item);
      });
    }
  }
}
function _diff(current, pre, path, result) {
  current = unwrapper(current);
  if (current === pre)
    return;
  const rootCurrentType = toTypeString(current);
  const rootPreType = toTypeString(pre);
  if (rootCurrentType == OBJECTTYPE) {
    if (rootPreType != OBJECTTYPE || Object.keys(current).length < Object.keys(pre).length) {
      setResult(result, path, current);
    } else {
      for (let key in current) {
        const currentValue = unwrapper(current[key]);
        const preValue = pre[key];
        const currentType = toTypeString(currentValue);
        const preType = toTypeString(preValue);
        if (currentType != ARRAYTYPE && currentType != OBJECTTYPE) {
          if (currentValue != preValue) {
            setResult(result, (path == "" ? "" : path + ".") + key, currentValue);
          }
        } else if (currentType == ARRAYTYPE) {
          if (preType != ARRAYTYPE) {
            setResult(result, (path == "" ? "" : path + ".") + key, currentValue);
          } else {
            if (currentValue.length < preValue.length) {
              setResult(result, (path == "" ? "" : path + ".") + key, currentValue);
            } else {
              currentValue.forEach((item, index2) => {
                _diff(item, preValue[index2], (path == "" ? "" : path + ".") + key + "[" + index2 + "]", result);
              });
            }
          }
        } else if (currentType == OBJECTTYPE) {
          if (preType != OBJECTTYPE || Object.keys(currentValue).length < Object.keys(preValue).length) {
            setResult(result, (path == "" ? "" : path + ".") + key, currentValue);
          } else {
            for (let subKey in currentValue) {
              _diff(currentValue[subKey], preValue[subKey], (path == "" ? "" : path + ".") + key + "." + subKey, result);
            }
          }
        }
      }
    }
  } else if (rootCurrentType == ARRAYTYPE) {
    if (rootPreType != ARRAYTYPE) {
      setResult(result, path, current);
    } else {
      if (current.length < pre.length) {
        setResult(result, path, current);
      } else {
        current.forEach((item, index2) => {
          _diff(item, pre[index2], path + "[" + index2 + "]", result);
        });
      }
    }
  } else {
    setResult(result, path, current);
  }
}
function setResult(result, k, v) {
  result[k] = v;
}
function hasComponentEffect(instance) {
  return queue.includes(instance.update);
}
function flushCallbacks(instance) {
  const ctx = instance.ctx;
  const callbacks = ctx.__next_tick_callbacks;
  if (callbacks && callbacks.length) {
    const copies = callbacks.slice(0);
    callbacks.length = 0;
    for (let i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }
}
function nextTick$1(instance, fn) {
  const ctx = instance.ctx;
  if (!ctx.__next_tick_pending && !hasComponentEffect(instance)) {
    return nextTick(fn && fn.bind(instance.proxy));
  }
  let _resolve;
  if (!ctx.__next_tick_callbacks) {
    ctx.__next_tick_callbacks = [];
  }
  ctx.__next_tick_callbacks.push(() => {
    if (fn) {
      callWithErrorHandling(fn.bind(instance.proxy), instance, 14);
    } else if (_resolve) {
      _resolve(instance.proxy);
    }
  });
  return new Promise((resolve) => {
    _resolve = resolve;
  });
}
function clone(src, seen) {
  src = unwrapper(src);
  const type = typeof src;
  if (type === "object" && src !== null) {
    let copy = seen.get(src);
    if (typeof copy !== "undefined") {
      return copy;
    }
    if (isArray(src)) {
      const len = src.length;
      copy = new Array(len);
      seen.set(src, copy);
      for (let i = 0; i < len; i++) {
        copy[i] = clone(src[i], seen);
      }
    } else {
      copy = {};
      seen.set(src, copy);
      for (const name in src) {
        if (hasOwn(src, name)) {
          copy[name] = clone(src[name], seen);
        }
      }
    }
    return copy;
  }
  if (type !== "symbol") {
    return src;
  }
}
function deepCopy(src) {
  return clone(src, typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : /* @__PURE__ */ new Map());
}
function getMPInstanceData(instance, keys) {
  const data = instance.data;
  const ret = /* @__PURE__ */ Object.create(null);
  keys.forEach((key) => {
    ret[key] = data[key];
  });
  return ret;
}
function patch(instance, data, oldData) {
  if (!data) {
    return;
  }
  data = deepCopy(data);
  const ctx = instance.ctx;
  const mpType = ctx.mpType;
  if (mpType === "page" || mpType === "component") {
    data.r0 = 1;
    const mpInstance = ctx.$scope;
    const keys = Object.keys(data);
    const diffData = diff(data, oldData || getMPInstanceData(mpInstance, keys));
    if (Object.keys(diffData).length) {
      ctx.__next_tick_pending = true;
      mpInstance.setData(diffData, () => {
        ctx.__next_tick_pending = false;
        flushCallbacks(instance);
      });
      flushPreFlushCbs(void 0, instance.update);
    } else {
      flushCallbacks(instance);
    }
  }
}
function initAppConfig(appConfig) {
  appConfig.globalProperties.$nextTick = function $nextTick(fn) {
    return nextTick$1(this.$, fn);
  };
}
function onApplyOptions(options, instance, publicThis) {
  instance.appContext.config.globalProperties.$applyOptions(options, instance, publicThis);
  const computedOptions = options.computed;
  if (computedOptions) {
    const keys = Object.keys(computedOptions);
    if (keys.length) {
      const ctx = instance.ctx;
      if (!ctx.$computedKeys) {
        ctx.$computedKeys = [];
      }
      ctx.$computedKeys.push(...keys);
    }
  }
  delete instance.ctx.$onApplyOptions;
}
function setRef$1(instance, isUnmount = false) {
  const { setupState, $templateRefs, ctx: { $scope, $mpPlatform } } = instance;
  if ($mpPlatform === "mp-alipay") {
    return;
  }
  if (!$templateRefs || !$scope) {
    return;
  }
  if (isUnmount) {
    return $templateRefs.forEach((templateRef) => setTemplateRef(templateRef, null, setupState));
  }
  const check = $mpPlatform === "mp-baidu" || $mpPlatform === "mp-toutiao";
  const doSetByRefs = (refs) => {
    const mpComponents = $scope.selectAllComponents(".r").concat($scope.selectAllComponents(".r-i-f"));
    return refs.filter((templateRef) => {
      const refValue = findComponentPublicInstance(mpComponents, templateRef.i);
      if (check && refValue === null) {
        return true;
      }
      setTemplateRef(templateRef, refValue, setupState);
      return false;
    });
  };
  const doSet = () => {
    const refs = doSetByRefs($templateRefs);
    if (refs.length && instance.proxy && instance.proxy.$scope) {
      instance.proxy.$scope.setData({ r1: 1 }, () => {
        doSetByRefs(refs);
      });
    }
  };
  if ($scope._$setRef) {
    $scope._$setRef(doSet);
  } else {
    nextTick$1(instance, doSet);
  }
}
function findComponentPublicInstance(mpComponents, id) {
  const mpInstance = mpComponents.find((com) => com && (com.properties || com.props).uI === id);
  if (mpInstance) {
    const vm = mpInstance.$vm;
    return getExposeProxy(vm.$) || vm;
  }
  return null;
}
function setTemplateRef({ r, f }, refValue, setupState) {
  if (isFunction(r)) {
    r(refValue, {});
  } else {
    const _isString = isString(r);
    const _isRef = isRef(r);
    if (_isString || _isRef) {
      if (f) {
        if (!_isRef) {
          return;
        }
        if (!isArray(r.value)) {
          r.value = [];
        }
        const existing = r.value;
        if (existing.indexOf(refValue) === -1) {
          existing.push(refValue);
          if (!refValue) {
            return;
          }
          onBeforeUnmount(() => remove(existing, refValue), refValue.$);
        }
      } else if (_isString) {
        if (hasOwn(setupState, r)) {
          setupState[r] = refValue;
        }
      } else if (isRef(r)) {
        r.value = refValue;
      } else {
        warnRef(r);
      }
    } else {
      warnRef(r);
    }
  }
}
function warnRef(ref2) {
  warn$1("Invalid template ref type:", ref2, `(${typeof ref2})`);
}
var MPType;
(function(MPType2) {
  MPType2["APP"] = "app";
  MPType2["PAGE"] = "page";
  MPType2["COMPONENT"] = "component";
})(MPType || (MPType = {}));
const queuePostRenderEffect$1 = queuePostFlushCb;
function mountComponent(initialVNode, options) {
  const instance = initialVNode.component = createComponentInstance(initialVNode, options.parentComponent, null);
  {
    instance.ctx.$onApplyOptions = onApplyOptions;
    instance.ctx.$children = [];
  }
  if (options.mpType === "app") {
    instance.render = NOOP;
  }
  if (options.onBeforeSetup) {
    options.onBeforeSetup(instance, options);
  }
  {
    pushWarningContext(initialVNode);
  }
  setupComponent(instance);
  {
    if (options.parentComponent && instance.proxy) {
      options.parentComponent.ctx.$children.push(getExposeProxy(instance) || instance.proxy);
    }
  }
  setupRenderEffect(instance);
  {
    popWarningContext();
  }
  return instance.proxy;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
function renderComponentRoot(instance) {
  const { type: Component2, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render, renderCache, data, setupState, ctx, uid: uid2, appContext: { app: { config: { globalProperties: { pruneComponentPropsCache: pruneComponentPropsCache2 } } } }, inheritAttrs } = instance;
  instance.$templateRefs = [];
  instance.$ei = 0;
  pruneComponentPropsCache2(uid2);
  instance.__counter = instance.__counter === 0 ? 1 : 0;
  let result;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      fallthroughAttrs(inheritAttrs, props, propsOptions, attrs);
      const proxyToUse = withProxy || proxy;
      result = render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx);
    } else {
      fallthroughAttrs(inheritAttrs, props, propsOptions, Component2.props ? attrs : getFunctionalFallthrough(attrs));
      const render2 = Component2;
      result = render2.length > 1 ? render2(props, { attrs, slots, emit: emit2 }) : render2(props, null);
    }
  } catch (err) {
    handleError(err, instance, 1);
    result = false;
  }
  setRef$1(instance);
  setCurrentRenderingInstance(prev);
  return result;
}
function fallthroughAttrs(inheritAttrs, props, propsOptions, fallthroughAttrs2) {
  if (props && fallthroughAttrs2 && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs2).filter((key) => key !== "class" && key !== "style");
    if (!keys.length) {
      return;
    }
    if (propsOptions && keys.some(isModelListener)) {
      keys.forEach((key) => {
        if (!isModelListener(key) || !(key.slice(9) in propsOptions)) {
          props[key] = fallthroughAttrs2[key];
        }
      });
    } else {
      keys.forEach((key) => props[key] = fallthroughAttrs2[key]);
    }
  }
}
const updateComponentPreRender = (instance) => {
  pauseTracking();
  flushPreFlushCbs(void 0, instance.update);
  resetTracking();
};
function componentUpdateScopedSlotsFn() {
  const scopedSlotsData = this.$scopedSlotsData;
  if (!scopedSlotsData || scopedSlotsData.length === 0) {
    return;
  }
  const mpInstance = this.ctx.$scope;
  const oldData = mpInstance.data;
  const diffData = /* @__PURE__ */ Object.create(null);
  scopedSlotsData.forEach(({ path, index: index2, data }) => {
    const oldScopedSlotData = getValueByDataPath(oldData, path);
    const diffPath = isString(index2) ? `${path}.${index2}` : `${path}[${index2}]`;
    if (typeof oldScopedSlotData === "undefined" || typeof oldScopedSlotData[index2] === "undefined") {
      diffData[diffPath] = data;
    } else {
      const diffScopedSlotData = diff(data, oldScopedSlotData[index2]);
      Object.keys(diffScopedSlotData).forEach((name) => {
        diffData[diffPath + "." + name] = diffScopedSlotData[name];
      });
    }
  });
  scopedSlotsData.length = 0;
  if (Object.keys(diffData).length) {
    mpInstance.setData(diffData);
  }
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function setupRenderEffect(instance) {
  const updateScopedSlots = componentUpdateScopedSlotsFn.bind(instance);
  instance.$updateScopedSlots = () => nextTick(() => queueJob(updateScopedSlots));
  const componentUpdateFn = () => {
    if (!instance.isMounted) {
      onBeforeUnmount(() => {
        setRef$1(instance, true);
      }, instance);
      patch(instance, renderComponentRoot(instance));
    } else {
      const { bu, u } = instance;
      toggleRecurse(instance, false);
      updateComponentPreRender(instance);
      if (bu) {
        invokeArrayFns$1(bu);
      }
      toggleRecurse(instance, true);
      patch(instance, renderComponentRoot(instance));
      if (u) {
        queuePostRenderEffect$1(u);
      }
    }
  };
  const effect = instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope);
  const update = instance.update = effect.run.bind(effect);
  update.id = instance.uid;
  toggleRecurse(instance, true);
  {
    effect.onTrack = instance.rtc ? (e) => invokeArrayFns$1(instance.rtc, e) : void 0;
    effect.onTrigger = instance.rtg ? (e) => invokeArrayFns$1(instance.rtg, e) : void 0;
    update.ownerInstance = instance;
  }
  update();
}
function unmountComponent(instance) {
  const { bum, scope, update, um } = instance;
  if (bum) {
    invokeArrayFns$1(bum);
  }
  scope.stop();
  if (update) {
    update.active = false;
  }
  if (um) {
    queuePostRenderEffect$1(um);
  }
  queuePostRenderEffect$1(() => {
    instance.isUnmounted = true;
  });
}
const oldCreateApp = createAppAPI();
function createVueApp(rootComponent, rootProps = null) {
  const app = oldCreateApp(rootComponent, rootProps);
  const appContext = app._context;
  initAppConfig(appContext.config);
  const createVNode = (initialVNode) => {
    initialVNode.appContext = appContext;
    initialVNode.shapeFlag = 6;
    return initialVNode;
  };
  const createComponent2 = function createComponent3(initialVNode, options) {
    return mountComponent(createVNode(initialVNode), options);
  };
  const destroyComponent = function destroyComponent2(component) {
    return component && unmountComponent(component.$);
  };
  app.mount = function mount() {
    rootComponent.render = NOOP;
    const instance = mountComponent(createVNode({ type: rootComponent }), {
      mpType: MPType.APP,
      mpInstance: null,
      parentComponent: null,
      slots: [],
      props: null
    });
    app._instance = instance.$;
    instance.$app = app;
    instance.$createComponent = createComponent2;
    instance.$destroyComponent = destroyComponent;
    appContext.$appInstance = instance;
    return instance;
  };
  app.unmount = function unmount() {
    warn$1(`Cannot unmount an app.`);
  };
  return app;
}
function injectLifecycleHook(name, hook, publicThis, instance) {
  if (isFunction(hook)) {
    injectHook(name, hook.bind(publicThis), instance);
  }
}
function initHooks$1(options, instance, publicThis) {
  const mpType = options.mpType || publicThis.$mpType;
  if (!mpType) {
    return;
  }
  Object.keys(options).forEach((name) => {
    if (name.indexOf("on") === 0) {
      const hooks = options[name];
      if (isArray(hooks)) {
        hooks.forEach((hook) => injectLifecycleHook(name, hook, publicThis, instance));
      } else {
        injectLifecycleHook(name, hooks, publicThis, instance);
      }
    }
  });
}
function applyOptions$2(options, instance, publicThis) {
  initHooks$1(options, instance, publicThis);
}
function set(target, key, val) {
  return target[key] = val;
}
function createErrorHandler(app) {
  return function errorHandler(err, instance, _info) {
    if (!instance) {
      throw err;
    }
    const appInstance = app._instance;
    if (!appInstance || !appInstance.proxy) {
      throw err;
    }
    {
      appInstance.proxy.$callHook(ON_ERROR, err);
    }
  };
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function initOptionMergeStrategies(optionMergeStrategies) {
  UniLifecycleHooks.forEach((name) => {
    optionMergeStrategies[name] = mergeAsArray;
  });
}
let realAtob;
const b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const b64re = /^(?:[A-Za-z\d+/]{4})*?(?:[A-Za-z\d+/]{2}(?:==)?|[A-Za-z\d+/]{3}=?)?$/;
if (typeof atob !== "function") {
  realAtob = function(str) {
    str = String(str).replace(/[\t\n\f\r ]+/g, "");
    if (!b64re.test(str)) {
      throw new Error("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.");
    }
    str += "==".slice(2 - (str.length & 3));
    var bitmap;
    var result = "";
    var r1;
    var r2;
    var i = 0;
    for (; i < str.length; ) {
      bitmap = b64.indexOf(str.charAt(i++)) << 18 | b64.indexOf(str.charAt(i++)) << 12 | (r1 = b64.indexOf(str.charAt(i++))) << 6 | (r2 = b64.indexOf(str.charAt(i++)));
      result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255) : r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255) : String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);
    }
    return result;
  };
} else {
  realAtob = atob;
}
function b64DecodeUnicode(str) {
  return decodeURIComponent(realAtob(str).split("").map(function(c) {
    return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(""));
}
function getCurrentUserInfo() {
  const token = index.getStorageSync("uni_id_token") || "";
  const tokenArr = token.split(".");
  if (!token || tokenArr.length !== 3) {
    return {
      uid: null,
      role: [],
      permission: [],
      tokenExpired: 0
    };
  }
  let userInfo;
  try {
    userInfo = JSON.parse(b64DecodeUnicode(tokenArr[1]));
  } catch (error) {
    throw new Error("\u83B7\u53D6\u5F53\u524D\u7528\u6237\u4FE1\u606F\u51FA\u9519\uFF0C\u8BE6\u7EC6\u9519\u8BEF\u4FE1\u606F\u4E3A\uFF1A" + error.message);
  }
  userInfo.tokenExpired = userInfo.exp * 1e3;
  delete userInfo.exp;
  delete userInfo.iat;
  return userInfo;
}
function uniIdMixin(globalProperties) {
  globalProperties.uniIDHasRole = function(roleId) {
    const { role } = getCurrentUserInfo();
    return role.indexOf(roleId) > -1;
  };
  globalProperties.uniIDHasPermission = function(permissionId) {
    const { permission } = getCurrentUserInfo();
    return this.uniIDHasRole("admin") || permission.indexOf(permissionId) > -1;
  };
  globalProperties.uniIDTokenValid = function() {
    const { tokenExpired } = getCurrentUserInfo();
    return tokenExpired > Date.now();
  };
}
function initApp(app) {
  const appConfig = app._context.config;
  if (isFunction(app._component.onError)) {
    appConfig.errorHandler = createErrorHandler(app);
  }
  initOptionMergeStrategies(appConfig.optionMergeStrategies);
  const globalProperties = appConfig.globalProperties;
  {
    uniIdMixin(globalProperties);
  }
  {
    globalProperties.$set = set;
    globalProperties.$applyOptions = applyOptions$2;
  }
  {
    index.invokeCreateVueAppHook(app);
  }
}
const propsCaches = /* @__PURE__ */ Object.create(null);
function pruneComponentPropsCache(uid2) {
  delete propsCaches[uid2];
}
function findComponentPropsData(up) {
  if (!up) {
    return;
  }
  const [uid2, propsId] = up.split(",");
  if (!propsCaches[uid2]) {
    return;
  }
  return propsCaches[uid2][parseInt(propsId)];
}
var plugin = {
  install(app) {
    initApp(app);
    app.config.globalProperties.pruneComponentPropsCache = pruneComponentPropsCache;
    const oldMount = app.mount;
    app.mount = function mount(rootContainer) {
      const instance = oldMount.call(app, rootContainer);
      const createApp2 = getCreateApp();
      if (createApp2) {
        createApp2(instance);
      } else {
        if (typeof createMiniProgramApp !== "undefined") {
          createMiniProgramApp(instance);
        }
      }
      return instance;
    };
  }
};
function getCreateApp() {
  const method = "createApp";
  if (typeof global !== "undefined") {
    return global[method];
  } else if (typeof my !== "undefined") {
    return my[method];
  }
}
function vOn(value, key) {
  const instance = getCurrentInstance();
  const ctx = instance.ctx;
  const extraKey = typeof key !== "undefined" && (ctx.$mpPlatform === "mp-weixin" || ctx.$mpPlatform === "mp-qq") && (isString(key) || typeof key === "number") ? "_" + key : "";
  const name = "e" + instance.$ei++ + extraKey;
  const mpInstance = ctx.$scope;
  if (!value) {
    delete mpInstance[name];
    return name;
  }
  const existingInvoker = mpInstance[name];
  if (existingInvoker) {
    existingInvoker.value = value;
  } else {
    mpInstance[name] = createInvoker(value, instance);
  }
  return name;
}
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    patchMPEvent(e);
    let args = [e];
    if (e.detail && e.detail.__args__) {
      args = e.detail.__args__;
    }
    const eventValue = invoker.value;
    const invoke = () => callWithAsyncErrorHandling(patchStopImmediatePropagation(e, eventValue), instance, 5, args);
    const eventTarget = e.target;
    const eventSync = eventTarget ? eventTarget.dataset ? eventTarget.dataset.eventsync === "true" : false : false;
    if (bubbles.includes(e.type) && !eventSync) {
      setTimeout(invoke);
    } else {
      const res = invoke();
      if (e.type === "input" && (isArray(res) || isPromise(res))) {
        return;
      }
      return res;
    }
  };
  invoker.value = initialValue;
  return invoker;
}
const bubbles = [
  "tap",
  "longpress",
  "longtap",
  "transitionend",
  "animationstart",
  "animationiteration",
  "animationend",
  "touchforcechange"
];
function patchMPEvent(event) {
  if (event.type && event.target) {
    event.preventDefault = NOOP;
    event.stopPropagation = NOOP;
    event.stopImmediatePropagation = NOOP;
    if (!hasOwn(event, "detail")) {
      event.detail = {};
    }
    if (hasOwn(event, "markerId")) {
      event.detail = typeof event.detail === "object" ? event.detail : {};
      event.detail.markerId = event.markerId;
    }
    if (isPlainObject(event.detail) && hasOwn(event.detail, "checked") && !hasOwn(event.detail, "value")) {
      event.detail.value = event.detail.checked;
    }
    if (isPlainObject(event.detail)) {
      event.target = extend({}, event.target, event.detail);
    }
  }
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop && originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn(e2));
  } else {
    return value;
  }
}
const o = (value, key) => vOn(value, key);
function createApp$1(rootComponent, rootProps = null) {
  rootComponent && (rootComponent.mpType = "app");
  return createVueApp(rootComponent, rootProps).use(plugin);
}
const createSSRApp = createApp$1;
const eventChannels = {};
const eventChannelStack = [];
function getEventChannel(id) {
  if (id) {
    const eventChannel = eventChannels[id];
    delete eventChannels[id];
    return eventChannel;
  }
  return eventChannelStack.shift();
}
const MP_METHODS = [
  "createSelectorQuery",
  "createIntersectionObserver",
  "selectAllComponents",
  "selectComponent"
];
function createEmitFn(oldEmit, ctx) {
  return function emit2(event, ...args) {
    const scope = ctx.$scope;
    if (scope && event) {
      const detail = { __args__: args };
      {
        scope.triggerEvent(event, detail);
      }
    }
    return oldEmit.apply(this, [event, ...args]);
  };
}
function initBaseInstance(instance, options) {
  const ctx = instance.ctx;
  ctx.mpType = options.mpType;
  ctx.$mpType = options.mpType;
  ctx.$mpPlatform = "mp-weixin";
  ctx.$scope = options.mpInstance;
  ctx.$mp = {};
  {
    ctx._self = {};
  }
  instance.slots = {};
  if (isArray(options.slots) && options.slots.length) {
    options.slots.forEach((name) => {
      instance.slots[name] = true;
    });
    if (instance.slots[SLOT_DEFAULT_NAME]) {
      instance.slots.default = true;
    }
  }
  ctx.getOpenerEventChannel = function() {
    {
      return options.mpInstance.getOpenerEventChannel();
    }
  };
  ctx.$hasHook = hasHook;
  ctx.$callHook = callHook;
  instance.emit = createEmitFn(instance.emit, ctx);
}
function initComponentInstance(instance, options) {
  initBaseInstance(instance, options);
  const ctx = instance.ctx;
  MP_METHODS.forEach((method) => {
    ctx[method] = function(...args) {
      const mpInstance = ctx.$scope;
      if (mpInstance && mpInstance[method]) {
        return mpInstance[method].apply(mpInstance, args);
      }
    };
  });
}
function initMocks(instance, mpInstance, mocks2) {
  const ctx = instance.ctx;
  mocks2.forEach((mock) => {
    if (hasOwn(mpInstance, mock)) {
      instance[mock] = ctx[mock] = mpInstance[mock];
    }
  });
}
function hasHook(name) {
  const hooks = this.$[name];
  if (hooks && hooks.length) {
    return true;
  }
  return false;
}
function callHook(name, args) {
  if (name === "mounted") {
    callHook.call(this, "bm");
    this.$.isMounted = true;
    name = "m";
  } else if (name === "onLoad" && args && args.__id__) {
    this.__eventChannel__ = getEventChannel(args.__id__);
    delete args.__id__;
  }
  const hooks = this.$[name];
  return hooks && invokeArrayFns(hooks, args);
}
const PAGE_INIT_HOOKS = [
  ON_LOAD,
  ON_SHOW,
  ON_HIDE,
  ON_UNLOAD,
  ON_RESIZE,
  ON_TAB_ITEM_TAP,
  ON_REACH_BOTTOM,
  ON_PULL_DOWN_REFRESH,
  ON_ADD_TO_FAVORITES
];
function findHooks(vueOptions, hooks = /* @__PURE__ */ new Set()) {
  if (vueOptions) {
    Object.keys(vueOptions).forEach((name) => {
      if (name.indexOf("on") === 0 && isFunction(vueOptions[name])) {
        hooks.add(name);
      }
    });
    {
      const { extends: extendsOptions, mixins } = vueOptions;
      if (mixins) {
        mixins.forEach((mixin) => findHooks(mixin, hooks));
      }
      if (extendsOptions) {
        findHooks(extendsOptions, hooks);
      }
    }
  }
  return hooks;
}
function initHook(mpOptions, hook, excludes) {
  if (excludes.indexOf(hook) === -1 && !hasOwn(mpOptions, hook)) {
    mpOptions[hook] = function(args) {
      return this.$vm && this.$vm.$callHook(hook, args);
    };
  }
}
const EXCLUDE_HOOKS = [ON_READY];
function initHooks(mpOptions, hooks, excludes = EXCLUDE_HOOKS) {
  hooks.forEach((hook) => initHook(mpOptions, hook, excludes));
}
function initUnknownHooks(mpOptions, vueOptions, excludes = EXCLUDE_HOOKS) {
  findHooks(vueOptions).forEach((hook) => initHook(mpOptions, hook, excludes));
}
function initRuntimeHooks(mpOptions, runtimeHooks) {
  if (!runtimeHooks) {
    return;
  }
  const hooks = Object.keys(MINI_PROGRAM_PAGE_RUNTIME_HOOKS);
  hooks.forEach((hook) => {
    if (runtimeHooks & MINI_PROGRAM_PAGE_RUNTIME_HOOKS[hook]) {
      initHook(mpOptions, hook, []);
    }
  });
}
const findMixinRuntimeHooks = /* @__PURE__ */ once(() => {
  const runtimeHooks = [];
  const app = getApp({ allowDefault: true });
  if (app && app.$vm && app.$vm.$) {
    const mixins = app.$vm.$.appContext.mixins;
    if (isArray(mixins)) {
      const hooks = Object.keys(MINI_PROGRAM_PAGE_RUNTIME_HOOKS);
      mixins.forEach((mixin) => {
        hooks.forEach((hook) => {
          if (hasOwn(mixin, hook) && !runtimeHooks.includes(hook)) {
            runtimeHooks.push(hook);
          }
        });
      });
    }
  }
  return runtimeHooks;
});
function initMixinRuntimeHooks(mpOptions) {
  initHooks(mpOptions, findMixinRuntimeHooks());
}
const HOOKS = [
  ON_SHOW,
  ON_HIDE,
  ON_ERROR,
  ON_THEME_CHANGE,
  ON_PAGE_NOT_FOUND,
  ON_UNHANDLE_REJECTION
];
function parseApp(instance, parseAppOptions) {
  const internalInstance = instance.$;
  const appOptions = {
    globalData: instance.$options && instance.$options.globalData || {},
    $vm: instance,
    onLaunch(options) {
      this.$vm = instance;
      const ctx = internalInstance.ctx;
      if (this.$vm && ctx.$scope) {
        return;
      }
      initBaseInstance(internalInstance, {
        mpType: "app",
        mpInstance: this,
        slots: []
      });
      ctx.globalData = this.globalData;
      instance.$callHook(ON_LAUNCH, options);
    }
  };
  initLocale(instance);
  const vueOptions = instance.$.type;
  initHooks(appOptions, HOOKS);
  initUnknownHooks(appOptions, vueOptions);
  {
    const methods = vueOptions.methods;
    methods && extend(appOptions, methods);
  }
  if (parseAppOptions) {
    parseAppOptions.parse(appOptions);
  }
  return appOptions;
}
function initCreateApp(parseAppOptions) {
  return function createApp2(vm) {
    return App(parseApp(vm, parseAppOptions));
  };
}
function initCreateSubpackageApp(parseAppOptions) {
  return function createApp2(vm) {
    const appOptions = parseApp(vm, parseAppOptions);
    const app = getApp({
      allowDefault: true
    });
    vm.$.ctx.$scope = app;
    const globalData = app.globalData;
    if (globalData) {
      Object.keys(appOptions.globalData).forEach((name) => {
        if (!hasOwn(globalData, name)) {
          globalData[name] = appOptions.globalData[name];
        }
      });
    }
    Object.keys(appOptions).forEach((name) => {
      if (!hasOwn(app, name)) {
        app[name] = appOptions[name];
      }
    });
    initAppLifecycle(appOptions, vm);
  };
}
function initAppLifecycle(appOptions, vm) {
  if (isFunction(appOptions.onLaunch)) {
    const args = wx.getLaunchOptionsSync && wx.getLaunchOptionsSync();
    appOptions.onLaunch(args);
  }
  if (isFunction(appOptions.onShow) && wx.onAppShow) {
    wx.onAppShow((args) => {
      vm.$callHook("onShow", args);
    });
  }
  if (isFunction(appOptions.onHide) && wx.onAppHide) {
    wx.onAppHide((args) => {
      vm.$callHook("onHide", args);
    });
  }
}
function initLocale(appVm) {
  const locale = ref(normalizeLocale(wx.getSystemInfoSync().language) || LOCALE_EN);
  Object.defineProperty(appVm, "$locale", {
    get() {
      return locale.value;
    },
    set(v) {
      locale.value = v;
    }
  });
}
function initVueIds(vueIds, mpInstance) {
  if (!vueIds) {
    return;
  }
  const ids = vueIds.split(",");
  const len = ids.length;
  if (len === 1) {
    mpInstance._$vueId = ids[0];
  } else if (len === 2) {
    mpInstance._$vueId = ids[0];
    mpInstance._$vuePid = ids[1];
  }
}
const EXTRAS = ["externalClasses"];
function initExtraOptions(miniProgramComponentOptions, vueOptions) {
  EXTRAS.forEach((name) => {
    if (hasOwn(vueOptions, name)) {
      miniProgramComponentOptions[name] = vueOptions[name];
    }
  });
}
function initWxsCallMethods(methods, wxsCallMethods) {
  if (!isArray(wxsCallMethods)) {
    return;
  }
  wxsCallMethods.forEach((callMethod) => {
    methods[callMethod] = function(args) {
      return this.$vm[callMethod](args);
    };
  });
}
function selectAllComponents(mpInstance, selector, $refs) {
  const components = mpInstance.selectAllComponents(selector);
  components.forEach((component) => {
    const ref2 = component.properties.uR;
    $refs[ref2] = component.$vm || component;
  });
}
function initRefs(instance, mpInstance) {
  Object.defineProperty(instance, "refs", {
    get() {
      const $refs = {};
      selectAllComponents(mpInstance, ".r", $refs);
      const forComponents = mpInstance.selectAllComponents(".r-i-f");
      forComponents.forEach((component) => {
        const ref2 = component.properties.uR;
        if (!ref2) {
          return;
        }
        if (!$refs[ref2]) {
          $refs[ref2] = [];
        }
        $refs[ref2].push(component.$vm || component);
      });
      return $refs;
    }
  });
}
function findVmByVueId(instance, vuePid) {
  const $children = instance.$children;
  for (let i = $children.length - 1; i >= 0; i--) {
    const childVm = $children[i];
    if (childVm.$scope._$vueId === vuePid) {
      return childVm;
    }
  }
  let parentVm;
  for (let i = $children.length - 1; i >= 0; i--) {
    parentVm = findVmByVueId($children[i], vuePid);
    if (parentVm) {
      return parentVm;
    }
  }
}
const builtInProps = [
  "eO",
  "uR",
  "uRIF",
  "uI",
  "uT",
  "uP",
  "uS"
];
function initDefaultProps(isBehavior = false) {
  const properties = {};
  if (!isBehavior) {
    builtInProps.forEach((name) => {
      properties[name] = {
        type: null,
        value: ""
      };
    });
    properties.uS = {
      type: null,
      value: [],
      observer: function(newVal) {
        const $slots = /* @__PURE__ */ Object.create(null);
        newVal && newVal.forEach((slotName) => {
          $slots[slotName] = true;
        });
        this.setData({
          $slots
        });
      }
    };
  }
  return properties;
}
function initVirtualHostProps(options) {
  const properties = {};
  {
    if (options && options.virtualHost) {
      properties.virtualHostStyle = {
        type: null,
        value: ""
      };
      properties.virtualHostClass = {
        type: null,
        value: ""
      };
    }
  }
  return properties;
}
function initProps(mpComponentOptions) {
  if (!mpComponentOptions.properties) {
    mpComponentOptions.properties = {};
  }
  extend(mpComponentOptions.properties, initDefaultProps(), initVirtualHostProps(mpComponentOptions.options));
}
const PROP_TYPES = [String, Number, Boolean, Object, Array, null];
function parsePropType(type, defaultValue) {
  if (isArray(type) && type.length === 1) {
    return type[0];
  }
  return type;
}
function normalizePropType(type, defaultValue) {
  const res = parsePropType(type);
  return PROP_TYPES.indexOf(res) !== -1 ? res : null;
}
function initPageProps({ properties }, rawProps) {
  if (isArray(rawProps)) {
    rawProps.forEach((key) => {
      properties[key] = {
        type: String,
        value: ""
      };
    });
  } else if (isPlainObject(rawProps)) {
    Object.keys(rawProps).forEach((key) => {
      const opts = rawProps[key];
      if (isPlainObject(opts)) {
        let value = opts.default;
        if (isFunction(value)) {
          value = value();
        }
        const type = opts.type;
        opts.type = normalizePropType(type);
        properties[key] = {
          type: opts.type,
          value
        };
      } else {
        properties[key] = {
          type: normalizePropType(opts)
        };
      }
    });
  }
}
function findPropsData(properties, isPage2) {
  return (isPage2 ? findPagePropsData(properties) : findComponentPropsData(properties.uP)) || {};
}
function findPagePropsData(properties) {
  const propsData = {};
  if (isPlainObject(properties)) {
    Object.keys(properties).forEach((name) => {
      if (builtInProps.indexOf(name) === -1) {
        propsData[name] = properties[name];
      }
    });
  }
  return propsData;
}
function initData(_) {
  return {};
}
function initPropsObserver(componentOptions) {
  const observe = function observe2() {
    const up = this.properties.uP;
    if (!up) {
      return;
    }
    if (this.$vm) {
      updateComponentProps(up, this.$vm.$);
    } else if (this.properties.uT === "m") {
      updateMiniProgramComponentProperties(up, this);
    }
  };
  {
    if (!componentOptions.observers) {
      componentOptions.observers = {};
    }
    componentOptions.observers.uP = observe;
  }
}
function updateMiniProgramComponentProperties(up, mpInstance) {
  const prevProps = mpInstance.properties;
  const nextProps = findComponentPropsData(up) || {};
  if (hasPropsChanged(prevProps, nextProps, false)) {
    mpInstance.setData(nextProps);
  }
}
function updateComponentProps(up, instance) {
  const prevProps = toRaw(instance.props);
  const nextProps = findComponentPropsData(up) || {};
  if (hasPropsChanged(prevProps, nextProps)) {
    updateProps(instance, nextProps, prevProps, false);
    if (hasQueueJob(instance.update)) {
      invalidateJob(instance.update);
    }
    {
      instance.update();
    }
  }
}
function hasPropsChanged(prevProps, nextProps, checkLen = true) {
  const nextKeys = Object.keys(nextProps);
  if (checkLen && nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key]) {
      return true;
    }
  }
  return false;
}
function initBehaviors(vueOptions) {
  const vueBehaviors = vueOptions.behaviors;
  let vueProps = vueOptions.props;
  if (!vueProps) {
    vueOptions.props = vueProps = [];
  }
  const behaviors = [];
  if (isArray(vueBehaviors)) {
    vueBehaviors.forEach((behavior) => {
      behaviors.push(behavior.replace("uni://", "wx://"));
      if (behavior === "uni://form-field") {
        if (isArray(vueProps)) {
          vueProps.push("name");
          vueProps.push("value");
        } else {
          vueProps.name = {
            type: String,
            default: ""
          };
          vueProps.value = {
            type: [String, Number, Boolean, Array, Object, Date],
            default: ""
          };
        }
      }
    });
  }
  return behaviors;
}
function applyOptions(componentOptions, vueOptions) {
  componentOptions.data = initData();
  componentOptions.behaviors = initBehaviors(vueOptions);
}
function parseComponent(vueOptions, { parse, mocks: mocks2, isPage: isPage2, initRelation: initRelation2, handleLink: handleLink2, initLifetimes: initLifetimes2 }) {
  vueOptions = vueOptions.default || vueOptions;
  const options = {
    multipleSlots: true,
    addGlobalClass: true,
    pureDataPattern: /^uP$/
  };
  if (vueOptions.options) {
    extend(options, vueOptions.options);
  }
  const mpComponentOptions = {
    options,
    lifetimes: initLifetimes2({ mocks: mocks2, isPage: isPage2, initRelation: initRelation2, vueOptions }),
    pageLifetimes: {
      show() {
        this.$vm && this.$vm.$callHook("onPageShow");
      },
      hide() {
        this.$vm && this.$vm.$callHook("onPageHide");
      },
      resize(size2) {
        this.$vm && this.$vm.$callHook("onPageResize", size2);
      }
    },
    methods: {
      __l: handleLink2
    }
  };
  {
    applyOptions(mpComponentOptions, vueOptions);
  }
  initProps(mpComponentOptions);
  initPropsObserver(mpComponentOptions);
  initExtraOptions(mpComponentOptions, vueOptions);
  initWxsCallMethods(mpComponentOptions.methods, vueOptions.wxsCallMethods);
  if (parse) {
    parse(mpComponentOptions, { handleLink: handleLink2 });
  }
  return mpComponentOptions;
}
function initCreateComponent(parseOptions2) {
  return function createComponent2(vueComponentOptions) {
    return Component(parseComponent(vueComponentOptions, parseOptions2));
  };
}
let $createComponentFn;
let $destroyComponentFn;
function getAppVm() {
  return getApp().$vm;
}
function $createComponent(initialVNode, options) {
  if (!$createComponentFn) {
    $createComponentFn = getAppVm().$createComponent;
  }
  const proxy = $createComponentFn(initialVNode, options);
  return getExposeProxy(proxy.$) || proxy;
}
function $destroyComponent(instance) {
  if (!$destroyComponentFn) {
    $destroyComponentFn = getApp().$vm.$destroyComponent;
  }
  return $destroyComponentFn(instance);
}
function parsePage(vueOptions, parseOptions2) {
  const { parse, mocks: mocks2, isPage: isPage2, initRelation: initRelation2, handleLink: handleLink2, initLifetimes: initLifetimes2 } = parseOptions2;
  const miniProgramPageOptions = parseComponent(vueOptions, {
    mocks: mocks2,
    isPage: isPage2,
    initRelation: initRelation2,
    handleLink: handleLink2,
    initLifetimes: initLifetimes2
  });
  initPageProps(miniProgramPageOptions, (vueOptions.default || vueOptions).props);
  const methods = miniProgramPageOptions.methods;
  methods.onLoad = function(query) {
    this.options = query;
    this.$page = {
      fullPath: addLeadingSlash(this.route + stringifyQuery(query))
    };
    return this.$vm && this.$vm.$callHook(ON_LOAD, query);
  };
  initHooks(methods, PAGE_INIT_HOOKS);
  {
    initUnknownHooks(methods, vueOptions);
  }
  initRuntimeHooks(methods, vueOptions.__runtimeHooks);
  initMixinRuntimeHooks(methods);
  parse && parse(miniProgramPageOptions, { handleLink: handleLink2 });
  return miniProgramPageOptions;
}
function initCreatePage(parseOptions2) {
  return function createPage2(vuePageOptions) {
    return Component(parsePage(vuePageOptions, parseOptions2));
  };
}
function initCreatePluginApp(parseAppOptions) {
  return function createApp2(vm) {
    initAppLifecycle(parseApp(vm, parseAppOptions), vm);
  };
}
const MPPage = Page;
const MPComponent = Component;
function initTriggerEvent(mpInstance) {
  const oldTriggerEvent = mpInstance.triggerEvent;
  mpInstance.triggerEvent = function(event, ...args) {
    return oldTriggerEvent.apply(mpInstance, [customizeEvent(event), ...args]);
  };
}
function initMiniProgramHook(name, options, isComponent) {
  const oldHook = options[name];
  if (!oldHook) {
    options[name] = function() {
      initTriggerEvent(this);
    };
  } else {
    options[name] = function(...args) {
      initTriggerEvent(this);
      return oldHook.apply(this, args);
    };
  }
}
Page = function(options) {
  initMiniProgramHook(ON_LOAD, options);
  return MPPage(options);
};
Component = function(options) {
  initMiniProgramHook("created", options);
  const isVueComponent = options.properties && options.properties.uP;
  if (!isVueComponent) {
    initProps(options);
    initPropsObserver(options);
  }
  return MPComponent(options);
};
function initLifetimes({ mocks: mocks2, isPage: isPage2, initRelation: initRelation2, vueOptions }) {
  return {
    attached() {
      let properties = this.properties;
      initVueIds(properties.uI, this);
      const relationOptions = {
        vuePid: this._$vuePid
      };
      initRelation2(this, relationOptions);
      const mpInstance = this;
      const isMiniProgramPage = isPage2(mpInstance);
      let propsData = properties;
      this.$vm = $createComponent({
        type: vueOptions,
        props: findPropsData(propsData, isMiniProgramPage)
      }, {
        mpType: isMiniProgramPage ? "page" : "component",
        mpInstance,
        slots: properties.uS || {},
        parentComponent: relationOptions.parent && relationOptions.parent.$,
        onBeforeSetup(instance, options) {
          initRefs(instance, mpInstance);
          initMocks(instance, mpInstance, mocks2);
          initComponentInstance(instance, options);
        }
      });
    },
    ready() {
      if (this.$vm) {
        {
          this.$vm.$callHook("mounted");
          this.$vm.$callHook(ON_READY);
        }
      }
    },
    detached() {
      if (this.$vm) {
        pruneComponentPropsCache(this.$vm.$.uid);
        $destroyComponent(this.$vm);
      }
    }
  };
}
const mocks = ["__route__", "__wxExparserNodeId__", "__wxWebviewId__"];
function isPage(mpInstance) {
  return !!mpInstance.route;
}
function initRelation(mpInstance, detail) {
  mpInstance.triggerEvent("__l", detail);
}
function handleLink(event) {
  const detail = event.detail || event.value;
  const vuePid = detail.vuePid;
  let parentVm;
  if (vuePid) {
    parentVm = findVmByVueId(this.$vm, vuePid);
  }
  if (!parentVm) {
    parentVm = this.$vm;
  }
  detail.parent = parentVm;
}
var parseOptions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  mocks,
  isPage,
  initRelation,
  handleLink,
  initLifetimes
});
const createApp = initCreateApp();
const createPage = initCreatePage(parseOptions);
const createComponent = initCreateComponent(parseOptions);
const createPluginApp = initCreatePluginApp();
const createSubpackageApp = initCreateSubpackageApp();
{
  wx.createApp = global.createApp = createApp;
  wx.createPage = createPage;
  wx.createComponent = createComponent;
  wx.createPluginApp = global.createPluginApp = createPluginApp;
  wx.createSubpackageApp = global.createSubpackageApp = createSubpackageApp;
}
var dist = {};
(function(exports2) {
  !function(t, e) {
    for (var r in e)
      t[r] = e[r];
  }(exports2, function(t) {
    var e = {};
    function r(n) {
      if (e[n])
        return e[n].exports;
      var i = e[n] = { i: n, l: false, exports: {} };
      return t[n].call(i.exports, i, i.exports, r), i.l = true, i.exports;
    }
    return r.m = t, r.c = e, r.d = function(t2, e2, n) {
      r.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: n });
    }, r.r = function(t2) {
      typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
    }, r.t = function(t2, e2) {
      if (1 & e2 && (t2 = r(t2)), 8 & e2)
        return t2;
      if (4 & e2 && typeof t2 == "object" && t2 && t2.__esModule)
        return t2;
      var n = /* @__PURE__ */ Object.create(null);
      if (r.r(n), Object.defineProperty(n, "default", { enumerable: true, value: t2 }), 2 & e2 && typeof t2 != "string")
        for (var i in t2)
          r.d(n, i, function(e3) {
            return t2[e3];
          }.bind(null, i));
      return n;
    }, r.n = function(t2) {
      var e2 = t2 && t2.__esModule ? function() {
        return t2.default;
      } : function() {
        return t2;
      };
      return r.d(e2, "a", e2), e2;
    }, r.o = function(t2, e2) {
      return Object.prototype.hasOwnProperty.call(t2, e2);
    }, r.p = "", r(r.s = 4);
  }([function(t, e, r) {
    const n = r(1), i = r(2);
    t.exports = { atob: n, btoa: i };
  }, function(t, e, r) {
    function n(t2) {
      const e2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(t2);
      return e2 < 0 ? void 0 : e2;
    }
    t.exports = function(t2) {
      if ((t2 = (t2 = "" + t2).replace(/[ \t\n\f\r]/g, "")).length % 4 == 0 && (t2 = t2.replace(/==?$/, "")), t2.length % 4 == 1 || /[^+/0-9A-Za-z]/.test(t2))
        return null;
      let e2 = "", r2 = 0, i = 0;
      for (let a = 0; a < t2.length; a++)
        r2 <<= 6, r2 |= n(t2[a]), i += 6, i === 24 && (e2 += String.fromCharCode((16711680 & r2) >> 16), e2 += String.fromCharCode((65280 & r2) >> 8), e2 += String.fromCharCode(255 & r2), r2 = i = 0);
      return i === 12 ? (r2 >>= 4, e2 += String.fromCharCode(r2)) : i === 18 && (r2 >>= 2, e2 += String.fromCharCode((65280 & r2) >> 8), e2 += String.fromCharCode(255 & r2)), e2;
    };
  }, function(t, e, r) {
    function n(t2) {
      if (t2 >= 0 && t2 < 64)
        return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[t2];
    }
    t.exports = function(t2) {
      let e2;
      for (t2 = "" + t2, e2 = 0; e2 < t2.length; e2++)
        if (t2.charCodeAt(e2) > 255)
          return null;
      let r2 = "";
      for (e2 = 0; e2 < t2.length; e2 += 3) {
        const i = [void 0, void 0, void 0, void 0];
        i[0] = t2.charCodeAt(e2) >> 2, i[1] = (3 & t2.charCodeAt(e2)) << 4, t2.length > e2 + 1 && (i[1] |= t2.charCodeAt(e2 + 1) >> 4, i[2] = (15 & t2.charCodeAt(e2 + 1)) << 2), t2.length > e2 + 2 && (i[2] |= t2.charCodeAt(e2 + 2) >> 6, i[3] = 63 & t2.charCodeAt(e2 + 2));
        for (let t3 = 0; t3 < i.length; t3++)
          i[t3] === void 0 ? r2 += "=" : r2 += n(i[t3]);
      }
      return r2;
    };
  }, function(t, e) {
    (function(e2) {
      t.exports = e2;
    }).call(this, {});
  }, function(t, e, r) {
    r.r(e), r.d(e, "createScopedThreejs", function() {
      return P;
    });
    var n = r(0);
    function i(t2, e2) {
      var r2 = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(t2);
        e2 && (n2 = n2.filter(function(e3) {
          return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
        })), r2.push.apply(r2, n2);
      }
      return r2;
    }
    function a(t2) {
      for (var e2 = 1; e2 < arguments.length; e2++) {
        var r2 = arguments[e2] != null ? arguments[e2] : {};
        e2 % 2 ? i(Object(r2), true).forEach(function(e3) {
          o2(t2, e3, r2[e3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(r2)) : i(Object(r2)).forEach(function(e3) {
          Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(r2, e3));
        });
      }
      return t2;
    }
    function o2(t2, e2, r2) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }) : t2[e2] = r2, t2;
    }
    function s(t2, e2) {
      for (var r2 = 0; r2 < e2.length; r2++) {
        var n2 = e2[r2];
        n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
      }
    }
    function c(t2, e2) {
      if (!(t2 instanceof e2))
        throw new TypeError("Cannot call a class as a function");
    }
    var l = /* @__PURE__ */ new WeakMap(), h = function t2(e2) {
      c(this, t2), this.identifier = e2.identifier, this.force = e2.force === void 0 ? 1 : e2.force, this.pageX = e2.pageX || e2.x, this.pageY = e2.pageY || e2.y, this.clientX = e2.clientX || e2.x, this.clientY = e2.clientY || e2.y, this.screenX = this.pageX, this.screenY = this.pageY;
    }, u = function() {
      function t2() {
        c(this, t2), l.set(this, {});
      }
      var e2, r2;
      return e2 = t2, (r2 = [{ key: "addEventListener", value: function(t3, e3) {
        var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n2 = l.get(this);
        n2 || (n2 = {}, l.set(this, n2)), n2[t3] || (n2[t3] = []), n2[t3].push(e3), r3.capture, r3.once, r3.passive;
      } }, { key: "removeEventListener", value: function(t3, e3) {
        var r3 = l.get(this);
        if (r3) {
          var n2 = r3[t3];
          if (n2 && n2.length > 0) {
            for (var i2 = n2.length; i2--; i2 > 0)
              if (n2[i2] === e3) {
                n2.splice(i2, 1);
                break;
              }
          }
        }
      } }, { key: "dispatchEvent", value: function() {
        var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        typeof t3.preventDefault != "function" && (t3.preventDefault = function() {
        }), typeof t3.stopPropagation != "function" && (t3.stopPropagation = function() {
        });
        var e3 = l.get(this)[t3.type];
        if (e3)
          for (var r3 = 0; r3 < e3.length; r3++)
            e3[r3](t3);
      } }, { key: "dispatchTouchEvent", value: function() {
        var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e3 = a({}, this), r3 = { changedTouches: t3.changedTouches.map(function(t4) {
          return new h(t4);
        }), touches: t3.touches.map(function(t4) {
          return new h(t4);
        }), targetTouches: Array.prototype.slice.call(t3.touches.map(function(t4) {
          return new h(t4);
        })), timeStamp: t3.timeStamp, target: e3, currentTarget: e3, type: t3.type, cancelBubble: false, cancelable: false };
        this.dispatchEvent(r3);
      } }]) && s(e2.prototype, r2), t2;
    }();
    function p(t2) {
      return (p = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      })(t2);
    }
    function d(t2, e2) {
      for (var r2 = 0; r2 < e2.length; r2++) {
        var n2 = e2[r2];
        n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
      }
    }
    function f(t2, e2) {
      return (f = Object.setPrototypeOf || function(t3, e3) {
        return t3.__proto__ = e3, t3;
      })(t2, e2);
    }
    function m(t2) {
      var e2 = function() {
        if (typeof Reflect == "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy == "function")
          return true;
        try {
          return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          })), true;
        } catch (t3) {
          return false;
        }
      }();
      return function() {
        var r2, n2 = y(t2);
        if (e2) {
          var i2 = y(this).constructor;
          r2 = Reflect.construct(n2, arguments, i2);
        } else
          r2 = n2.apply(this, arguments);
        return g(this, r2);
      };
    }
    function g(t2, e2) {
      return !e2 || p(e2) !== "object" && typeof e2 != "function" ? v(t2) : e2;
    }
    function v(t2) {
      if (t2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t2;
    }
    function y(t2) {
      return (y = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
        return t3.__proto__ || Object.getPrototypeOf(t3);
      })(t2);
    }
    var x = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap(), w = /* @__PURE__ */ new WeakMap();
    function _(t2) {
      var e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      e2.target = e2.target || this, typeof this["on".concat(t2)] == "function" && this["on".concat(t2)].call(this, e2);
    }
    function M(t2) {
      var e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.readyState = t2, e2.readyState = t2, _.call(this, "readystatechange", e2);
    }
    function S(t2) {
      return !/^(http|https|ftp|wxfile):\/\/.*/i.test(t2);
    }
    var T = function(t2) {
      !function(t3, e3) {
        if (typeof e3 != "function" && e3 !== null)
          throw new TypeError("Super expression must either be null or a function");
        t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && f(t3, e3);
      }(a2, t2);
      var e2, r2, i2 = m(a2);
      function a2() {
        var t3;
        return function(t4, e3) {
          if (!(t4 instanceof e3))
            throw new TypeError("Cannot call a class as a function");
        }(this, a2), (t3 = i2.call(this)).onabort = null, t3.onerror = null, t3.onload = null, t3.onloadstart = null, t3.onprogress = null, t3.ontimeout = null, t3.onloadend = null, t3.onreadystatechange = null, t3.readyState = 0, t3.response = null, t3.responseText = null, t3.responseType = "text", t3.dataType = "string", t3.responseXML = null, t3.status = 0, t3.statusText = "", t3.upload = {}, t3.withCredentials = false, x.set(v(t3), { "content-type": "application/x-www-form-urlencoded" }), b.set(v(t3), {}), t3;
      }
      return e2 = a2, (r2 = [{ key: "abort", value: function() {
        var t3 = w.get(this);
        t3 && t3.abort();
      } }, { key: "getAllResponseHeaders", value: function() {
        var t3 = b.get(this);
        return Object.keys(t3).map(function(e3) {
          return "".concat(e3, ": ").concat(t3[e3]);
        }).join("\n");
      } }, { key: "getResponseHeader", value: function(t3) {
        return b.get(this)[t3];
      } }, { key: "open", value: function(t3, e3) {
        this._method = t3, this._url = e3, M.call(this, a2.OPENED);
      } }, { key: "overrideMimeType", value: function() {
      } }, { key: "send", value: function() {
        var t3 = this, e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        if (this.readyState !== a2.OPENED)
          throw new Error("Failed to execute 'send' on 'XMLHttpRequest': The object's state must be OPENED.");
        var r3, n2 = this._url, i3 = x.get(this), o3 = this.responseType, s2 = this.dataType, c2 = S(n2);
        o3 === "arraybuffer" || (r3 = "utf8"), delete this.response, this.response = null;
        var l2 = function(e4) {
          var r4 = e4.data, n3 = e4.statusCode, i4 = e4.header;
          if (n3 = n3 === void 0 ? 200 : n3, typeof r4 != "string" && !(r4 instanceof ArrayBuffer))
            try {
              r4 = JSON.stringify(r4);
            } catch (t4) {
            }
          t3.status = n3, i4 && b.set(t3, i4), _.call(t3, "loadstart"), M.call(t3, a2.HEADERS_RECEIVED), M.call(t3, a2.LOADING), t3.response = r4, r4 instanceof ArrayBuffer ? Object.defineProperty(t3, "responseText", { enumerable: true, configurable: true, get: function() {
            throw "InvalidStateError : responseType is " + this.responseType;
          } }) : t3.responseText = r4, M.call(t3, a2.DONE), _.call(t3, "load"), _.call(t3, "loadend");
        }, h2 = function(e4) {
          var r4 = e4.errMsg;
          r4.indexOf("abort") !== -1 ? _.call(t3, "abort") : _.call(t3, "error", { message: r4 }), _.call(t3, "loadend"), c2 && console.warn(r4);
        };
        if (c2) {
          var u2 = wx.getFileSystemManager(), p2 = { filePath: n2, success: l2, fail: h2 };
          return r3 && (p2.encoding = r3), void u2.readFile(p2);
        }
        wx.request({ data: e3, url: n2, method: this._method, header: i3, dataType: s2, responseType: o3, success: l2, fail: h2 });
      } }, { key: "setRequestHeader", value: function(t3, e3) {
        var r3 = x.get(this);
        r3[t3] = e3, x.set(this, r3);
      } }, { key: "addEventListener", value: function(t3, e3) {
        var r3 = this;
        typeof e3 == "function" && (this["on" + t3] = function() {
          var t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          t4.target = t4.target || r3, e3.call(r3, t4);
        });
      } }, { key: "removeEventListener", value: function(t3, e3) {
        this["on" + t3] === e3 && (this["on" + t3] = null);
      } }]) && d(e2.prototype, r2), a2;
    }(u);
    function E2(t2, e2) {
      var r2;
      if (typeof Symbol == "undefined" || t2[Symbol.iterator] == null) {
        if (Array.isArray(t2) || (r2 = function(t3, e3) {
          if (!t3)
            return;
          if (typeof t3 == "string")
            return A(t3, e3);
          var r3 = Object.prototype.toString.call(t3).slice(8, -1);
          r3 === "Object" && t3.constructor && (r3 = t3.constructor.name);
          if (r3 === "Map" || r3 === "Set")
            return Array.from(t3);
          if (r3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3))
            return A(t3, e3);
        }(t2)) || e2 && t2 && typeof t2.length == "number") {
          r2 && (t2 = r2);
          var n2 = 0, i2 = function() {
          };
          return { s: i2, n: function() {
            return n2 >= t2.length ? { done: true } : { done: false, value: t2[n2++] };
          }, e: function(t3) {
            throw t3;
          }, f: i2 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var a2, o3 = true, s2 = false;
      return { s: function() {
        r2 = t2[Symbol.iterator]();
      }, n: function() {
        var t3 = r2.next();
        return o3 = t3.done, t3;
      }, e: function(t3) {
        s2 = true, a2 = t3;
      }, f: function() {
        try {
          o3 || r2.return == null || r2.return();
        } finally {
          if (s2)
            throw a2;
        }
      } };
    }
    function A(t2, e2) {
      (e2 == null || e2 > t2.length) && (e2 = t2.length);
      for (var r2 = 0, n2 = new Array(e2); r2 < e2; r2++)
        n2[r2] = t2[r2];
      return n2;
    }
    function L(t2, e2) {
      var r2, n2 = E2(Object.getOwnPropertyNames(e2));
      try {
        for (n2.s(); !(r2 = n2.n()).done; ) {
          var i2 = r2.value;
          if (i2 !== "constructor" && i2 !== "prototype" && i2 !== "name") {
            var a2 = Object.getOwnPropertyDescriptor(e2, i2);
            Object.defineProperty(t2, i2, a2);
          }
        }
      } catch (t3) {
        n2.e(t3);
      } finally {
        n2.f();
      }
    }
    function R(t2) {
      return (R = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      })(t2);
    }
    function P(e2) {
      Object.defineProperty(e2, "style", { get: function() {
        return { width: this.width + "px", height: this.height + "px" };
      } }), Object.defineProperty(e2, "clientHeight", { get: function() {
        return this.height;
      } }), Object.defineProperty(e2, "clientWidth", { get: function() {
        return this.width;
      } }), L(e2.constructor.prototype, u.prototype);
      var i2 = { createElementNS: function(t2, r2) {
        return r2 === "canvas" ? e2 : r2 === "img" ? e2.createImage() : void 0;
      } };
      L(i2.constructor.prototype, u.prototype);
      var a2 = { AudioContext: function() {
      }, URL: {} };
      L(a2.constructor.prototype, u.prototype);
      var o3, s2, c2 = T, l2 = {};
      return o3 = this, s2 = function(t2) {
        function e3() {
        }
        Number.EPSILON === void 0 && (Number.EPSILON = Math.pow(2, -52)), Number.isInteger === void 0 && (Number.isInteger = function(t3) {
          return typeof t3 == "number" && isFinite(t3) && Math.floor(t3) === t3;
        }), Math.sign === void 0 && (Math.sign = function(t3) {
          return t3 < 0 ? -1 : t3 > 0 ? 1 : +t3;
        }), "name" in Function.prototype == 0 && Object.defineProperty(Function.prototype, "name", { get: function() {
          return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
        } }), Object.assign === void 0 && (Object.assign = function(t3) {
          if (t3 == null)
            throw new TypeError("Cannot convert undefined or null to object");
          for (var e4 = Object(t3), r3 = 1; r3 < arguments.length; r3++) {
            var n2 = arguments[r3];
            if (n2 != null)
              for (var i3 in n2)
                Object.prototype.hasOwnProperty.call(n2, i3) && (e4[i3] = n2[i3]);
          }
          return e4;
        }), Object.assign(e3.prototype, { addEventListener: function(t3, e4) {
          this._listeners === void 0 && (this._listeners = {});
          var r3 = this._listeners;
          r3[t3] === void 0 && (r3[t3] = []), r3[t3].indexOf(e4) === -1 && r3[t3].push(e4);
        }, hasEventListener: function(t3, e4) {
          if (this._listeners === void 0)
            return false;
          var r3 = this._listeners;
          return r3[t3] !== void 0 && r3[t3].indexOf(e4) !== -1;
        }, removeEventListener: function(t3, e4) {
          if (this._listeners !== void 0) {
            var r3 = this._listeners[t3];
            if (r3 !== void 0) {
              var n2 = r3.indexOf(e4);
              n2 !== -1 && r3.splice(n2, 1);
            }
          }
        }, dispatchEvent: function(t3) {
          if (this._listeners !== void 0) {
            var e4 = this._listeners[t3.type];
            if (e4 !== void 0) {
              t3.target = this;
              for (var r3 = e4.slice(0), n2 = 0, i3 = r3.length; n2 < i3; n2++)
                r3[n2].call(this, t3);
            }
          }
        } });
        for (var r2 = [], o4 = 0; o4 < 256; o4++)
          r2[o4] = (o4 < 16 ? "0" : "") + o4.toString(16);
        var s3 = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function() {
          var t3 = 4294967295 * Math.random() | 0, e4 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0, i3 = 4294967295 * Math.random() | 0;
          return (r2[255 & t3] + r2[t3 >> 8 & 255] + r2[t3 >> 16 & 255] + r2[t3 >> 24 & 255] + "-" + r2[255 & e4] + r2[e4 >> 8 & 255] + "-" + r2[e4 >> 16 & 15 | 64] + r2[e4 >> 24 & 255] + "-" + r2[63 & n2 | 128] + r2[n2 >> 8 & 255] + "-" + r2[n2 >> 16 & 255] + r2[n2 >> 24 & 255] + r2[255 & i3] + r2[i3 >> 8 & 255] + r2[i3 >> 16 & 255] + r2[i3 >> 24 & 255]).toUpperCase();
        }, clamp: function(t3, e4, r3) {
          return Math.max(e4, Math.min(r3, t3));
        }, euclideanModulo: function(t3, e4) {
          return (t3 % e4 + e4) % e4;
        }, mapLinear: function(t3, e4, r3, n2, i3) {
          return n2 + (t3 - e4) * (i3 - n2) / (r3 - e4);
        }, lerp: function(t3, e4, r3) {
          return (1 - r3) * t3 + r3 * e4;
        }, smoothstep: function(t3, e4, r3) {
          return t3 <= e4 ? 0 : t3 >= r3 ? 1 : (t3 = (t3 - e4) / (r3 - e4)) * t3 * (3 - 2 * t3);
        }, smootherstep: function(t3, e4, r3) {
          return t3 <= e4 ? 0 : t3 >= r3 ? 1 : (t3 = (t3 - e4) / (r3 - e4)) * t3 * t3 * (t3 * (6 * t3 - 15) + 10);
        }, randInt: function(t3, e4) {
          return t3 + Math.floor(Math.random() * (e4 - t3 + 1));
        }, randFloat: function(t3, e4) {
          return t3 + Math.random() * (e4 - t3);
        }, randFloatSpread: function(t3) {
          return t3 * (0.5 - Math.random());
        }, degToRad: function(t3) {
          return t3 * s3.DEG2RAD;
        }, radToDeg: function(t3) {
          return t3 * s3.RAD2DEG;
        }, isPowerOfTwo: function(t3) {
          return (t3 & t3 - 1) == 0 && t3 !== 0;
        }, ceilPowerOfTwo: function(t3) {
          return Math.pow(2, Math.ceil(Math.log(t3) / Math.LN2));
        }, floorPowerOfTwo: function(t3) {
          return Math.pow(2, Math.floor(Math.log(t3) / Math.LN2));
        } };
        function l3(t3, e4) {
          this.x = t3 || 0, this.y = e4 || 0;
        }
        function h2(t3, e4, r3, n2) {
          this._x = t3 || 0, this._y = e4 || 0, this._z = r3 || 0, this._w = n2 !== void 0 ? n2 : 1;
        }
        Object.defineProperties(l3.prototype, { width: { get: function() {
          return this.x;
        }, set: function(t3) {
          this.x = t3;
        } }, height: { get: function() {
          return this.y;
        }, set: function(t3) {
          this.y = t3;
        } } }), Object.assign(l3.prototype, { isVector2: true, set: function(t3, e4) {
          return this.x = t3, this.y = e4, this;
        }, setScalar: function(t3) {
          return this.x = t3, this.y = t3, this;
        }, setX: function(t3) {
          return this.x = t3, this;
        }, setY: function(t3) {
          return this.y = t3, this;
        }, setComponent: function(t3, e4) {
          switch (t3) {
            case 0:
              this.x = e4;
              break;
            case 1:
              this.y = e4;
              break;
            default:
              throw new Error("index is out of range: " + t3);
          }
          return this;
        }, getComponent: function(t3) {
          switch (t3) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t3);
          }
        }, clone: function() {
          return new this.constructor(this.x, this.y);
        }, copy: function(t3) {
          return this.x = t3.x, this.y = t3.y, this;
        }, add: function(t3, e4) {
          return e4 !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t3, e4)) : (this.x += t3.x, this.y += t3.y, this);
        }, addScalar: function(t3) {
          return this.x += t3, this.y += t3, this;
        }, addVectors: function(t3, e4) {
          return this.x = t3.x + e4.x, this.y = t3.y + e4.y, this;
        }, addScaledVector: function(t3, e4) {
          return this.x += t3.x * e4, this.y += t3.y * e4, this;
        }, sub: function(t3, e4) {
          return e4 !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t3, e4)) : (this.x -= t3.x, this.y -= t3.y, this);
        }, subScalar: function(t3) {
          return this.x -= t3, this.y -= t3, this;
        }, subVectors: function(t3, e4) {
          return this.x = t3.x - e4.x, this.y = t3.y - e4.y, this;
        }, multiply: function(t3) {
          return this.x *= t3.x, this.y *= t3.y, this;
        }, multiplyScalar: function(t3) {
          return this.x *= t3, this.y *= t3, this;
        }, divide: function(t3) {
          return this.x /= t3.x, this.y /= t3.y, this;
        }, divideScalar: function(t3) {
          return this.multiplyScalar(1 / t3);
        }, applyMatrix3: function(t3) {
          var e4 = this.x, r3 = this.y, n2 = t3.elements;
          return this.x = n2[0] * e4 + n2[3] * r3 + n2[6], this.y = n2[1] * e4 + n2[4] * r3 + n2[7], this;
        }, min: function(t3) {
          return this.x = Math.min(this.x, t3.x), this.y = Math.min(this.y, t3.y), this;
        }, max: function(t3) {
          return this.x = Math.max(this.x, t3.x), this.y = Math.max(this.y, t3.y), this;
        }, clamp: function(t3, e4) {
          return this.x = Math.max(t3.x, Math.min(e4.x, this.x)), this.y = Math.max(t3.y, Math.min(e4.y, this.y)), this;
        }, clampScalar: function(t3, e4) {
          return this.x = Math.max(t3, Math.min(e4, this.x)), this.y = Math.max(t3, Math.min(e4, this.y)), this;
        }, clampLength: function(t3, e4) {
          var r3 = this.length();
          return this.divideScalar(r3 || 1).multiplyScalar(Math.max(t3, Math.min(e4, r3)));
        }, floor: function() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }, ceil: function() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }, round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, roundToZero: function() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
        }, negate: function() {
          return this.x = -this.x, this.y = -this.y, this;
        }, dot: function(t3) {
          return this.x * t3.x + this.y * t3.y;
        }, cross: function(t3) {
          return this.x * t3.y - this.y * t3.x;
        }, lengthSq: function() {
          return this.x * this.x + this.y * this.y;
        }, length: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, manhattanLength: function() {
          return Math.abs(this.x) + Math.abs(this.y);
        }, normalize: function() {
          return this.divideScalar(this.length() || 1);
        }, angle: function() {
          var t3 = Math.atan2(this.y, this.x);
          return t3 < 0 && (t3 += 2 * Math.PI), t3;
        }, distanceTo: function(t3) {
          return Math.sqrt(this.distanceToSquared(t3));
        }, distanceToSquared: function(t3) {
          var e4 = this.x - t3.x, r3 = this.y - t3.y;
          return e4 * e4 + r3 * r3;
        }, manhattanDistanceTo: function(t3) {
          return Math.abs(this.x - t3.x) + Math.abs(this.y - t3.y);
        }, setLength: function(t3) {
          return this.normalize().multiplyScalar(t3);
        }, lerp: function(t3, e4) {
          return this.x += (t3.x - this.x) * e4, this.y += (t3.y - this.y) * e4, this;
        }, lerpVectors: function(t3, e4, r3) {
          return this.subVectors(e4, t3).multiplyScalar(r3).add(t3);
        }, equals: function(t3) {
          return t3.x === this.x && t3.y === this.y;
        }, fromArray: function(t3, e4) {
          return e4 === void 0 && (e4 = 0), this.x = t3[e4], this.y = t3[e4 + 1], this;
        }, toArray: function(t3, e4) {
          return t3 === void 0 && (t3 = []), e4 === void 0 && (e4 = 0), t3[e4] = this.x, t3[e4 + 1] = this.y, t3;
        }, fromBufferAttribute: function(t3, e4, r3) {
          return r3 !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t3.getX(e4), this.y = t3.getY(e4), this;
        }, rotateAround: function(t3, e4) {
          var r3 = Math.cos(e4), n2 = Math.sin(e4), i3 = this.x - t3.x, a3 = this.y - t3.y;
          return this.x = i3 * r3 - a3 * n2 + t3.x, this.y = i3 * n2 + a3 * r3 + t3.y, this;
        } }), Object.assign(h2, { slerp: function(t3, e4, r3, n2) {
          return r3.copy(t3).slerp(e4, n2);
        }, slerpFlat: function(t3, e4, r3, n2, i3, a3, o5) {
          var s4 = r3[n2 + 0], c3 = r3[n2 + 1], l4 = r3[n2 + 2], h3 = r3[n2 + 3], u3 = i3[a3 + 0], p3 = i3[a3 + 1], d3 = i3[a3 + 2], f3 = i3[a3 + 3];
          if (h3 !== f3 || s4 !== u3 || c3 !== p3 || l4 !== d3) {
            var m3 = 1 - o5, g3 = s4 * u3 + c3 * p3 + l4 * d3 + h3 * f3, v3 = g3 >= 0 ? 1 : -1, y3 = 1 - g3 * g3;
            if (y3 > Number.EPSILON) {
              var x3 = Math.sqrt(y3), b3 = Math.atan2(x3, g3 * v3);
              m3 = Math.sin(m3 * b3) / x3, o5 = Math.sin(o5 * b3) / x3;
            }
            var w3 = o5 * v3;
            if (s4 = s4 * m3 + u3 * w3, c3 = c3 * m3 + p3 * w3, l4 = l4 * m3 + d3 * w3, h3 = h3 * m3 + f3 * w3, m3 === 1 - o5) {
              var _3 = 1 / Math.sqrt(s4 * s4 + c3 * c3 + l4 * l4 + h3 * h3);
              s4 *= _3, c3 *= _3, l4 *= _3, h3 *= _3;
            }
          }
          t3[e4] = s4, t3[e4 + 1] = c3, t3[e4 + 2] = l4, t3[e4 + 3] = h3;
        } }), Object.defineProperties(h2.prototype, { x: { get: function() {
          return this._x;
        }, set: function(t3) {
          this._x = t3, this._onChangeCallback();
        } }, y: { get: function() {
          return this._y;
        }, set: function(t3) {
          this._y = t3, this._onChangeCallback();
        } }, z: { get: function() {
          return this._z;
        }, set: function(t3) {
          this._z = t3, this._onChangeCallback();
        } }, w: { get: function() {
          return this._w;
        }, set: function(t3) {
          this._w = t3, this._onChangeCallback();
        } } }), Object.assign(h2.prototype, { isQuaternion: true, set: function(t3, e4, r3, n2) {
          return this._x = t3, this._y = e4, this._z = r3, this._w = n2, this._onChangeCallback(), this;
        }, clone: function() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }, copy: function(t3) {
          return this._x = t3.x, this._y = t3.y, this._z = t3.z, this._w = t3.w, this._onChangeCallback(), this;
        }, setFromEuler: function(t3, e4) {
          if (!t3 || !t3.isEuler)
            throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
          var r3 = t3._x, n2 = t3._y, i3 = t3._z, a3 = t3.order, o5 = Math.cos, s4 = Math.sin, c3 = o5(r3 / 2), l4 = o5(n2 / 2), h3 = o5(i3 / 2), u3 = s4(r3 / 2), p3 = s4(n2 / 2), d3 = s4(i3 / 2);
          return a3 === "XYZ" ? (this._x = u3 * l4 * h3 + c3 * p3 * d3, this._y = c3 * p3 * h3 - u3 * l4 * d3, this._z = c3 * l4 * d3 + u3 * p3 * h3, this._w = c3 * l4 * h3 - u3 * p3 * d3) : a3 === "YXZ" ? (this._x = u3 * l4 * h3 + c3 * p3 * d3, this._y = c3 * p3 * h3 - u3 * l4 * d3, this._z = c3 * l4 * d3 - u3 * p3 * h3, this._w = c3 * l4 * h3 + u3 * p3 * d3) : a3 === "ZXY" ? (this._x = u3 * l4 * h3 - c3 * p3 * d3, this._y = c3 * p3 * h3 + u3 * l4 * d3, this._z = c3 * l4 * d3 + u3 * p3 * h3, this._w = c3 * l4 * h3 - u3 * p3 * d3) : a3 === "ZYX" ? (this._x = u3 * l4 * h3 - c3 * p3 * d3, this._y = c3 * p3 * h3 + u3 * l4 * d3, this._z = c3 * l4 * d3 - u3 * p3 * h3, this._w = c3 * l4 * h3 + u3 * p3 * d3) : a3 === "YZX" ? (this._x = u3 * l4 * h3 + c3 * p3 * d3, this._y = c3 * p3 * h3 + u3 * l4 * d3, this._z = c3 * l4 * d3 - u3 * p3 * h3, this._w = c3 * l4 * h3 - u3 * p3 * d3) : a3 === "XZY" && (this._x = u3 * l4 * h3 - c3 * p3 * d3, this._y = c3 * p3 * h3 - u3 * l4 * d3, this._z = c3 * l4 * d3 + u3 * p3 * h3, this._w = c3 * l4 * h3 + u3 * p3 * d3), e4 !== false && this._onChangeCallback(), this;
        }, setFromAxisAngle: function(t3, e4) {
          var r3 = e4 / 2, n2 = Math.sin(r3);
          return this._x = t3.x * n2, this._y = t3.y * n2, this._z = t3.z * n2, this._w = Math.cos(r3), this._onChangeCallback(), this;
        }, setFromRotationMatrix: function(t3) {
          var e4, r3 = t3.elements, n2 = r3[0], i3 = r3[4], a3 = r3[8], o5 = r3[1], s4 = r3[5], c3 = r3[9], l4 = r3[2], h3 = r3[6], u3 = r3[10], p3 = n2 + s4 + u3;
          return p3 > 0 ? (e4 = 0.5 / Math.sqrt(p3 + 1), this._w = 0.25 / e4, this._x = (h3 - c3) * e4, this._y = (a3 - l4) * e4, this._z = (o5 - i3) * e4) : n2 > s4 && n2 > u3 ? (e4 = 2 * Math.sqrt(1 + n2 - s4 - u3), this._w = (h3 - c3) / e4, this._x = 0.25 * e4, this._y = (i3 + o5) / e4, this._z = (a3 + l4) / e4) : s4 > u3 ? (e4 = 2 * Math.sqrt(1 + s4 - n2 - u3), this._w = (a3 - l4) / e4, this._x = (i3 + o5) / e4, this._y = 0.25 * e4, this._z = (c3 + h3) / e4) : (e4 = 2 * Math.sqrt(1 + u3 - n2 - s4), this._w = (o5 - i3) / e4, this._x = (a3 + l4) / e4, this._y = (c3 + h3) / e4, this._z = 0.25 * e4), this._onChangeCallback(), this;
        }, setFromUnitVectors: function(t3, e4) {
          var r3 = t3.dot(e4) + 1;
          return r3 < 1e-6 ? (r3 = 0, Math.abs(t3.x) > Math.abs(t3.z) ? (this._x = -t3.y, this._y = t3.x, this._z = 0, this._w = r3) : (this._x = 0, this._y = -t3.z, this._z = t3.y, this._w = r3)) : (this._x = t3.y * e4.z - t3.z * e4.y, this._y = t3.z * e4.x - t3.x * e4.z, this._z = t3.x * e4.y - t3.y * e4.x, this._w = r3), this.normalize();
        }, angleTo: function(t3) {
          return 2 * Math.acos(Math.abs(s3.clamp(this.dot(t3), -1, 1)));
        }, rotateTowards: function(t3, e4) {
          var r3 = this.angleTo(t3);
          if (r3 === 0)
            return this;
          var n2 = Math.min(1, e4 / r3);
          return this.slerp(t3, n2), this;
        }, inverse: function() {
          return this.conjugate();
        }, conjugate: function() {
          return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }, dot: function(t3) {
          return this._x * t3._x + this._y * t3._y + this._z * t3._z + this._w * t3._w;
        }, lengthSq: function() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }, length: function() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }, normalize: function() {
          var t3 = this.length();
          return t3 === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t3 = 1 / t3, this._x = this._x * t3, this._y = this._y * t3, this._z = this._z * t3, this._w = this._w * t3), this._onChangeCallback(), this;
        }, multiply: function(t3, e4) {
          return e4 !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t3, e4)) : this.multiplyQuaternions(this, t3);
        }, premultiply: function(t3) {
          return this.multiplyQuaternions(t3, this);
        }, multiplyQuaternions: function(t3, e4) {
          var r3 = t3._x, n2 = t3._y, i3 = t3._z, a3 = t3._w, o5 = e4._x, s4 = e4._y, c3 = e4._z, l4 = e4._w;
          return this._x = r3 * l4 + a3 * o5 + n2 * c3 - i3 * s4, this._y = n2 * l4 + a3 * s4 + i3 * o5 - r3 * c3, this._z = i3 * l4 + a3 * c3 + r3 * s4 - n2 * o5, this._w = a3 * l4 - r3 * o5 - n2 * s4 - i3 * c3, this._onChangeCallback(), this;
        }, slerp: function(t3, e4) {
          if (e4 === 0)
            return this;
          if (e4 === 1)
            return this.copy(t3);
          var r3 = this._x, n2 = this._y, i3 = this._z, a3 = this._w, o5 = a3 * t3._w + r3 * t3._x + n2 * t3._y + i3 * t3._z;
          if (o5 < 0 ? (this._w = -t3._w, this._x = -t3._x, this._y = -t3._y, this._z = -t3._z, o5 = -o5) : this.copy(t3), o5 >= 1)
            return this._w = a3, this._x = r3, this._y = n2, this._z = i3, this;
          var s4 = 1 - o5 * o5;
          if (s4 <= Number.EPSILON) {
            var c3 = 1 - e4;
            return this._w = c3 * a3 + e4 * this._w, this._x = c3 * r3 + e4 * this._x, this._y = c3 * n2 + e4 * this._y, this._z = c3 * i3 + e4 * this._z, this.normalize(), this._onChangeCallback(), this;
          }
          var l4 = Math.sqrt(s4), h3 = Math.atan2(l4, o5), u3 = Math.sin((1 - e4) * h3) / l4, p3 = Math.sin(e4 * h3) / l4;
          return this._w = a3 * u3 + this._w * p3, this._x = r3 * u3 + this._x * p3, this._y = n2 * u3 + this._y * p3, this._z = i3 * u3 + this._z * p3, this._onChangeCallback(), this;
        }, equals: function(t3) {
          return t3._x === this._x && t3._y === this._y && t3._z === this._z && t3._w === this._w;
        }, fromArray: function(t3, e4) {
          return e4 === void 0 && (e4 = 0), this._x = t3[e4], this._y = t3[e4 + 1], this._z = t3[e4 + 2], this._w = t3[e4 + 3], this._onChangeCallback(), this;
        }, toArray: function(t3, e4) {
          return t3 === void 0 && (t3 = []), e4 === void 0 && (e4 = 0), t3[e4] = this._x, t3[e4 + 1] = this._y, t3[e4 + 2] = this._z, t3[e4 + 3] = this._w, t3;
        }, _onChange: function(t3) {
          return this._onChangeCallback = t3, this;
        }, _onChangeCallback: function() {
        } });
        var u2 = new d2(), p2 = new h2();
        function d2(t3, e4, r3) {
          this.x = t3 || 0, this.y = e4 || 0, this.z = r3 || 0;
        }
        Object.assign(d2.prototype, { isVector3: true, set: function(t3, e4, r3) {
          return this.x = t3, this.y = e4, this.z = r3, this;
        }, setScalar: function(t3) {
          return this.x = t3, this.y = t3, this.z = t3, this;
        }, setX: function(t3) {
          return this.x = t3, this;
        }, setY: function(t3) {
          return this.y = t3, this;
        }, setZ: function(t3) {
          return this.z = t3, this;
        }, setComponent: function(t3, e4) {
          switch (t3) {
            case 0:
              this.x = e4;
              break;
            case 1:
              this.y = e4;
              break;
            case 2:
              this.z = e4;
              break;
            default:
              throw new Error("index is out of range: " + t3);
          }
          return this;
        }, getComponent: function(t3) {
          switch (t3) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + t3);
          }
        }, clone: function() {
          return new this.constructor(this.x, this.y, this.z);
        }, copy: function(t3) {
          return this.x = t3.x, this.y = t3.y, this.z = t3.z, this;
        }, add: function(t3, e4) {
          return e4 !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t3, e4)) : (this.x += t3.x, this.y += t3.y, this.z += t3.z, this);
        }, addScalar: function(t3) {
          return this.x += t3, this.y += t3, this.z += t3, this;
        }, addVectors: function(t3, e4) {
          return this.x = t3.x + e4.x, this.y = t3.y + e4.y, this.z = t3.z + e4.z, this;
        }, addScaledVector: function(t3, e4) {
          return this.x += t3.x * e4, this.y += t3.y * e4, this.z += t3.z * e4, this;
        }, sub: function(t3, e4) {
          return e4 !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t3, e4)) : (this.x -= t3.x, this.y -= t3.y, this.z -= t3.z, this);
        }, subScalar: function(t3) {
          return this.x -= t3, this.y -= t3, this.z -= t3, this;
        }, subVectors: function(t3, e4) {
          return this.x = t3.x - e4.x, this.y = t3.y - e4.y, this.z = t3.z - e4.z, this;
        }, multiply: function(t3, e4) {
          return e4 !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t3, e4)) : (this.x *= t3.x, this.y *= t3.y, this.z *= t3.z, this);
        }, multiplyScalar: function(t3) {
          return this.x *= t3, this.y *= t3, this.z *= t3, this;
        }, multiplyVectors: function(t3, e4) {
          return this.x = t3.x * e4.x, this.y = t3.y * e4.y, this.z = t3.z * e4.z, this;
        }, applyEuler: function(t3) {
          return t3 && t3.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(p2.setFromEuler(t3));
        }, applyAxisAngle: function(t3, e4) {
          return this.applyQuaternion(p2.setFromAxisAngle(t3, e4));
        }, applyMatrix3: function(t3) {
          var e4 = this.x, r3 = this.y, n2 = this.z, i3 = t3.elements;
          return this.x = i3[0] * e4 + i3[3] * r3 + i3[6] * n2, this.y = i3[1] * e4 + i3[4] * r3 + i3[7] * n2, this.z = i3[2] * e4 + i3[5] * r3 + i3[8] * n2, this;
        }, applyMatrix4: function(t3) {
          var e4 = this.x, r3 = this.y, n2 = this.z, i3 = t3.elements, a3 = 1 / (i3[3] * e4 + i3[7] * r3 + i3[11] * n2 + i3[15]);
          return this.x = (i3[0] * e4 + i3[4] * r3 + i3[8] * n2 + i3[12]) * a3, this.y = (i3[1] * e4 + i3[5] * r3 + i3[9] * n2 + i3[13]) * a3, this.z = (i3[2] * e4 + i3[6] * r3 + i3[10] * n2 + i3[14]) * a3, this;
        }, applyQuaternion: function(t3) {
          var e4 = this.x, r3 = this.y, n2 = this.z, i3 = t3.x, a3 = t3.y, o5 = t3.z, s4 = t3.w, c3 = s4 * e4 + a3 * n2 - o5 * r3, l4 = s4 * r3 + o5 * e4 - i3 * n2, h3 = s4 * n2 + i3 * r3 - a3 * e4, u3 = -i3 * e4 - a3 * r3 - o5 * n2;
          return this.x = c3 * s4 + u3 * -i3 + l4 * -o5 - h3 * -a3, this.y = l4 * s4 + u3 * -a3 + h3 * -i3 - c3 * -o5, this.z = h3 * s4 + u3 * -o5 + c3 * -a3 - l4 * -i3, this;
        }, project: function(t3) {
          return this.applyMatrix4(t3.matrixWorldInverse).applyMatrix4(t3.projectionMatrix);
        }, unproject: function(t3) {
          return this.applyMatrix4(t3.projectionMatrixInverse).applyMatrix4(t3.matrixWorld);
        }, transformDirection: function(t3) {
          var e4 = this.x, r3 = this.y, n2 = this.z, i3 = t3.elements;
          return this.x = i3[0] * e4 + i3[4] * r3 + i3[8] * n2, this.y = i3[1] * e4 + i3[5] * r3 + i3[9] * n2, this.z = i3[2] * e4 + i3[6] * r3 + i3[10] * n2, this.normalize();
        }, divide: function(t3) {
          return this.x /= t3.x, this.y /= t3.y, this.z /= t3.z, this;
        }, divideScalar: function(t3) {
          return this.multiplyScalar(1 / t3);
        }, min: function(t3) {
          return this.x = Math.min(this.x, t3.x), this.y = Math.min(this.y, t3.y), this.z = Math.min(this.z, t3.z), this;
        }, max: function(t3) {
          return this.x = Math.max(this.x, t3.x), this.y = Math.max(this.y, t3.y), this.z = Math.max(this.z, t3.z), this;
        }, clamp: function(t3, e4) {
          return this.x = Math.max(t3.x, Math.min(e4.x, this.x)), this.y = Math.max(t3.y, Math.min(e4.y, this.y)), this.z = Math.max(t3.z, Math.min(e4.z, this.z)), this;
        }, clampScalar: function(t3, e4) {
          return this.x = Math.max(t3, Math.min(e4, this.x)), this.y = Math.max(t3, Math.min(e4, this.y)), this.z = Math.max(t3, Math.min(e4, this.z)), this;
        }, clampLength: function(t3, e4) {
          var r3 = this.length();
          return this.divideScalar(r3 || 1).multiplyScalar(Math.max(t3, Math.min(e4, r3)));
        }, floor: function() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }, ceil: function() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }, round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }, roundToZero: function() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
        }, negate: function() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }, dot: function(t3) {
          return this.x * t3.x + this.y * t3.y + this.z * t3.z;
        }, lengthSq: function() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }, length: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }, manhattanLength: function() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }, normalize: function() {
          return this.divideScalar(this.length() || 1);
        }, setLength: function(t3) {
          return this.normalize().multiplyScalar(t3);
        }, lerp: function(t3, e4) {
          return this.x += (t3.x - this.x) * e4, this.y += (t3.y - this.y) * e4, this.z += (t3.z - this.z) * e4, this;
        }, lerpVectors: function(t3, e4, r3) {
          return this.subVectors(e4, t3).multiplyScalar(r3).add(t3);
        }, cross: function(t3, e4) {
          return e4 !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t3, e4)) : this.crossVectors(this, t3);
        }, crossVectors: function(t3, e4) {
          var r3 = t3.x, n2 = t3.y, i3 = t3.z, a3 = e4.x, o5 = e4.y, s4 = e4.z;
          return this.x = n2 * s4 - i3 * o5, this.y = i3 * a3 - r3 * s4, this.z = r3 * o5 - n2 * a3, this;
        }, projectOnVector: function(t3) {
          var e4 = t3.dot(this) / t3.lengthSq();
          return this.copy(t3).multiplyScalar(e4);
        }, projectOnPlane: function(t3) {
          return u2.copy(this).projectOnVector(t3), this.sub(u2);
        }, reflect: function(t3) {
          return this.sub(u2.copy(t3).multiplyScalar(2 * this.dot(t3)));
        }, angleTo: function(t3) {
          var e4 = this.dot(t3) / Math.sqrt(this.lengthSq() * t3.lengthSq());
          return Math.acos(s3.clamp(e4, -1, 1));
        }, distanceTo: function(t3) {
          return Math.sqrt(this.distanceToSquared(t3));
        }, distanceToSquared: function(t3) {
          var e4 = this.x - t3.x, r3 = this.y - t3.y, n2 = this.z - t3.z;
          return e4 * e4 + r3 * r3 + n2 * n2;
        }, manhattanDistanceTo: function(t3) {
          return Math.abs(this.x - t3.x) + Math.abs(this.y - t3.y) + Math.abs(this.z - t3.z);
        }, setFromSpherical: function(t3) {
          return this.setFromSphericalCoords(t3.radius, t3.phi, t3.theta);
        }, setFromSphericalCoords: function(t3, e4, r3) {
          var n2 = Math.sin(e4) * t3;
          return this.x = n2 * Math.sin(r3), this.y = Math.cos(e4) * t3, this.z = n2 * Math.cos(r3), this;
        }, setFromCylindrical: function(t3) {
          return this.setFromCylindricalCoords(t3.radius, t3.theta, t3.y);
        }, setFromCylindricalCoords: function(t3, e4, r3) {
          return this.x = t3 * Math.sin(e4), this.y = r3, this.z = t3 * Math.cos(e4), this;
        }, setFromMatrixPosition: function(t3) {
          var e4 = t3.elements;
          return this.x = e4[12], this.y = e4[13], this.z = e4[14], this;
        }, setFromMatrixScale: function(t3) {
          var e4 = this.setFromMatrixColumn(t3, 0).length(), r3 = this.setFromMatrixColumn(t3, 1).length(), n2 = this.setFromMatrixColumn(t3, 2).length();
          return this.x = e4, this.y = r3, this.z = n2, this;
        }, setFromMatrixColumn: function(t3, e4) {
          return this.fromArray(t3.elements, 4 * e4);
        }, equals: function(t3) {
          return t3.x === this.x && t3.y === this.y && t3.z === this.z;
        }, fromArray: function(t3, e4) {
          return e4 === void 0 && (e4 = 0), this.x = t3[e4], this.y = t3[e4 + 1], this.z = t3[e4 + 2], this;
        }, toArray: function(t3, e4) {
          return t3 === void 0 && (t3 = []), e4 === void 0 && (e4 = 0), t3[e4] = this.x, t3[e4 + 1] = this.y, t3[e4 + 2] = this.z, t3;
        }, fromBufferAttribute: function(t3, e4, r3) {
          return r3 !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t3.getX(e4), this.y = t3.getY(e4), this.z = t3.getZ(e4), this;
        } });
        var f2 = new d2();
        function m2() {
          this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
        }
        Object.assign(m2.prototype, { isMatrix3: true, set: function(t3, e4, r3, n2, i3, a3, o5, s4, c3) {
          var l4 = this.elements;
          return l4[0] = t3, l4[1] = n2, l4[2] = o5, l4[3] = e4, l4[4] = i3, l4[5] = s4, l4[6] = r3, l4[7] = a3, l4[8] = c3, this;
        }, identity: function() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }, clone: function() {
          return new this.constructor().fromArray(this.elements);
        }, copy: function(t3) {
          var e4 = this.elements, r3 = t3.elements;
          return e4[0] = r3[0], e4[1] = r3[1], e4[2] = r3[2], e4[3] = r3[3], e4[4] = r3[4], e4[5] = r3[5], e4[6] = r3[6], e4[7] = r3[7], e4[8] = r3[8], this;
        }, setFromMatrix4: function(t3) {
          var e4 = t3.elements;
          return this.set(e4[0], e4[4], e4[8], e4[1], e4[5], e4[9], e4[2], e4[6], e4[10]), this;
        }, applyToBufferAttribute: function(t3) {
          for (var e4 = 0, r3 = t3.count; e4 < r3; e4++)
            f2.x = t3.getX(e4), f2.y = t3.getY(e4), f2.z = t3.getZ(e4), f2.applyMatrix3(this), t3.setXYZ(e4, f2.x, f2.y, f2.z);
          return t3;
        }, multiply: function(t3) {
          return this.multiplyMatrices(this, t3);
        }, premultiply: function(t3) {
          return this.multiplyMatrices(t3, this);
        }, multiplyMatrices: function(t3, e4) {
          var r3 = t3.elements, n2 = e4.elements, i3 = this.elements, a3 = r3[0], o5 = r3[3], s4 = r3[6], c3 = r3[1], l4 = r3[4], h3 = r3[7], u3 = r3[2], p3 = r3[5], d3 = r3[8], f3 = n2[0], m3 = n2[3], g3 = n2[6], v3 = n2[1], y3 = n2[4], x3 = n2[7], b3 = n2[2], w3 = n2[5], _3 = n2[8];
          return i3[0] = a3 * f3 + o5 * v3 + s4 * b3, i3[3] = a3 * m3 + o5 * y3 + s4 * w3, i3[6] = a3 * g3 + o5 * x3 + s4 * _3, i3[1] = c3 * f3 + l4 * v3 + h3 * b3, i3[4] = c3 * m3 + l4 * y3 + h3 * w3, i3[7] = c3 * g3 + l4 * x3 + h3 * _3, i3[2] = u3 * f3 + p3 * v3 + d3 * b3, i3[5] = u3 * m3 + p3 * y3 + d3 * w3, i3[8] = u3 * g3 + p3 * x3 + d3 * _3, this;
        }, multiplyScalar: function(t3) {
          var e4 = this.elements;
          return e4[0] *= t3, e4[3] *= t3, e4[6] *= t3, e4[1] *= t3, e4[4] *= t3, e4[7] *= t3, e4[2] *= t3, e4[5] *= t3, e4[8] *= t3, this;
        }, determinant: function() {
          var t3 = this.elements, e4 = t3[0], r3 = t3[1], n2 = t3[2], i3 = t3[3], a3 = t3[4], o5 = t3[5], s4 = t3[6], c3 = t3[7], l4 = t3[8];
          return e4 * a3 * l4 - e4 * o5 * c3 - r3 * i3 * l4 + r3 * o5 * s4 + n2 * i3 * c3 - n2 * a3 * s4;
        }, getInverse: function(t3, e4) {
          t3 && t3.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
          var r3 = t3.elements, n2 = this.elements, i3 = r3[0], a3 = r3[1], o5 = r3[2], s4 = r3[3], c3 = r3[4], l4 = r3[5], h3 = r3[6], u3 = r3[7], p3 = r3[8], d3 = p3 * c3 - l4 * u3, f3 = l4 * h3 - p3 * s4, m3 = u3 * s4 - c3 * h3, g3 = i3 * d3 + a3 * f3 + o5 * m3;
          if (g3 === 0) {
            var v3 = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
            if (e4 === true)
              throw new Error(v3);
            return console.warn(v3), this.identity();
          }
          var y3 = 1 / g3;
          return n2[0] = d3 * y3, n2[1] = (o5 * u3 - p3 * a3) * y3, n2[2] = (l4 * a3 - o5 * c3) * y3, n2[3] = f3 * y3, n2[4] = (p3 * i3 - o5 * h3) * y3, n2[5] = (o5 * s4 - l4 * i3) * y3, n2[6] = m3 * y3, n2[7] = (a3 * h3 - u3 * i3) * y3, n2[8] = (c3 * i3 - a3 * s4) * y3, this;
        }, transpose: function() {
          var t3, e4 = this.elements;
          return t3 = e4[1], e4[1] = e4[3], e4[3] = t3, t3 = e4[2], e4[2] = e4[6], e4[6] = t3, t3 = e4[5], e4[5] = e4[7], e4[7] = t3, this;
        }, getNormalMatrix: function(t3) {
          return this.setFromMatrix4(t3).getInverse(this).transpose();
        }, transposeIntoArray: function(t3) {
          var e4 = this.elements;
          return t3[0] = e4[0], t3[1] = e4[3], t3[2] = e4[6], t3[3] = e4[1], t3[4] = e4[4], t3[5] = e4[7], t3[6] = e4[2], t3[7] = e4[5], t3[8] = e4[8], this;
        }, setUvTransform: function(t3, e4, r3, n2, i3, a3, o5) {
          var s4 = Math.cos(i3), c3 = Math.sin(i3);
          this.set(r3 * s4, r3 * c3, -r3 * (s4 * a3 + c3 * o5) + a3 + t3, -n2 * c3, n2 * s4, -n2 * (-c3 * a3 + s4 * o5) + o5 + e4, 0, 0, 1);
        }, scale: function(t3, e4) {
          var r3 = this.elements;
          return r3[0] *= t3, r3[3] *= t3, r3[6] *= t3, r3[1] *= e4, r3[4] *= e4, r3[7] *= e4, this;
        }, rotate: function(t3) {
          var e4 = Math.cos(t3), r3 = Math.sin(t3), n2 = this.elements, i3 = n2[0], a3 = n2[3], o5 = n2[6], s4 = n2[1], c3 = n2[4], l4 = n2[7];
          return n2[0] = e4 * i3 + r3 * s4, n2[3] = e4 * a3 + r3 * c3, n2[6] = e4 * o5 + r3 * l4, n2[1] = -r3 * i3 + e4 * s4, n2[4] = -r3 * a3 + e4 * c3, n2[7] = -r3 * o5 + e4 * l4, this;
        }, translate: function(t3, e4) {
          var r3 = this.elements;
          return r3[0] += t3 * r3[2], r3[3] += t3 * r3[5], r3[6] += t3 * r3[8], r3[1] += e4 * r3[2], r3[4] += e4 * r3[5], r3[7] += e4 * r3[8], this;
        }, equals: function(t3) {
          for (var e4 = this.elements, r3 = t3.elements, n2 = 0; n2 < 9; n2++)
            if (e4[n2] !== r3[n2])
              return false;
          return true;
        }, fromArray: function(t3, e4) {
          e4 === void 0 && (e4 = 0);
          for (var r3 = 0; r3 < 9; r3++)
            this.elements[r3] = t3[r3 + e4];
          return this;
        }, toArray: function(t3, e4) {
          t3 === void 0 && (t3 = []), e4 === void 0 && (e4 = 0);
          var r3 = this.elements;
          return t3[e4] = r3[0], t3[e4 + 1] = r3[1], t3[e4 + 2] = r3[2], t3[e4 + 3] = r3[3], t3[e4 + 4] = r3[4], t3[e4 + 5] = r3[5], t3[e4 + 6] = r3[6], t3[e4 + 7] = r3[7], t3[e4 + 8] = r3[8], t3;
        } });
        var g2 = { getDataURL: function(t3) {
          return t3.src;
        } }, v2 = 0;
        function y2(t3, e4, r3, n2, i3, a3, o5, c3, h3, u3) {
          Object.defineProperty(this, "id", { value: v2++ }), this.uuid = s3.generateUUID(), this.name = "", this.image = t3 !== void 0 ? t3 : y2.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = e4 !== void 0 ? e4 : y2.DEFAULT_MAPPING, this.wrapS = r3 !== void 0 ? r3 : 1001, this.wrapT = n2 !== void 0 ? n2 : 1001, this.magFilter = i3 !== void 0 ? i3 : 1006, this.minFilter = a3 !== void 0 ? a3 : 1008, this.anisotropy = h3 !== void 0 ? h3 : 1, this.format = o5 !== void 0 ? o5 : 1023, this.type = c3 !== void 0 ? c3 : 1009, this.offset = new l3(0, 0), this.repeat = new l3(1, 1), this.center = new l3(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new m2(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = u3 !== void 0 ? u3 : 3e3, this.version = 0, this.onUpdate = null;
        }
        function x2(t3, e4, r3, n2) {
          this.x = t3 || 0, this.y = e4 || 0, this.z = r3 || 0, this.w = n2 !== void 0 ? n2 : 1;
        }
        function b2(t3, e4, r3) {
          this.width = t3, this.height = e4, this.scissor = new x2(0, 0, t3, e4), this.scissorTest = false, this.viewport = new x2(0, 0, t3, e4), r3 = r3 || {}, this.texture = new y2(void 0, void 0, r3.wrapS, r3.wrapT, r3.magFilter, r3.minFilter, r3.format, r3.type, r3.anisotropy, r3.encoding), this.texture.image = {}, this.texture.image.width = t3, this.texture.image.height = e4, this.texture.generateMipmaps = r3.generateMipmaps !== void 0 && r3.generateMipmaps, this.texture.minFilter = r3.minFilter !== void 0 ? r3.minFilter : 1006, this.depthBuffer = r3.depthBuffer === void 0 || r3.depthBuffer, this.stencilBuffer = r3.stencilBuffer === void 0 || r3.stencilBuffer, this.depthTexture = r3.depthTexture !== void 0 ? r3.depthTexture : null;
        }
        function w2(t3, e4, r3) {
          b2.call(this, t3, e4, r3), this.samples = 4;
        }
        y2.DEFAULT_IMAGE = void 0, y2.DEFAULT_MAPPING = 300, y2.prototype = Object.assign(Object.create(e3.prototype), { constructor: y2, isTexture: true, updateMatrix: function() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          return this.name = t3.name, this.image = t3.image, this.mipmaps = t3.mipmaps.slice(0), this.mapping = t3.mapping, this.wrapS = t3.wrapS, this.wrapT = t3.wrapT, this.magFilter = t3.magFilter, this.minFilter = t3.minFilter, this.anisotropy = t3.anisotropy, this.format = t3.format, this.type = t3.type, this.offset.copy(t3.offset), this.repeat.copy(t3.repeat), this.center.copy(t3.center), this.rotation = t3.rotation, this.matrixAutoUpdate = t3.matrixAutoUpdate, this.matrix.copy(t3.matrix), this.generateMipmaps = t3.generateMipmaps, this.premultiplyAlpha = t3.premultiplyAlpha, this.flipY = t3.flipY, this.unpackAlignment = t3.unpackAlignment, this.encoding = t3.encoding, this;
        }, toJSON: function(t3) {
          var e4 = t3 === void 0 || typeof t3 == "string";
          if (!e4 && t3.textures[this.uuid] !== void 0)
            return t3.textures[this.uuid];
          var r3 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
          if (this.image !== void 0) {
            var n2 = this.image;
            if (n2.uuid === void 0 && (n2.uuid = s3.generateUUID()), !e4 && t3.images[n2.uuid] === void 0) {
              var i3;
              if (Array.isArray(n2)) {
                i3 = [];
                for (var a3 = 0, o5 = n2.length; a3 < o5; a3++)
                  i3.push(g2.getDataURL(n2[a3]));
              } else
                i3 = g2.getDataURL(n2);
              t3.images[n2.uuid] = { uuid: n2.uuid, url: i3 };
            }
            r3.image = n2.uuid;
          }
          return e4 || (t3.textures[this.uuid] = r3), r3;
        }, dispose: function() {
          this.dispatchEvent({ type: "dispose" });
        }, transformUv: function(t3) {
          if (this.mapping !== 300)
            return t3;
          if (t3.applyMatrix3(this.matrix), t3.x < 0 || t3.x > 1)
            switch (this.wrapS) {
              case 1e3:
                t3.x = t3.x - Math.floor(t3.x);
                break;
              case 1001:
                t3.x = t3.x < 0 ? 0 : 1;
                break;
              case 1002:
                Math.abs(Math.floor(t3.x) % 2) === 1 ? t3.x = Math.ceil(t3.x) - t3.x : t3.x = t3.x - Math.floor(t3.x);
            }
          if (t3.y < 0 || t3.y > 1)
            switch (this.wrapT) {
              case 1e3:
                t3.y = t3.y - Math.floor(t3.y);
                break;
              case 1001:
                t3.y = t3.y < 0 ? 0 : 1;
                break;
              case 1002:
                Math.abs(Math.floor(t3.y) % 2) === 1 ? t3.y = Math.ceil(t3.y) - t3.y : t3.y = t3.y - Math.floor(t3.y);
            }
          return this.flipY && (t3.y = 1 - t3.y), t3;
        } }), Object.defineProperty(y2.prototype, "needsUpdate", { set: function(t3) {
          t3 === true && this.version++;
        } }), Object.defineProperties(x2.prototype, { width: { get: function() {
          return this.z;
        }, set: function(t3) {
          this.z = t3;
        } }, height: { get: function() {
          return this.w;
        }, set: function(t3) {
          this.w = t3;
        } } }), Object.assign(x2.prototype, { isVector4: true, set: function(t3, e4, r3, n2) {
          return this.x = t3, this.y = e4, this.z = r3, this.w = n2, this;
        }, setScalar: function(t3) {
          return this.x = t3, this.y = t3, this.z = t3, this.w = t3, this;
        }, setX: function(t3) {
          return this.x = t3, this;
        }, setY: function(t3) {
          return this.y = t3, this;
        }, setZ: function(t3) {
          return this.z = t3, this;
        }, setW: function(t3) {
          return this.w = t3, this;
        }, setComponent: function(t3, e4) {
          switch (t3) {
            case 0:
              this.x = e4;
              break;
            case 1:
              this.y = e4;
              break;
            case 2:
              this.z = e4;
              break;
            case 3:
              this.w = e4;
              break;
            default:
              throw new Error("index is out of range: " + t3);
          }
          return this;
        }, getComponent: function(t3) {
          switch (t3) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t3);
          }
        }, clone: function() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }, copy: function(t3) {
          return this.x = t3.x, this.y = t3.y, this.z = t3.z, this.w = t3.w !== void 0 ? t3.w : 1, this;
        }, add: function(t3, e4) {
          return e4 !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t3, e4)) : (this.x += t3.x, this.y += t3.y, this.z += t3.z, this.w += t3.w, this);
        }, addScalar: function(t3) {
          return this.x += t3, this.y += t3, this.z += t3, this.w += t3, this;
        }, addVectors: function(t3, e4) {
          return this.x = t3.x + e4.x, this.y = t3.y + e4.y, this.z = t3.z + e4.z, this.w = t3.w + e4.w, this;
        }, addScaledVector: function(t3, e4) {
          return this.x += t3.x * e4, this.y += t3.y * e4, this.z += t3.z * e4, this.w += t3.w * e4, this;
        }, sub: function(t3, e4) {
          return e4 !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t3, e4)) : (this.x -= t3.x, this.y -= t3.y, this.z -= t3.z, this.w -= t3.w, this);
        }, subScalar: function(t3) {
          return this.x -= t3, this.y -= t3, this.z -= t3, this.w -= t3, this;
        }, subVectors: function(t3, e4) {
          return this.x = t3.x - e4.x, this.y = t3.y - e4.y, this.z = t3.z - e4.z, this.w = t3.w - e4.w, this;
        }, multiplyScalar: function(t3) {
          return this.x *= t3, this.y *= t3, this.z *= t3, this.w *= t3, this;
        }, applyMatrix4: function(t3) {
          var e4 = this.x, r3 = this.y, n2 = this.z, i3 = this.w, a3 = t3.elements;
          return this.x = a3[0] * e4 + a3[4] * r3 + a3[8] * n2 + a3[12] * i3, this.y = a3[1] * e4 + a3[5] * r3 + a3[9] * n2 + a3[13] * i3, this.z = a3[2] * e4 + a3[6] * r3 + a3[10] * n2 + a3[14] * i3, this.w = a3[3] * e4 + a3[7] * r3 + a3[11] * n2 + a3[15] * i3, this;
        }, divideScalar: function(t3) {
          return this.multiplyScalar(1 / t3);
        }, setAxisAngleFromQuaternion: function(t3) {
          this.w = 2 * Math.acos(t3.w);
          var e4 = Math.sqrt(1 - t3.w * t3.w);
          return e4 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t3.x / e4, this.y = t3.y / e4, this.z = t3.z / e4), this;
        }, setAxisAngleFromRotationMatrix: function(t3) {
          var e4, r3, n2, i3, a3 = t3.elements, o5 = a3[0], s4 = a3[4], c3 = a3[8], l4 = a3[1], h3 = a3[5], u3 = a3[9], p3 = a3[2], d3 = a3[6], f3 = a3[10];
          if (Math.abs(s4 - l4) < 0.01 && Math.abs(c3 - p3) < 0.01 && Math.abs(u3 - d3) < 0.01) {
            if (Math.abs(s4 + l4) < 0.1 && Math.abs(c3 + p3) < 0.1 && Math.abs(u3 + d3) < 0.1 && Math.abs(o5 + h3 + f3 - 3) < 0.1)
              return this.set(1, 0, 0, 0), this;
            e4 = Math.PI;
            var m3 = (o5 + 1) / 2, g3 = (h3 + 1) / 2, v3 = (f3 + 1) / 2, y3 = (s4 + l4) / 4, x3 = (c3 + p3) / 4, b3 = (u3 + d3) / 4;
            return m3 > g3 && m3 > v3 ? m3 < 0.01 ? (r3 = 0, n2 = 0.707106781, i3 = 0.707106781) : (n2 = y3 / (r3 = Math.sqrt(m3)), i3 = x3 / r3) : g3 > v3 ? g3 < 0.01 ? (r3 = 0.707106781, n2 = 0, i3 = 0.707106781) : (r3 = y3 / (n2 = Math.sqrt(g3)), i3 = b3 / n2) : v3 < 0.01 ? (r3 = 0.707106781, n2 = 0.707106781, i3 = 0) : (r3 = x3 / (i3 = Math.sqrt(v3)), n2 = b3 / i3), this.set(r3, n2, i3, e4), this;
          }
          var w3 = Math.sqrt((d3 - u3) * (d3 - u3) + (c3 - p3) * (c3 - p3) + (l4 - s4) * (l4 - s4));
          return Math.abs(w3) < 1e-3 && (w3 = 1), this.x = (d3 - u3) / w3, this.y = (c3 - p3) / w3, this.z = (l4 - s4) / w3, this.w = Math.acos((o5 + h3 + f3 - 1) / 2), this;
        }, min: function(t3) {
          return this.x = Math.min(this.x, t3.x), this.y = Math.min(this.y, t3.y), this.z = Math.min(this.z, t3.z), this.w = Math.min(this.w, t3.w), this;
        }, max: function(t3) {
          return this.x = Math.max(this.x, t3.x), this.y = Math.max(this.y, t3.y), this.z = Math.max(this.z, t3.z), this.w = Math.max(this.w, t3.w), this;
        }, clamp: function(t3, e4) {
          return this.x = Math.max(t3.x, Math.min(e4.x, this.x)), this.y = Math.max(t3.y, Math.min(e4.y, this.y)), this.z = Math.max(t3.z, Math.min(e4.z, this.z)), this.w = Math.max(t3.w, Math.min(e4.w, this.w)), this;
        }, clampScalar: function(t3, e4) {
          return this.x = Math.max(t3, Math.min(e4, this.x)), this.y = Math.max(t3, Math.min(e4, this.y)), this.z = Math.max(t3, Math.min(e4, this.z)), this.w = Math.max(t3, Math.min(e4, this.w)), this;
        }, clampLength: function(t3, e4) {
          var r3 = this.length();
          return this.divideScalar(r3 || 1).multiplyScalar(Math.max(t3, Math.min(e4, r3)));
        }, floor: function() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }, ceil: function() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }, round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }, roundToZero: function() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
        }, negate: function() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }, dot: function(t3) {
          return this.x * t3.x + this.y * t3.y + this.z * t3.z + this.w * t3.w;
        }, lengthSq: function() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }, length: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }, manhattanLength: function() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }, normalize: function() {
          return this.divideScalar(this.length() || 1);
        }, setLength: function(t3) {
          return this.normalize().multiplyScalar(t3);
        }, lerp: function(t3, e4) {
          return this.x += (t3.x - this.x) * e4, this.y += (t3.y - this.y) * e4, this.z += (t3.z - this.z) * e4, this.w += (t3.w - this.w) * e4, this;
        }, lerpVectors: function(t3, e4, r3) {
          return this.subVectors(e4, t3).multiplyScalar(r3).add(t3);
        }, equals: function(t3) {
          return t3.x === this.x && t3.y === this.y && t3.z === this.z && t3.w === this.w;
        }, fromArray: function(t3, e4) {
          return e4 === void 0 && (e4 = 0), this.x = t3[e4], this.y = t3[e4 + 1], this.z = t3[e4 + 2], this.w = t3[e4 + 3], this;
        }, toArray: function(t3, e4) {
          return t3 === void 0 && (t3 = []), e4 === void 0 && (e4 = 0), t3[e4] = this.x, t3[e4 + 1] = this.y, t3[e4 + 2] = this.z, t3[e4 + 3] = this.w, t3;
        }, fromBufferAttribute: function(t3, e4, r3) {
          return r3 !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t3.getX(e4), this.y = t3.getY(e4), this.z = t3.getZ(e4), this.w = t3.getW(e4), this;
        } }), b2.prototype = Object.assign(Object.create(e3.prototype), { constructor: b2, isWebGLRenderTarget: true, setSize: function(t3, e4) {
          this.width === t3 && this.height === e4 || (this.width = t3, this.height = e4, this.texture.image.width = t3, this.texture.image.height = e4, this.dispose()), this.viewport.set(0, 0, t3, e4), this.scissor.set(0, 0, t3, e4);
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          return this.width = t3.width, this.height = t3.height, this.viewport.copy(t3.viewport), this.texture = t3.texture.clone(), this.depthBuffer = t3.depthBuffer, this.stencilBuffer = t3.stencilBuffer, this.depthTexture = t3.depthTexture, this;
        }, dispose: function() {
          this.dispatchEvent({ type: "dispose" });
        } }), w2.prototype = Object.assign(Object.create(b2.prototype), { constructor: w2, isWebGLMultisampleRenderTarget: true, copy: function(t3) {
          return b2.prototype.copy.call(this, t3), this.samples = t3.samples, this;
        } });
        var _2 = new d2(), M2 = new P2(), S2 = new d2(0, 0, 0), T2 = new d2(1, 1, 1), E3 = new d2(), A2 = new d2(), L2 = new d2();
        function P2() {
          this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
        }
        Object.assign(P2.prototype, { isMatrix4: true, set: function(t3, e4, r3, n2, i3, a3, o5, s4, c3, l4, h3, u3, p3, d3, f3, m3) {
          var g3 = this.elements;
          return g3[0] = t3, g3[4] = e4, g3[8] = r3, g3[12] = n2, g3[1] = i3, g3[5] = a3, g3[9] = o5, g3[13] = s4, g3[2] = c3, g3[6] = l4, g3[10] = h3, g3[14] = u3, g3[3] = p3, g3[7] = d3, g3[11] = f3, g3[15] = m3, this;
        }, identity: function() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }, clone: function() {
          return new P2().fromArray(this.elements);
        }, copy: function(t3) {
          var e4 = this.elements, r3 = t3.elements;
          return e4[0] = r3[0], e4[1] = r3[1], e4[2] = r3[2], e4[3] = r3[3], e4[4] = r3[4], e4[5] = r3[5], e4[6] = r3[6], e4[7] = r3[7], e4[8] = r3[8], e4[9] = r3[9], e4[10] = r3[10], e4[11] = r3[11], e4[12] = r3[12], e4[13] = r3[13], e4[14] = r3[14], e4[15] = r3[15], this;
        }, copyPosition: function(t3) {
          var e4 = this.elements, r3 = t3.elements;
          return e4[12] = r3[12], e4[13] = r3[13], e4[14] = r3[14], this;
        }, extractBasis: function(t3, e4, r3) {
          return t3.setFromMatrixColumn(this, 0), e4.setFromMatrixColumn(this, 1), r3.setFromMatrixColumn(this, 2), this;
        }, makeBasis: function(t3, e4, r3) {
          return this.set(t3.x, e4.x, r3.x, 0, t3.y, e4.y, r3.y, 0, t3.z, e4.z, r3.z, 0, 0, 0, 0, 1), this;
        }, extractRotation: function(t3) {
          var e4 = this.elements, r3 = t3.elements, n2 = 1 / _2.setFromMatrixColumn(t3, 0).length(), i3 = 1 / _2.setFromMatrixColumn(t3, 1).length(), a3 = 1 / _2.setFromMatrixColumn(t3, 2).length();
          return e4[0] = r3[0] * n2, e4[1] = r3[1] * n2, e4[2] = r3[2] * n2, e4[3] = 0, e4[4] = r3[4] * i3, e4[5] = r3[5] * i3, e4[6] = r3[6] * i3, e4[7] = 0, e4[8] = r3[8] * a3, e4[9] = r3[9] * a3, e4[10] = r3[10] * a3, e4[11] = 0, e4[12] = 0, e4[13] = 0, e4[14] = 0, e4[15] = 1, this;
        }, makeRotationFromEuler: function(t3) {
          t3 && t3.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
          var e4 = this.elements, r3 = t3.x, n2 = t3.y, i3 = t3.z, a3 = Math.cos(r3), o5 = Math.sin(r3), s4 = Math.cos(n2), c3 = Math.sin(n2), l4 = Math.cos(i3), h3 = Math.sin(i3);
          if (t3.order === "XYZ") {
            var u3 = a3 * l4, p3 = a3 * h3, d3 = o5 * l4, f3 = o5 * h3;
            e4[0] = s4 * l4, e4[4] = -s4 * h3, e4[8] = c3, e4[1] = p3 + d3 * c3, e4[5] = u3 - f3 * c3, e4[9] = -o5 * s4, e4[2] = f3 - u3 * c3, e4[6] = d3 + p3 * c3, e4[10] = a3 * s4;
          } else if (t3.order === "YXZ") {
            var m3 = s4 * l4, g3 = s4 * h3, v3 = c3 * l4, y3 = c3 * h3;
            e4[0] = m3 + y3 * o5, e4[4] = v3 * o5 - g3, e4[8] = a3 * c3, e4[1] = a3 * h3, e4[5] = a3 * l4, e4[9] = -o5, e4[2] = g3 * o5 - v3, e4[6] = y3 + m3 * o5, e4[10] = a3 * s4;
          } else if (t3.order === "ZXY")
            m3 = s4 * l4, g3 = s4 * h3, v3 = c3 * l4, y3 = c3 * h3, e4[0] = m3 - y3 * o5, e4[4] = -a3 * h3, e4[8] = v3 + g3 * o5, e4[1] = g3 + v3 * o5, e4[5] = a3 * l4, e4[9] = y3 - m3 * o5, e4[2] = -a3 * c3, e4[6] = o5, e4[10] = a3 * s4;
          else if (t3.order === "ZYX")
            u3 = a3 * l4, p3 = a3 * h3, d3 = o5 * l4, f3 = o5 * h3, e4[0] = s4 * l4, e4[4] = d3 * c3 - p3, e4[8] = u3 * c3 + f3, e4[1] = s4 * h3, e4[5] = f3 * c3 + u3, e4[9] = p3 * c3 - d3, e4[2] = -c3, e4[6] = o5 * s4, e4[10] = a3 * s4;
          else if (t3.order === "YZX") {
            var x3 = a3 * s4, b3 = a3 * c3, w3 = o5 * s4, _3 = o5 * c3;
            e4[0] = s4 * l4, e4[4] = _3 - x3 * h3, e4[8] = w3 * h3 + b3, e4[1] = h3, e4[5] = a3 * l4, e4[9] = -o5 * l4, e4[2] = -c3 * l4, e4[6] = b3 * h3 + w3, e4[10] = x3 - _3 * h3;
          } else
            t3.order === "XZY" && (x3 = a3 * s4, b3 = a3 * c3, w3 = o5 * s4, _3 = o5 * c3, e4[0] = s4 * l4, e4[4] = -h3, e4[8] = c3 * l4, e4[1] = x3 * h3 + _3, e4[5] = a3 * l4, e4[9] = b3 * h3 - w3, e4[2] = w3 * h3 - b3, e4[6] = o5 * l4, e4[10] = _3 * h3 + x3);
          return e4[3] = 0, e4[7] = 0, e4[11] = 0, e4[12] = 0, e4[13] = 0, e4[14] = 0, e4[15] = 1, this;
        }, makeRotationFromQuaternion: function(t3) {
          return this.compose(S2, t3, T2);
        }, lookAt: function(t3, e4, r3) {
          var n2 = this.elements;
          return L2.subVectors(t3, e4), L2.lengthSq() === 0 && (L2.z = 1), L2.normalize(), E3.crossVectors(r3, L2), E3.lengthSq() === 0 && (Math.abs(r3.z) === 1 ? L2.x += 1e-4 : L2.z += 1e-4, L2.normalize(), E3.crossVectors(r3, L2)), E3.normalize(), A2.crossVectors(L2, E3), n2[0] = E3.x, n2[4] = A2.x, n2[8] = L2.x, n2[1] = E3.y, n2[5] = A2.y, n2[9] = L2.y, n2[2] = E3.z, n2[6] = A2.z, n2[10] = L2.z, this;
        }, multiply: function(t3, e4) {
          return e4 !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t3, e4)) : this.multiplyMatrices(this, t3);
        }, premultiply: function(t3) {
          return this.multiplyMatrices(t3, this);
        }, multiplyMatrices: function(t3, e4) {
          var r3 = t3.elements, n2 = e4.elements, i3 = this.elements, a3 = r3[0], o5 = r3[4], s4 = r3[8], c3 = r3[12], l4 = r3[1], h3 = r3[5], u3 = r3[9], p3 = r3[13], d3 = r3[2], f3 = r3[6], m3 = r3[10], g3 = r3[14], v3 = r3[3], y3 = r3[7], x3 = r3[11], b3 = r3[15], w3 = n2[0], _3 = n2[4], M3 = n2[8], S3 = n2[12], T3 = n2[1], E4 = n2[5], A3 = n2[9], L3 = n2[13], R2 = n2[2], P3 = n2[6], C2 = n2[10], O2 = n2[14], D2 = n2[3], N2 = n2[7], I2 = n2[11], z2 = n2[15];
          return i3[0] = a3 * w3 + o5 * T3 + s4 * R2 + c3 * D2, i3[4] = a3 * _3 + o5 * E4 + s4 * P3 + c3 * N2, i3[8] = a3 * M3 + o5 * A3 + s4 * C2 + c3 * I2, i3[12] = a3 * S3 + o5 * L3 + s4 * O2 + c3 * z2, i3[1] = l4 * w3 + h3 * T3 + u3 * R2 + p3 * D2, i3[5] = l4 * _3 + h3 * E4 + u3 * P3 + p3 * N2, i3[9] = l4 * M3 + h3 * A3 + u3 * C2 + p3 * I2, i3[13] = l4 * S3 + h3 * L3 + u3 * O2 + p3 * z2, i3[2] = d3 * w3 + f3 * T3 + m3 * R2 + g3 * D2, i3[6] = d3 * _3 + f3 * E4 + m3 * P3 + g3 * N2, i3[10] = d3 * M3 + f3 * A3 + m3 * C2 + g3 * I2, i3[14] = d3 * S3 + f3 * L3 + m3 * O2 + g3 * z2, i3[3] = v3 * w3 + y3 * T3 + x3 * R2 + b3 * D2, i3[7] = v3 * _3 + y3 * E4 + x3 * P3 + b3 * N2, i3[11] = v3 * M3 + y3 * A3 + x3 * C2 + b3 * I2, i3[15] = v3 * S3 + y3 * L3 + x3 * O2 + b3 * z2, this;
        }, multiplyScalar: function(t3) {
          var e4 = this.elements;
          return e4[0] *= t3, e4[4] *= t3, e4[8] *= t3, e4[12] *= t3, e4[1] *= t3, e4[5] *= t3, e4[9] *= t3, e4[13] *= t3, e4[2] *= t3, e4[6] *= t3, e4[10] *= t3, e4[14] *= t3, e4[3] *= t3, e4[7] *= t3, e4[11] *= t3, e4[15] *= t3, this;
        }, applyToBufferAttribute: function(t3) {
          for (var e4 = 0, r3 = t3.count; e4 < r3; e4++)
            _2.x = t3.getX(e4), _2.y = t3.getY(e4), _2.z = t3.getZ(e4), _2.applyMatrix4(this), t3.setXYZ(e4, _2.x, _2.y, _2.z);
          return t3;
        }, determinant: function() {
          var t3 = this.elements, e4 = t3[0], r3 = t3[4], n2 = t3[8], i3 = t3[12], a3 = t3[1], o5 = t3[5], s4 = t3[9], c3 = t3[13], l4 = t3[2], h3 = t3[6], u3 = t3[10], p3 = t3[14];
          return t3[3] * (+i3 * s4 * h3 - n2 * c3 * h3 - i3 * o5 * u3 + r3 * c3 * u3 + n2 * o5 * p3 - r3 * s4 * p3) + t3[7] * (+e4 * s4 * p3 - e4 * c3 * u3 + i3 * a3 * u3 - n2 * a3 * p3 + n2 * c3 * l4 - i3 * s4 * l4) + t3[11] * (+e4 * c3 * h3 - e4 * o5 * p3 - i3 * a3 * h3 + r3 * a3 * p3 + i3 * o5 * l4 - r3 * c3 * l4) + t3[15] * (-n2 * o5 * l4 - e4 * s4 * h3 + e4 * o5 * u3 + n2 * a3 * h3 - r3 * a3 * u3 + r3 * s4 * l4);
        }, transpose: function() {
          var t3, e4 = this.elements;
          return t3 = e4[1], e4[1] = e4[4], e4[4] = t3, t3 = e4[2], e4[2] = e4[8], e4[8] = t3, t3 = e4[6], e4[6] = e4[9], e4[9] = t3, t3 = e4[3], e4[3] = e4[12], e4[12] = t3, t3 = e4[7], e4[7] = e4[13], e4[13] = t3, t3 = e4[11], e4[11] = e4[14], e4[14] = t3, this;
        }, setPosition: function(t3, e4, r3) {
          var n2 = this.elements;
          return t3.isVector3 ? (n2[12] = t3.x, n2[13] = t3.y, n2[14] = t3.z) : (n2[12] = t3, n2[13] = e4, n2[14] = r3), this;
        }, getInverse: function(t3, e4) {
          var r3 = this.elements, n2 = t3.elements, i3 = n2[0], a3 = n2[1], o5 = n2[2], s4 = n2[3], c3 = n2[4], l4 = n2[5], h3 = n2[6], u3 = n2[7], p3 = n2[8], d3 = n2[9], f3 = n2[10], m3 = n2[11], g3 = n2[12], v3 = n2[13], y3 = n2[14], x3 = n2[15], b3 = d3 * y3 * u3 - v3 * f3 * u3 + v3 * h3 * m3 - l4 * y3 * m3 - d3 * h3 * x3 + l4 * f3 * x3, w3 = g3 * f3 * u3 - p3 * y3 * u3 - g3 * h3 * m3 + c3 * y3 * m3 + p3 * h3 * x3 - c3 * f3 * x3, _3 = p3 * v3 * u3 - g3 * d3 * u3 + g3 * l4 * m3 - c3 * v3 * m3 - p3 * l4 * x3 + c3 * d3 * x3, M3 = g3 * d3 * h3 - p3 * v3 * h3 - g3 * l4 * f3 + c3 * v3 * f3 + p3 * l4 * y3 - c3 * d3 * y3, S3 = i3 * b3 + a3 * w3 + o5 * _3 + s4 * M3;
          if (S3 === 0) {
            var T3 = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
            if (e4 === true)
              throw new Error(T3);
            return console.warn(T3), this.identity();
          }
          var E4 = 1 / S3;
          return r3[0] = b3 * E4, r3[1] = (v3 * f3 * s4 - d3 * y3 * s4 - v3 * o5 * m3 + a3 * y3 * m3 + d3 * o5 * x3 - a3 * f3 * x3) * E4, r3[2] = (l4 * y3 * s4 - v3 * h3 * s4 + v3 * o5 * u3 - a3 * y3 * u3 - l4 * o5 * x3 + a3 * h3 * x3) * E4, r3[3] = (d3 * h3 * s4 - l4 * f3 * s4 - d3 * o5 * u3 + a3 * f3 * u3 + l4 * o5 * m3 - a3 * h3 * m3) * E4, r3[4] = w3 * E4, r3[5] = (p3 * y3 * s4 - g3 * f3 * s4 + g3 * o5 * m3 - i3 * y3 * m3 - p3 * o5 * x3 + i3 * f3 * x3) * E4, r3[6] = (g3 * h3 * s4 - c3 * y3 * s4 - g3 * o5 * u3 + i3 * y3 * u3 + c3 * o5 * x3 - i3 * h3 * x3) * E4, r3[7] = (c3 * f3 * s4 - p3 * h3 * s4 + p3 * o5 * u3 - i3 * f3 * u3 - c3 * o5 * m3 + i3 * h3 * m3) * E4, r3[8] = _3 * E4, r3[9] = (g3 * d3 * s4 - p3 * v3 * s4 - g3 * a3 * m3 + i3 * v3 * m3 + p3 * a3 * x3 - i3 * d3 * x3) * E4, r3[10] = (c3 * v3 * s4 - g3 * l4 * s4 + g3 * a3 * u3 - i3 * v3 * u3 - c3 * a3 * x3 + i3 * l4 * x3) * E4, r3[11] = (p3 * l4 * s4 - c3 * d3 * s4 - p3 * a3 * u3 + i3 * d3 * u3 + c3 * a3 * m3 - i3 * l4 * m3) * E4, r3[12] = M3 * E4, r3[13] = (p3 * v3 * o5 - g3 * d3 * o5 + g3 * a3 * f3 - i3 * v3 * f3 - p3 * a3 * y3 + i3 * d3 * y3) * E4, r3[14] = (g3 * l4 * o5 - c3 * v3 * o5 - g3 * a3 * h3 + i3 * v3 * h3 + c3 * a3 * y3 - i3 * l4 * y3) * E4, r3[15] = (c3 * d3 * o5 - p3 * l4 * o5 + p3 * a3 * h3 - i3 * d3 * h3 - c3 * a3 * f3 + i3 * l4 * f3) * E4, this;
        }, scale: function(t3) {
          var e4 = this.elements, r3 = t3.x, n2 = t3.y, i3 = t3.z;
          return e4[0] *= r3, e4[4] *= n2, e4[8] *= i3, e4[1] *= r3, e4[5] *= n2, e4[9] *= i3, e4[2] *= r3, e4[6] *= n2, e4[10] *= i3, e4[3] *= r3, e4[7] *= n2, e4[11] *= i3, this;
        }, getMaxScaleOnAxis: function() {
          var t3 = this.elements, e4 = t3[0] * t3[0] + t3[1] * t3[1] + t3[2] * t3[2], r3 = t3[4] * t3[4] + t3[5] * t3[5] + t3[6] * t3[6], n2 = t3[8] * t3[8] + t3[9] * t3[9] + t3[10] * t3[10];
          return Math.sqrt(Math.max(e4, r3, n2));
        }, makeTranslation: function(t3, e4, r3) {
          return this.set(1, 0, 0, t3, 0, 1, 0, e4, 0, 0, 1, r3, 0, 0, 0, 1), this;
        }, makeRotationX: function(t3) {
          var e4 = Math.cos(t3), r3 = Math.sin(t3);
          return this.set(1, 0, 0, 0, 0, e4, -r3, 0, 0, r3, e4, 0, 0, 0, 0, 1), this;
        }, makeRotationY: function(t3) {
          var e4 = Math.cos(t3), r3 = Math.sin(t3);
          return this.set(e4, 0, r3, 0, 0, 1, 0, 0, -r3, 0, e4, 0, 0, 0, 0, 1), this;
        }, makeRotationZ: function(t3) {
          var e4 = Math.cos(t3), r3 = Math.sin(t3);
          return this.set(e4, -r3, 0, 0, r3, e4, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }, makeRotationAxis: function(t3, e4) {
          var r3 = Math.cos(e4), n2 = Math.sin(e4), i3 = 1 - r3, a3 = t3.x, o5 = t3.y, s4 = t3.z, c3 = i3 * a3, l4 = i3 * o5;
          return this.set(c3 * a3 + r3, c3 * o5 - n2 * s4, c3 * s4 + n2 * o5, 0, c3 * o5 + n2 * s4, l4 * o5 + r3, l4 * s4 - n2 * a3, 0, c3 * s4 - n2 * o5, l4 * s4 + n2 * a3, i3 * s4 * s4 + r3, 0, 0, 0, 0, 1), this;
        }, makeScale: function(t3, e4, r3) {
          return this.set(t3, 0, 0, 0, 0, e4, 0, 0, 0, 0, r3, 0, 0, 0, 0, 1), this;
        }, makeShear: function(t3, e4, r3) {
          return this.set(1, e4, r3, 0, t3, 1, r3, 0, t3, e4, 1, 0, 0, 0, 0, 1), this;
        }, compose: function(t3, e4, r3) {
          var n2 = this.elements, i3 = e4._x, a3 = e4._y, o5 = e4._z, s4 = e4._w, c3 = i3 + i3, l4 = a3 + a3, h3 = o5 + o5, u3 = i3 * c3, p3 = i3 * l4, d3 = i3 * h3, f3 = a3 * l4, m3 = a3 * h3, g3 = o5 * h3, v3 = s4 * c3, y3 = s4 * l4, x3 = s4 * h3, b3 = r3.x, w3 = r3.y, _3 = r3.z;
          return n2[0] = (1 - (f3 + g3)) * b3, n2[1] = (p3 + x3) * b3, n2[2] = (d3 - y3) * b3, n2[3] = 0, n2[4] = (p3 - x3) * w3, n2[5] = (1 - (u3 + g3)) * w3, n2[6] = (m3 + v3) * w3, n2[7] = 0, n2[8] = (d3 + y3) * _3, n2[9] = (m3 - v3) * _3, n2[10] = (1 - (u3 + f3)) * _3, n2[11] = 0, n2[12] = t3.x, n2[13] = t3.y, n2[14] = t3.z, n2[15] = 1, this;
        }, decompose: function(t3, e4, r3) {
          var n2 = this.elements, i3 = _2.set(n2[0], n2[1], n2[2]).length(), a3 = _2.set(n2[4], n2[5], n2[6]).length(), o5 = _2.set(n2[8], n2[9], n2[10]).length();
          this.determinant() < 0 && (i3 = -i3), t3.x = n2[12], t3.y = n2[13], t3.z = n2[14], M2.copy(this);
          var s4 = 1 / i3, c3 = 1 / a3, l4 = 1 / o5;
          return M2.elements[0] *= s4, M2.elements[1] *= s4, M2.elements[2] *= s4, M2.elements[4] *= c3, M2.elements[5] *= c3, M2.elements[6] *= c3, M2.elements[8] *= l4, M2.elements[9] *= l4, M2.elements[10] *= l4, e4.setFromRotationMatrix(M2), r3.x = i3, r3.y = a3, r3.z = o5, this;
        }, makePerspective: function(t3, e4, r3, n2, i3, a3) {
          a3 === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
          var o5 = this.elements, s4 = 2 * i3 / (e4 - t3), c3 = 2 * i3 / (r3 - n2), l4 = (e4 + t3) / (e4 - t3), h3 = (r3 + n2) / (r3 - n2), u3 = -(a3 + i3) / (a3 - i3), p3 = -2 * a3 * i3 / (a3 - i3);
          return o5[0] = s4, o5[4] = 0, o5[8] = l4, o5[12] = 0, o5[1] = 0, o5[5] = c3, o5[9] = h3, o5[13] = 0, o5[2] = 0, o5[6] = 0, o5[10] = u3, o5[14] = p3, o5[3] = 0, o5[7] = 0, o5[11] = -1, o5[15] = 0, this;
        }, makeOrthographic: function(t3, e4, r3, n2, i3, a3) {
          var o5 = this.elements, s4 = 1 / (e4 - t3), c3 = 1 / (r3 - n2), l4 = 1 / (a3 - i3), h3 = (e4 + t3) * s4, u3 = (r3 + n2) * c3, p3 = (a3 + i3) * l4;
          return o5[0] = 2 * s4, o5[4] = 0, o5[8] = 0, o5[12] = -h3, o5[1] = 0, o5[5] = 2 * c3, o5[9] = 0, o5[13] = -u3, o5[2] = 0, o5[6] = 0, o5[10] = -2 * l4, o5[14] = -p3, o5[3] = 0, o5[7] = 0, o5[11] = 0, o5[15] = 1, this;
        }, equals: function(t3) {
          for (var e4 = this.elements, r3 = t3.elements, n2 = 0; n2 < 16; n2++)
            if (e4[n2] !== r3[n2])
              return false;
          return true;
        }, fromArray: function(t3, e4) {
          e4 === void 0 && (e4 = 0);
          for (var r3 = 0; r3 < 16; r3++)
            this.elements[r3] = t3[r3 + e4];
          return this;
        }, toArray: function(t3, e4) {
          t3 === void 0 && (t3 = []), e4 === void 0 && (e4 = 0);
          var r3 = this.elements;
          return t3[e4] = r3[0], t3[e4 + 1] = r3[1], t3[e4 + 2] = r3[2], t3[e4 + 3] = r3[3], t3[e4 + 4] = r3[4], t3[e4 + 5] = r3[5], t3[e4 + 6] = r3[6], t3[e4 + 7] = r3[7], t3[e4 + 8] = r3[8], t3[e4 + 9] = r3[9], t3[e4 + 10] = r3[10], t3[e4 + 11] = r3[11], t3[e4 + 12] = r3[12], t3[e4 + 13] = r3[13], t3[e4 + 14] = r3[14], t3[e4 + 15] = r3[15], t3;
        } });
        var C = new P2(), O = new h2();
        function D(t3, e4, r3, n2) {
          this._x = t3 || 0, this._y = e4 || 0, this._z = r3 || 0, this._order = n2 || D.DefaultOrder;
        }
        function N() {
          this.mask = 1;
        }
        D.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], D.DefaultOrder = "XYZ", Object.defineProperties(D.prototype, { x: { get: function() {
          return this._x;
        }, set: function(t3) {
          this._x = t3, this._onChangeCallback();
        } }, y: { get: function() {
          return this._y;
        }, set: function(t3) {
          this._y = t3, this._onChangeCallback();
        } }, z: { get: function() {
          return this._z;
        }, set: function(t3) {
          this._z = t3, this._onChangeCallback();
        } }, order: { get: function() {
          return this._order;
        }, set: function(t3) {
          this._order = t3, this._onChangeCallback();
        } } }), Object.assign(D.prototype, { isEuler: true, set: function(t3, e4, r3, n2) {
          return this._x = t3, this._y = e4, this._z = r3, this._order = n2 || this._order, this._onChangeCallback(), this;
        }, clone: function() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }, copy: function(t3) {
          return this._x = t3._x, this._y = t3._y, this._z = t3._z, this._order = t3._order, this._onChangeCallback(), this;
        }, setFromRotationMatrix: function(t3, e4, r3) {
          var n2 = s3.clamp, i3 = t3.elements, a3 = i3[0], o5 = i3[4], c3 = i3[8], l4 = i3[1], h3 = i3[5], u3 = i3[9], p3 = i3[2], d3 = i3[6], f3 = i3[10];
          return (e4 = e4 || this._order) === "XYZ" ? (this._y = Math.asin(n2(c3, -1, 1)), Math.abs(c3) < 0.9999999 ? (this._x = Math.atan2(-u3, f3), this._z = Math.atan2(-o5, a3)) : (this._x = Math.atan2(d3, h3), this._z = 0)) : e4 === "YXZ" ? (this._x = Math.asin(-n2(u3, -1, 1)), Math.abs(u3) < 0.9999999 ? (this._y = Math.atan2(c3, f3), this._z = Math.atan2(l4, h3)) : (this._y = Math.atan2(-p3, a3), this._z = 0)) : e4 === "ZXY" ? (this._x = Math.asin(n2(d3, -1, 1)), Math.abs(d3) < 0.9999999 ? (this._y = Math.atan2(-p3, f3), this._z = Math.atan2(-o5, h3)) : (this._y = 0, this._z = Math.atan2(l4, a3))) : e4 === "ZYX" ? (this._y = Math.asin(-n2(p3, -1, 1)), Math.abs(p3) < 0.9999999 ? (this._x = Math.atan2(d3, f3), this._z = Math.atan2(l4, a3)) : (this._x = 0, this._z = Math.atan2(-o5, h3))) : e4 === "YZX" ? (this._z = Math.asin(n2(l4, -1, 1)), Math.abs(l4) < 0.9999999 ? (this._x = Math.atan2(-u3, h3), this._y = Math.atan2(-p3, a3)) : (this._x = 0, this._y = Math.atan2(c3, f3))) : e4 === "XZY" ? (this._z = Math.asin(-n2(o5, -1, 1)), Math.abs(o5) < 0.9999999 ? (this._x = Math.atan2(d3, h3), this._y = Math.atan2(c3, a3)) : (this._x = Math.atan2(-u3, f3), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e4), this._order = e4, r3 !== false && this._onChangeCallback(), this;
        }, setFromQuaternion: function(t3, e4, r3) {
          return C.makeRotationFromQuaternion(t3), this.setFromRotationMatrix(C, e4, r3);
        }, setFromVector3: function(t3, e4) {
          return this.set(t3.x, t3.y, t3.z, e4 || this._order);
        }, reorder: function(t3) {
          return O.setFromEuler(this), this.setFromQuaternion(O, t3);
        }, equals: function(t3) {
          return t3._x === this._x && t3._y === this._y && t3._z === this._z && t3._order === this._order;
        }, fromArray: function(t3) {
          return this._x = t3[0], this._y = t3[1], this._z = t3[2], t3[3] !== void 0 && (this._order = t3[3]), this._onChangeCallback(), this;
        }, toArray: function(t3, e4) {
          return t3 === void 0 && (t3 = []), e4 === void 0 && (e4 = 0), t3[e4] = this._x, t3[e4 + 1] = this._y, t3[e4 + 2] = this._z, t3[e4 + 3] = this._order, t3;
        }, toVector3: function(t3) {
          return t3 ? t3.set(this._x, this._y, this._z) : new d2(this._x, this._y, this._z);
        }, _onChange: function(t3) {
          return this._onChangeCallback = t3, this;
        }, _onChangeCallback: function() {
        } }), Object.assign(N.prototype, { set: function(t3) {
          this.mask = 1 << t3 | 0;
        }, enable: function(t3) {
          this.mask |= 1 << t3 | 0;
        }, enableAll: function() {
          this.mask = -1;
        }, toggle: function(t3) {
          this.mask ^= 1 << t3 | 0;
        }, disable: function(t3) {
          this.mask &= ~(1 << t3 | 0);
        }, disableAll: function() {
          this.mask = 0;
        }, test: function(t3) {
          return (this.mask & t3.mask) != 0;
        } });
        var I = 0, z = new d2(), B = new h2(), F = new P2(), G = new d2(), U = new d2(), H = new d2(), V = new h2(), j = new d2(1, 0, 0), k = new d2(0, 1, 0), W = new d2(0, 0, 1), q = { type: "added" }, X = { type: "removed" };
        function Y() {
          Object.defineProperty(this, "id", { value: I++ }), this.uuid = s3.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Y.DefaultUp.clone();
          var t3 = new d2(), e4 = new D(), r3 = new h2(), n2 = new d2(1, 1, 1);
          e4._onChange(function() {
            r3.setFromEuler(e4, false);
          }), r3._onChange(function() {
            e4.setFromQuaternion(r3, void 0, false);
          }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: t3 }, rotation: { configurable: true, enumerable: true, value: e4 }, quaternion: { configurable: true, enumerable: true, value: r3 }, scale: { configurable: true, enumerable: true, value: n2 }, modelViewMatrix: { value: new P2() }, normalMatrix: { value: new m2() } }), this.matrix = new P2(), this.matrixWorld = new P2(), this.matrixAutoUpdate = Y.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new N(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.userData = {};
        }
        function J() {
          Y.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
        Y.DefaultUp = new d2(0, 1, 0), Y.DefaultMatrixAutoUpdate = true, Y.prototype = Object.assign(Object.create(e3.prototype), { constructor: Y, isObject3D: true, onBeforeRender: function() {
        }, onAfterRender: function() {
        }, applyMatrix: function(t3) {
          this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t3), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }, applyQuaternion: function(t3) {
          return this.quaternion.premultiply(t3), this;
        }, setRotationFromAxisAngle: function(t3, e4) {
          this.quaternion.setFromAxisAngle(t3, e4);
        }, setRotationFromEuler: function(t3) {
          this.quaternion.setFromEuler(t3, true);
        }, setRotationFromMatrix: function(t3) {
          this.quaternion.setFromRotationMatrix(t3);
        }, setRotationFromQuaternion: function(t3) {
          this.quaternion.copy(t3);
        }, rotateOnAxis: function(t3, e4) {
          return B.setFromAxisAngle(t3, e4), this.quaternion.multiply(B), this;
        }, rotateOnWorldAxis: function(t3, e4) {
          return B.setFromAxisAngle(t3, e4), this.quaternion.premultiply(B), this;
        }, rotateX: function(t3) {
          return this.rotateOnAxis(j, t3);
        }, rotateY: function(t3) {
          return this.rotateOnAxis(k, t3);
        }, rotateZ: function(t3) {
          return this.rotateOnAxis(W, t3);
        }, translateOnAxis: function(t3, e4) {
          return z.copy(t3).applyQuaternion(this.quaternion), this.position.add(z.multiplyScalar(e4)), this;
        }, translateX: function(t3) {
          return this.translateOnAxis(j, t3);
        }, translateY: function(t3) {
          return this.translateOnAxis(k, t3);
        }, translateZ: function(t3) {
          return this.translateOnAxis(W, t3);
        }, localToWorld: function(t3) {
          return t3.applyMatrix4(this.matrixWorld);
        }, worldToLocal: function(t3) {
          return t3.applyMatrix4(F.getInverse(this.matrixWorld));
        }, lookAt: function(t3, e4, r3) {
          t3.isVector3 ? G.copy(t3) : G.set(t3, e4, r3);
          var n2 = this.parent;
          this.updateWorldMatrix(true, false), U.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? F.lookAt(U, G, this.up) : F.lookAt(G, U, this.up), this.quaternion.setFromRotationMatrix(F), n2 && (F.extractRotation(n2.matrixWorld), B.setFromRotationMatrix(F), this.quaternion.premultiply(B.inverse()));
        }, add: function(t3) {
          if (arguments.length > 1) {
            for (var e4 = 0; e4 < arguments.length; e4++)
              this.add(arguments[e4]);
            return this;
          }
          return t3 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t3), this) : (t3 && t3.isObject3D ? (t3.parent !== null && t3.parent.remove(t3), t3.parent = this, this.children.push(t3), t3.dispatchEvent(q)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t3), this);
        }, remove: function(t3) {
          if (arguments.length > 1) {
            for (var e4 = 0; e4 < arguments.length; e4++)
              this.remove(arguments[e4]);
            return this;
          }
          var r3 = this.children.indexOf(t3);
          return r3 !== -1 && (t3.parent = null, this.children.splice(r3, 1), t3.dispatchEvent(X)), this;
        }, attach: function(t3) {
          return this.updateWorldMatrix(true, false), F.getInverse(this.matrixWorld), t3.parent !== null && (t3.parent.updateWorldMatrix(true, false), F.multiply(t3.parent.matrixWorld)), t3.applyMatrix(F), t3.updateWorldMatrix(false, false), this.add(t3), this;
        }, getObjectById: function(t3) {
          return this.getObjectByProperty("id", t3);
        }, getObjectByName: function(t3) {
          return this.getObjectByProperty("name", t3);
        }, getObjectByProperty: function(t3, e4) {
          if (this[t3] === e4)
            return this;
          for (var r3 = 0, n2 = this.children.length; r3 < n2; r3++) {
            var i3 = this.children[r3].getObjectByProperty(t3, e4);
            if (i3 !== void 0)
              return i3;
          }
        }, getWorldPosition: function(t3) {
          return t3 === void 0 && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t3 = new d2()), this.updateMatrixWorld(true), t3.setFromMatrixPosition(this.matrixWorld);
        }, getWorldQuaternion: function(t3) {
          return t3 === void 0 && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t3 = new h2()), this.updateMatrixWorld(true), this.matrixWorld.decompose(U, t3, H), t3;
        }, getWorldScale: function(t3) {
          return t3 === void 0 && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t3 = new d2()), this.updateMatrixWorld(true), this.matrixWorld.decompose(U, V, t3), t3;
        }, getWorldDirection: function(t3) {
          t3 === void 0 && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t3 = new d2()), this.updateMatrixWorld(true);
          var e4 = this.matrixWorld.elements;
          return t3.set(e4[8], e4[9], e4[10]).normalize();
        }, raycast: function() {
        }, traverse: function(t3) {
          t3(this);
          for (var e4 = this.children, r3 = 0, n2 = e4.length; r3 < n2; r3++)
            e4[r3].traverse(t3);
        }, traverseVisible: function(t3) {
          if (this.visible !== false) {
            t3(this);
            for (var e4 = this.children, r3 = 0, n2 = e4.length; r3 < n2; r3++)
              e4[r3].traverseVisible(t3);
          }
        }, traverseAncestors: function(t3) {
          var e4 = this.parent;
          e4 !== null && (t3(e4), e4.traverseAncestors(t3));
        }, updateMatrix: function() {
          this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
        }, updateMatrixWorld: function(t3) {
          this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t3) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t3 = true);
          for (var e4 = this.children, r3 = 0, n2 = e4.length; r3 < n2; r3++)
            e4[r3].updateMatrixWorld(t3);
        }, updateWorldMatrix: function(t3, e4) {
          var r3 = this.parent;
          if (t3 === true && r3 !== null && r3.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e4 === true)
            for (var n2 = this.children, i3 = 0, a3 = n2.length; i3 < a3; i3++)
              n2[i3].updateWorldMatrix(false, true);
        }, toJSON: function(t3) {
          var e4 = t3 === void 0 || typeof t3 == "string", r3 = {};
          e4 && (t3 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, r3.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
          var n2 = {};
          function i3(e5, r4) {
            return e5[r4.uuid] === void 0 && (e5[r4.uuid] = r4.toJSON(t3)), r4.uuid;
          }
          if (n2.uuid = this.uuid, n2.type = this.type, this.name !== "" && (n2.name = this.name), this.castShadow === true && (n2.castShadow = true), this.receiveShadow === true && (n2.receiveShadow = true), this.visible === false && (n2.visible = false), this.frustumCulled === false && (n2.frustumCulled = false), this.renderOrder !== 0 && (n2.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (n2.userData = this.userData), n2.layers = this.layers.mask, n2.matrix = this.matrix.toArray(), this.matrixAutoUpdate === false && (n2.matrixAutoUpdate = false), this.isMesh && this.drawMode !== 0 && (n2.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
            n2.geometry = i3(t3.geometries, this.geometry);
            var a3 = this.geometry.parameters;
            if (a3 !== void 0 && a3.shapes !== void 0) {
              var o5 = a3.shapes;
              if (Array.isArray(o5))
                for (var s4 = 0, c3 = o5.length; s4 < c3; s4++) {
                  var l4 = o5[s4];
                  i3(t3.shapes, l4);
                }
              else
                i3(t3.shapes, o5);
            }
          }
          if (this.material !== void 0)
            if (Array.isArray(this.material)) {
              var h3 = [];
              for (s4 = 0, c3 = this.material.length; s4 < c3; s4++)
                h3.push(i3(t3.materials, this.material[s4]));
              n2.material = h3;
            } else
              n2.material = i3(t3.materials, this.material);
          if (this.children.length > 0)
            for (n2.children = [], s4 = 0; s4 < this.children.length; s4++)
              n2.children.push(this.children[s4].toJSON(t3).object);
          if (e4) {
            var u3 = m3(t3.geometries), p3 = m3(t3.materials), d3 = m3(t3.textures), f3 = m3(t3.images);
            o5 = m3(t3.shapes), u3.length > 0 && (r3.geometries = u3), p3.length > 0 && (r3.materials = p3), d3.length > 0 && (r3.textures = d3), f3.length > 0 && (r3.images = f3), o5.length > 0 && (r3.shapes = o5);
          }
          return r3.object = n2, r3;
          function m3(t4) {
            var e5 = [];
            for (var r4 in t4) {
              var n3 = t4[r4];
              delete n3.metadata, e5.push(n3);
            }
            return e5;
          }
        }, clone: function(t3) {
          return new this.constructor().copy(this, t3);
        }, copy: function(t3, e4) {
          if (e4 === void 0 && (e4 = true), this.name = t3.name, this.up.copy(t3.up), this.position.copy(t3.position), this.quaternion.copy(t3.quaternion), this.scale.copy(t3.scale), this.matrix.copy(t3.matrix), this.matrixWorld.copy(t3.matrixWorld), this.matrixAutoUpdate = t3.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t3.matrixWorldNeedsUpdate, this.layers.mask = t3.layers.mask, this.visible = t3.visible, this.castShadow = t3.castShadow, this.receiveShadow = t3.receiveShadow, this.frustumCulled = t3.frustumCulled, this.renderOrder = t3.renderOrder, this.userData = JSON.parse(JSON.stringify(t3.userData)), e4 === true)
            for (var r3 = 0; r3 < t3.children.length; r3++) {
              var n2 = t3.children[r3];
              this.add(n2.clone());
            }
          return this;
        } }), J.prototype = Object.assign(Object.create(Y.prototype), { constructor: J, isScene: true, copy: function(t3, e4) {
          return Y.prototype.copy.call(this, t3, e4), t3.background !== null && (this.background = t3.background.clone()), t3.fog !== null && (this.fog = t3.fog.clone()), t3.overrideMaterial !== null && (this.overrideMaterial = t3.overrideMaterial.clone()), this.autoUpdate = t3.autoUpdate, this.matrixAutoUpdate = t3.matrixAutoUpdate, this;
        }, toJSON: function(t3) {
          var e4 = Y.prototype.toJSON.call(this, t3);
          return this.background !== null && (e4.object.background = this.background.toJSON(t3)), this.fog !== null && (e4.object.fog = this.fog.toJSON()), e4;
        }, dispose: function() {
          this.dispatchEvent({ type: "dispose" });
        } });
        var Z = [new d2(), new d2(), new d2(), new d2(), new d2(), new d2(), new d2(), new d2()], Q = new d2(), K = new d2(), $ = new d2(), tt = new d2(), et = new d2(), rt = new d2(), nt = new d2(), it = new d2(), at = new d2(), ot = new d2(), st = new d2();
        function ct(t3, e4) {
          this.min = t3 !== void 0 ? t3 : new d2(1 / 0, 1 / 0, 1 / 0), this.max = e4 !== void 0 ? e4 : new d2(-1 / 0, -1 / 0, -1 / 0);
        }
        function lt(t3, e4, r3, n2, i3) {
          var a3, o5;
          for (a3 = 0, o5 = t3.length - 3; a3 <= o5; a3 += 3) {
            st.fromArray(t3, a3);
            var s4 = i3.x * Math.abs(st.x) + i3.y * Math.abs(st.y) + i3.z * Math.abs(st.z), c3 = e4.dot(st), l4 = r3.dot(st), h3 = n2.dot(st);
            if (Math.max(-Math.max(c3, l4, h3), Math.min(c3, l4, h3)) > s4)
              return false;
          }
          return true;
        }
        Object.assign(ct.prototype, { isBox3: true, set: function(t3, e4) {
          return this.min.copy(t3), this.max.copy(e4), this;
        }, setFromArray: function(t3) {
          for (var e4 = 1 / 0, r3 = 1 / 0, n2 = 1 / 0, i3 = -1 / 0, a3 = -1 / 0, o5 = -1 / 0, s4 = 0, c3 = t3.length; s4 < c3; s4 += 3) {
            var l4 = t3[s4], h3 = t3[s4 + 1], u3 = t3[s4 + 2];
            l4 < e4 && (e4 = l4), h3 < r3 && (r3 = h3), u3 < n2 && (n2 = u3), l4 > i3 && (i3 = l4), h3 > a3 && (a3 = h3), u3 > o5 && (o5 = u3);
          }
          return this.min.set(e4, r3, n2), this.max.set(i3, a3, o5), this;
        }, setFromBufferAttribute: function(t3) {
          for (var e4 = 1 / 0, r3 = 1 / 0, n2 = 1 / 0, i3 = -1 / 0, a3 = -1 / 0, o5 = -1 / 0, s4 = 0, c3 = t3.count; s4 < c3; s4++) {
            var l4 = t3.getX(s4), h3 = t3.getY(s4), u3 = t3.getZ(s4);
            l4 < e4 && (e4 = l4), h3 < r3 && (r3 = h3), u3 < n2 && (n2 = u3), l4 > i3 && (i3 = l4), h3 > a3 && (a3 = h3), u3 > o5 && (o5 = u3);
          }
          return this.min.set(e4, r3, n2), this.max.set(i3, a3, o5), this;
        }, setFromPoints: function(t3) {
          this.makeEmpty();
          for (var e4 = 0, r3 = t3.length; e4 < r3; e4++)
            this.expandByPoint(t3[e4]);
          return this;
        }, setFromCenterAndSize: function(t3, e4) {
          var r3 = Q.copy(e4).multiplyScalar(0.5);
          return this.min.copy(t3).sub(r3), this.max.copy(t3).add(r3), this;
        }, setFromObject: function(t3) {
          return this.makeEmpty(), this.expandByObject(t3);
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          return this.min.copy(t3.min), this.max.copy(t3.max), this;
        }, makeEmpty: function() {
          return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }, isEmpty: function() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }, getCenter: function(t3) {
          return t3 === void 0 && (console.warn("THREE.Box3: .getCenter() target is now required"), t3 = new d2()), this.isEmpty() ? t3.set(0, 0, 0) : t3.addVectors(this.min, this.max).multiplyScalar(0.5);
        }, getSize: function(t3) {
          return t3 === void 0 && (console.warn("THREE.Box3: .getSize() target is now required"), t3 = new d2()), this.isEmpty() ? t3.set(0, 0, 0) : t3.subVectors(this.max, this.min);
        }, expandByPoint: function(t3) {
          return this.min.min(t3), this.max.max(t3), this;
        }, expandByVector: function(t3) {
          return this.min.sub(t3), this.max.add(t3), this;
        }, expandByScalar: function(t3) {
          return this.min.addScalar(-t3), this.max.addScalar(t3), this;
        }, expandByObject: function(t3) {
          var e4, r3;
          t3.updateWorldMatrix(false, false);
          var n2 = t3.geometry;
          if (n2 !== void 0) {
            if (n2.isGeometry) {
              var i3 = n2.vertices;
              for (e4 = 0, r3 = i3.length; e4 < r3; e4++)
                Q.copy(i3[e4]), Q.applyMatrix4(t3.matrixWorld), this.expandByPoint(Q);
            } else if (n2.isBufferGeometry) {
              var a3 = n2.attributes.position;
              if (a3 !== void 0)
                for (e4 = 0, r3 = a3.count; e4 < r3; e4++)
                  Q.fromBufferAttribute(a3, e4).applyMatrix4(t3.matrixWorld), this.expandByPoint(Q);
            }
          }
          var o5 = t3.children;
          for (e4 = 0, r3 = o5.length; e4 < r3; e4++)
            this.expandByObject(o5[e4]);
          return this;
        }, containsPoint: function(t3) {
          return !(t3.x < this.min.x || t3.x > this.max.x || t3.y < this.min.y || t3.y > this.max.y || t3.z < this.min.z || t3.z > this.max.z);
        }, containsBox: function(t3) {
          return this.min.x <= t3.min.x && t3.max.x <= this.max.x && this.min.y <= t3.min.y && t3.max.y <= this.max.y && this.min.z <= t3.min.z && t3.max.z <= this.max.z;
        }, getParameter: function(t3, e4) {
          return e4 === void 0 && (console.warn("THREE.Box3: .getParameter() target is now required"), e4 = new d2()), e4.set((t3.x - this.min.x) / (this.max.x - this.min.x), (t3.y - this.min.y) / (this.max.y - this.min.y), (t3.z - this.min.z) / (this.max.z - this.min.z));
        }, intersectsBox: function(t3) {
          return !(t3.max.x < this.min.x || t3.min.x > this.max.x || t3.max.y < this.min.y || t3.min.y > this.max.y || t3.max.z < this.min.z || t3.min.z > this.max.z);
        }, intersectsSphere: function(t3) {
          return this.clampPoint(t3.center, Q), Q.distanceToSquared(t3.center) <= t3.radius * t3.radius;
        }, intersectsPlane: function(t3) {
          var e4, r3;
          return t3.normal.x > 0 ? (e4 = t3.normal.x * this.min.x, r3 = t3.normal.x * this.max.x) : (e4 = t3.normal.x * this.max.x, r3 = t3.normal.x * this.min.x), t3.normal.y > 0 ? (e4 += t3.normal.y * this.min.y, r3 += t3.normal.y * this.max.y) : (e4 += t3.normal.y * this.max.y, r3 += t3.normal.y * this.min.y), t3.normal.z > 0 ? (e4 += t3.normal.z * this.min.z, r3 += t3.normal.z * this.max.z) : (e4 += t3.normal.z * this.max.z, r3 += t3.normal.z * this.min.z), e4 <= -t3.constant && r3 >= -t3.constant;
        }, intersectsTriangle: function(t3) {
          if (this.isEmpty())
            return false;
          this.getCenter(it), at.subVectors(this.max, it), K.subVectors(t3.a, it), $.subVectors(t3.b, it), tt.subVectors(t3.c, it), et.subVectors($, K), rt.subVectors(tt, $), nt.subVectors(K, tt);
          var e4 = [0, -et.z, et.y, 0, -rt.z, rt.y, 0, -nt.z, nt.y, et.z, 0, -et.x, rt.z, 0, -rt.x, nt.z, 0, -nt.x, -et.y, et.x, 0, -rt.y, rt.x, 0, -nt.y, nt.x, 0];
          return !!lt(e4, K, $, tt, at) && !!lt(e4 = [1, 0, 0, 0, 1, 0, 0, 0, 1], K, $, tt, at) && (ot.crossVectors(et, rt), lt(e4 = [ot.x, ot.y, ot.z], K, $, tt, at));
        }, clampPoint: function(t3, e4) {
          return e4 === void 0 && (console.warn("THREE.Box3: .clampPoint() target is now required"), e4 = new d2()), e4.copy(t3).clamp(this.min, this.max);
        }, distanceToPoint: function(t3) {
          return Q.copy(t3).clamp(this.min, this.max).sub(t3).length();
        }, getBoundingSphere: function(t3) {
          return t3 === void 0 && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t3.center), t3.radius = 0.5 * this.getSize(Q).length(), t3;
        }, intersect: function(t3) {
          return this.min.max(t3.min), this.max.min(t3.max), this.isEmpty() && this.makeEmpty(), this;
        }, union: function(t3) {
          return this.min.min(t3.min), this.max.max(t3.max), this;
        }, applyMatrix4: function(t3) {
          return this.isEmpty() || (Z[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t3), Z[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t3), Z[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t3), Z[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t3), Z[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t3), Z[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t3), Z[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t3), Z[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t3), this.setFromPoints(Z)), this;
        }, translate: function(t3) {
          return this.min.add(t3), this.max.add(t3), this;
        }, equals: function(t3) {
          return t3.min.equals(this.min) && t3.max.equals(this.max);
        } });
        var ht = new ct();
        function ut(t3, e4) {
          this.center = t3 !== void 0 ? t3 : new d2(), this.radius = e4 !== void 0 ? e4 : 0;
        }
        Object.assign(ut.prototype, { set: function(t3, e4) {
          return this.center.copy(t3), this.radius = e4, this;
        }, setFromPoints: function(t3, e4) {
          var r3 = this.center;
          e4 !== void 0 ? r3.copy(e4) : ht.setFromPoints(t3).getCenter(r3);
          for (var n2 = 0, i3 = 0, a3 = t3.length; i3 < a3; i3++)
            n2 = Math.max(n2, r3.distanceToSquared(t3[i3]));
          return this.radius = Math.sqrt(n2), this;
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          return this.center.copy(t3.center), this.radius = t3.radius, this;
        }, empty: function() {
          return this.radius <= 0;
        }, containsPoint: function(t3) {
          return t3.distanceToSquared(this.center) <= this.radius * this.radius;
        }, distanceToPoint: function(t3) {
          return t3.distanceTo(this.center) - this.radius;
        }, intersectsSphere: function(t3) {
          var e4 = this.radius + t3.radius;
          return t3.center.distanceToSquared(this.center) <= e4 * e4;
        }, intersectsBox: function(t3) {
          return t3.intersectsSphere(this);
        }, intersectsPlane: function(t3) {
          return Math.abs(t3.distanceToPoint(this.center)) <= this.radius;
        }, clampPoint: function(t3, e4) {
          var r3 = this.center.distanceToSquared(t3);
          return e4 === void 0 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e4 = new d2()), e4.copy(t3), r3 > this.radius * this.radius && (e4.sub(this.center).normalize(), e4.multiplyScalar(this.radius).add(this.center)), e4;
        }, getBoundingBox: function(t3) {
          return t3 === void 0 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t3 = new ct()), t3.set(this.center, this.center), t3.expandByScalar(this.radius), t3;
        }, applyMatrix4: function(t3) {
          return this.center.applyMatrix4(t3), this.radius = this.radius * t3.getMaxScaleOnAxis(), this;
        }, translate: function(t3) {
          return this.center.add(t3), this;
        }, equals: function(t3) {
          return t3.center.equals(this.center) && t3.radius === this.radius;
        } });
        var pt = new d2(), dt = new d2(), ft = new d2(), mt = new d2(), gt = new d2(), vt = new d2(), yt = new d2();
        function xt(t3, e4) {
          this.origin = t3 !== void 0 ? t3 : new d2(), this.direction = e4 !== void 0 ? e4 : new d2();
        }
        Object.assign(xt.prototype, { set: function(t3, e4) {
          return this.origin.copy(t3), this.direction.copy(e4), this;
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          return this.origin.copy(t3.origin), this.direction.copy(t3.direction), this;
        }, at: function(t3, e4) {
          return e4 === void 0 && (console.warn("THREE.Ray: .at() target is now required"), e4 = new d2()), e4.copy(this.direction).multiplyScalar(t3).add(this.origin);
        }, lookAt: function(t3) {
          return this.direction.copy(t3).sub(this.origin).normalize(), this;
        }, recast: function(t3) {
          return this.origin.copy(this.at(t3, pt)), this;
        }, closestPointToPoint: function(t3, e4) {
          e4 === void 0 && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e4 = new d2()), e4.subVectors(t3, this.origin);
          var r3 = e4.dot(this.direction);
          return r3 < 0 ? e4.copy(this.origin) : e4.copy(this.direction).multiplyScalar(r3).add(this.origin);
        }, distanceToPoint: function(t3) {
          return Math.sqrt(this.distanceSqToPoint(t3));
        }, distanceSqToPoint: function(t3) {
          var e4 = pt.subVectors(t3, this.origin).dot(this.direction);
          return e4 < 0 ? this.origin.distanceToSquared(t3) : (pt.copy(this.direction).multiplyScalar(e4).add(this.origin), pt.distanceToSquared(t3));
        }, distanceSqToSegment: function(t3, e4, r3, n2) {
          dt.copy(t3).add(e4).multiplyScalar(0.5), ft.copy(e4).sub(t3).normalize(), mt.copy(this.origin).sub(dt);
          var i3, a3, o5, s4, c3 = 0.5 * t3.distanceTo(e4), l4 = -this.direction.dot(ft), h3 = mt.dot(this.direction), u3 = -mt.dot(ft), p3 = mt.lengthSq(), d3 = Math.abs(1 - l4 * l4);
          if (d3 > 0)
            if (a3 = l4 * h3 - u3, s4 = c3 * d3, (i3 = l4 * u3 - h3) >= 0)
              if (a3 >= -s4)
                if (a3 <= s4) {
                  var f3 = 1 / d3;
                  o5 = (i3 *= f3) * (i3 + l4 * (a3 *= f3) + 2 * h3) + a3 * (l4 * i3 + a3 + 2 * u3) + p3;
                } else
                  a3 = c3, o5 = -(i3 = Math.max(0, -(l4 * a3 + h3))) * i3 + a3 * (a3 + 2 * u3) + p3;
              else
                a3 = -c3, o5 = -(i3 = Math.max(0, -(l4 * a3 + h3))) * i3 + a3 * (a3 + 2 * u3) + p3;
            else
              a3 <= -s4 ? o5 = -(i3 = Math.max(0, -(-l4 * c3 + h3))) * i3 + (a3 = i3 > 0 ? -c3 : Math.min(Math.max(-c3, -u3), c3)) * (a3 + 2 * u3) + p3 : a3 <= s4 ? (i3 = 0, o5 = (a3 = Math.min(Math.max(-c3, -u3), c3)) * (a3 + 2 * u3) + p3) : o5 = -(i3 = Math.max(0, -(l4 * c3 + h3))) * i3 + (a3 = i3 > 0 ? c3 : Math.min(Math.max(-c3, -u3), c3)) * (a3 + 2 * u3) + p3;
          else
            a3 = l4 > 0 ? -c3 : c3, o5 = -(i3 = Math.max(0, -(l4 * a3 + h3))) * i3 + a3 * (a3 + 2 * u3) + p3;
          return r3 && r3.copy(this.direction).multiplyScalar(i3).add(this.origin), n2 && n2.copy(ft).multiplyScalar(a3).add(dt), o5;
        }, intersectSphere: function(t3, e4) {
          pt.subVectors(t3.center, this.origin);
          var r3 = pt.dot(this.direction), n2 = pt.dot(pt) - r3 * r3, i3 = t3.radius * t3.radius;
          if (n2 > i3)
            return null;
          var a3 = Math.sqrt(i3 - n2), o5 = r3 - a3, s4 = r3 + a3;
          return o5 < 0 && s4 < 0 ? null : o5 < 0 ? this.at(s4, e4) : this.at(o5, e4);
        }, intersectsSphere: function(t3) {
          return this.distanceSqToPoint(t3.center) <= t3.radius * t3.radius;
        }, distanceToPlane: function(t3) {
          var e4 = t3.normal.dot(this.direction);
          if (e4 === 0)
            return t3.distanceToPoint(this.origin) === 0 ? 0 : null;
          var r3 = -(this.origin.dot(t3.normal) + t3.constant) / e4;
          return r3 >= 0 ? r3 : null;
        }, intersectPlane: function(t3, e4) {
          var r3 = this.distanceToPlane(t3);
          return r3 === null ? null : this.at(r3, e4);
        }, intersectsPlane: function(t3) {
          var e4 = t3.distanceToPoint(this.origin);
          return e4 === 0 || t3.normal.dot(this.direction) * e4 < 0;
        }, intersectBox: function(t3, e4) {
          var r3, n2, i3, a3, o5, s4, c3 = 1 / this.direction.x, l4 = 1 / this.direction.y, h3 = 1 / this.direction.z, u3 = this.origin;
          return c3 >= 0 ? (r3 = (t3.min.x - u3.x) * c3, n2 = (t3.max.x - u3.x) * c3) : (r3 = (t3.max.x - u3.x) * c3, n2 = (t3.min.x - u3.x) * c3), l4 >= 0 ? (i3 = (t3.min.y - u3.y) * l4, a3 = (t3.max.y - u3.y) * l4) : (i3 = (t3.max.y - u3.y) * l4, a3 = (t3.min.y - u3.y) * l4), r3 > a3 || i3 > n2 ? null : ((i3 > r3 || r3 != r3) && (r3 = i3), (a3 < n2 || n2 != n2) && (n2 = a3), h3 >= 0 ? (o5 = (t3.min.z - u3.z) * h3, s4 = (t3.max.z - u3.z) * h3) : (o5 = (t3.max.z - u3.z) * h3, s4 = (t3.min.z - u3.z) * h3), r3 > s4 || o5 > n2 ? null : ((o5 > r3 || r3 != r3) && (r3 = o5), (s4 < n2 || n2 != n2) && (n2 = s4), n2 < 0 ? null : this.at(r3 >= 0 ? r3 : n2, e4)));
        }, intersectsBox: function(t3) {
          return this.intersectBox(t3, pt) !== null;
        }, intersectTriangle: function(t3, e4, r3, n2, i3) {
          gt.subVectors(e4, t3), vt.subVectors(r3, t3), yt.crossVectors(gt, vt);
          var a3, o5 = this.direction.dot(yt);
          if (o5 > 0) {
            if (n2)
              return null;
            a3 = 1;
          } else {
            if (!(o5 < 0))
              return null;
            a3 = -1, o5 = -o5;
          }
          mt.subVectors(this.origin, t3);
          var s4 = a3 * this.direction.dot(vt.crossVectors(mt, vt));
          if (s4 < 0)
            return null;
          var c3 = a3 * this.direction.dot(gt.cross(mt));
          if (c3 < 0)
            return null;
          if (s4 + c3 > o5)
            return null;
          var l4 = -a3 * mt.dot(yt);
          return l4 < 0 ? null : this.at(l4 / o5, i3);
        }, applyMatrix4: function(t3) {
          return this.origin.applyMatrix4(t3), this.direction.transformDirection(t3), this;
        }, equals: function(t3) {
          return t3.origin.equals(this.origin) && t3.direction.equals(this.direction);
        } });
        var bt = new d2(), wt = new d2(), _t = new d2(), Mt = new d2(), St = new d2(), Tt = new d2(), Et = new d2(), At = new d2(), Lt = new d2(), Rt = new d2();
        function Pt(t3, e4, r3) {
          this.a = t3 !== void 0 ? t3 : new d2(), this.b = e4 !== void 0 ? e4 : new d2(), this.c = r3 !== void 0 ? r3 : new d2();
        }
        Object.assign(Pt, { getNormal: function(t3, e4, r3, n2) {
          n2 === void 0 && (console.warn("THREE.Triangle: .getNormal() target is now required"), n2 = new d2()), n2.subVectors(r3, e4), bt.subVectors(t3, e4), n2.cross(bt);
          var i3 = n2.lengthSq();
          return i3 > 0 ? n2.multiplyScalar(1 / Math.sqrt(i3)) : n2.set(0, 0, 0);
        }, getBarycoord: function(t3, e4, r3, n2, i3) {
          bt.subVectors(n2, e4), wt.subVectors(r3, e4), _t.subVectors(t3, e4);
          var a3 = bt.dot(bt), o5 = bt.dot(wt), s4 = bt.dot(_t), c3 = wt.dot(wt), l4 = wt.dot(_t), h3 = a3 * c3 - o5 * o5;
          if (i3 === void 0 && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i3 = new d2()), h3 === 0)
            return i3.set(-2, -1, -1);
          var u3 = 1 / h3, p3 = (c3 * s4 - o5 * l4) * u3, f3 = (a3 * l4 - o5 * s4) * u3;
          return i3.set(1 - p3 - f3, f3, p3);
        }, containsPoint: function(t3, e4, r3, n2) {
          return Pt.getBarycoord(t3, e4, r3, n2, Mt), Mt.x >= 0 && Mt.y >= 0 && Mt.x + Mt.y <= 1;
        }, getUV: function(t3, e4, r3, n2, i3, a3, o5, s4) {
          return this.getBarycoord(t3, e4, r3, n2, Mt), s4.set(0, 0), s4.addScaledVector(i3, Mt.x), s4.addScaledVector(a3, Mt.y), s4.addScaledVector(o5, Mt.z), s4;
        }, isFrontFacing: function(t3, e4, r3, n2) {
          return bt.subVectors(r3, e4), wt.subVectors(t3, e4), bt.cross(wt).dot(n2) < 0;
        } }), Object.assign(Pt.prototype, { set: function(t3, e4, r3) {
          return this.a.copy(t3), this.b.copy(e4), this.c.copy(r3), this;
        }, setFromPointsAndIndices: function(t3, e4, r3, n2) {
          return this.a.copy(t3[e4]), this.b.copy(t3[r3]), this.c.copy(t3[n2]), this;
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          return this.a.copy(t3.a), this.b.copy(t3.b), this.c.copy(t3.c), this;
        }, getArea: function() {
          return bt.subVectors(this.c, this.b), wt.subVectors(this.a, this.b), 0.5 * bt.cross(wt).length();
        }, getMidpoint: function(t3) {
          return t3 === void 0 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t3 = new d2()), t3.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }, getNormal: function(t3) {
          return Pt.getNormal(this.a, this.b, this.c, t3);
        }, getPlane: function(t3) {
          return t3 === void 0 && (console.warn("THREE.Triangle: .getPlane() target is now required"), t3 = new d2()), t3.setFromCoplanarPoints(this.a, this.b, this.c);
        }, getBarycoord: function(t3, e4) {
          return Pt.getBarycoord(t3, this.a, this.b, this.c, e4);
        }, getUV: function(t3, e4, r3, n2, i3) {
          return Pt.getUV(t3, this.a, this.b, this.c, e4, r3, n2, i3);
        }, containsPoint: function(t3) {
          return Pt.containsPoint(t3, this.a, this.b, this.c);
        }, isFrontFacing: function(t3) {
          return Pt.isFrontFacing(this.a, this.b, this.c, t3);
        }, intersectsBox: function(t3) {
          return t3.intersectsTriangle(this);
        }, closestPointToPoint: function(t3, e4) {
          e4 === void 0 && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e4 = new d2());
          var r3, n2, i3 = this.a, a3 = this.b, o5 = this.c;
          St.subVectors(a3, i3), Tt.subVectors(o5, i3), At.subVectors(t3, i3);
          var s4 = St.dot(At), c3 = Tt.dot(At);
          if (s4 <= 0 && c3 <= 0)
            return e4.copy(i3);
          Lt.subVectors(t3, a3);
          var l4 = St.dot(Lt), h3 = Tt.dot(Lt);
          if (l4 >= 0 && h3 <= l4)
            return e4.copy(a3);
          var u3 = s4 * h3 - l4 * c3;
          if (u3 <= 0 && s4 >= 0 && l4 <= 0)
            return r3 = s4 / (s4 - l4), e4.copy(i3).addScaledVector(St, r3);
          Rt.subVectors(t3, o5);
          var p3 = St.dot(Rt), f3 = Tt.dot(Rt);
          if (f3 >= 0 && p3 <= f3)
            return e4.copy(o5);
          var m3 = p3 * c3 - s4 * f3;
          if (m3 <= 0 && c3 >= 0 && f3 <= 0)
            return n2 = c3 / (c3 - f3), e4.copy(i3).addScaledVector(Tt, n2);
          var g3 = l4 * f3 - p3 * h3;
          if (g3 <= 0 && h3 - l4 >= 0 && p3 - f3 >= 0)
            return Et.subVectors(o5, a3), n2 = (h3 - l4) / (h3 - l4 + (p3 - f3)), e4.copy(a3).addScaledVector(Et, n2);
          var v3 = 1 / (g3 + m3 + u3);
          return r3 = m3 * v3, n2 = u3 * v3, e4.copy(i3).addScaledVector(St, r3).addScaledVector(Tt, n2);
        }, equals: function(t3) {
          return t3.a.equals(this.a) && t3.b.equals(this.b) && t3.c.equals(this.c);
        } });
        var Ct = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Ot = { h: 0, s: 0, l: 0 }, Dt = { h: 0, s: 0, l: 0 };
        function Nt(t3, e4, r3) {
          return e4 === void 0 && r3 === void 0 ? this.set(t3) : this.setRGB(t3, e4, r3);
        }
        function It(t3, e4, r3) {
          return r3 < 0 && (r3 += 1), r3 > 1 && (r3 -= 1), r3 < 1 / 6 ? t3 + 6 * (e4 - t3) * r3 : r3 < 0.5 ? e4 : r3 < 2 / 3 ? t3 + 6 * (e4 - t3) * (2 / 3 - r3) : t3;
        }
        function zt(t3) {
          return t3 < 0.04045 ? 0.0773993808 * t3 : Math.pow(0.9478672986 * t3 + 0.0521327014, 2.4);
        }
        function Bt(t3) {
          return t3 < 31308e-7 ? 12.92 * t3 : 1.055 * Math.pow(t3, 0.41666) - 0.055;
        }
        function Ft(t3, e4, r3, n2, i3, a3) {
          this.a = t3, this.b = e4, this.c = r3, this.normal = n2 && n2.isVector3 ? n2 : new d2(), this.vertexNormals = Array.isArray(n2) ? n2 : [], this.color = i3 && i3.isColor ? i3 : new Nt(), this.vertexColors = Array.isArray(i3) ? i3 : [], this.materialIndex = a3 !== void 0 ? a3 : 0;
        }
        Object.assign(Nt.prototype, { isColor: true, r: 1, g: 1, b: 1, set: function(t3) {
          return t3 && t3.isColor ? this.copy(t3) : typeof t3 == "number" ? this.setHex(t3) : typeof t3 == "string" && this.setStyle(t3), this;
        }, setScalar: function(t3) {
          return this.r = t3, this.g = t3, this.b = t3, this;
        }, setHex: function(t3) {
          return t3 = Math.floor(t3), this.r = (t3 >> 16 & 255) / 255, this.g = (t3 >> 8 & 255) / 255, this.b = (255 & t3) / 255, this;
        }, setRGB: function(t3, e4, r3) {
          return this.r = t3, this.g = e4, this.b = r3, this;
        }, setHSL: function(t3, e4, r3) {
          if (t3 = s3.euclideanModulo(t3, 1), e4 = s3.clamp(e4, 0, 1), r3 = s3.clamp(r3, 0, 1), e4 === 0)
            this.r = this.g = this.b = r3;
          else {
            var n2 = r3 <= 0.5 ? r3 * (1 + e4) : r3 + e4 - r3 * e4, i3 = 2 * r3 - n2;
            this.r = It(i3, n2, t3 + 1 / 3), this.g = It(i3, n2, t3), this.b = It(i3, n2, t3 - 1 / 3);
          }
          return this;
        }, setStyle: function(t3) {
          function e4(e5) {
            e5 !== void 0 && parseFloat(e5) < 1 && console.warn("THREE.Color: Alpha component of " + t3 + " will be ignored.");
          }
          var r3;
          if (r3 = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t3)) {
            var n2, i3 = r3[1], a3 = r3[2];
            switch (i3) {
              case "rgb":
              case "rgba":
                if (n2 = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a3))
                  return this.r = Math.min(255, parseInt(n2[1], 10)) / 255, this.g = Math.min(255, parseInt(n2[2], 10)) / 255, this.b = Math.min(255, parseInt(n2[3], 10)) / 255, e4(n2[5]), this;
                if (n2 = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a3))
                  return this.r = Math.min(100, parseInt(n2[1], 10)) / 100, this.g = Math.min(100, parseInt(n2[2], 10)) / 100, this.b = Math.min(100, parseInt(n2[3], 10)) / 100, e4(n2[5]), this;
                break;
              case "hsl":
              case "hsla":
                if (n2 = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a3)) {
                  var o5 = parseFloat(n2[1]) / 360, s4 = parseInt(n2[2], 10) / 100, c3 = parseInt(n2[3], 10) / 100;
                  return e4(n2[5]), this.setHSL(o5, s4, c3);
                }
            }
          } else if (r3 = /^\#([A-Fa-f0-9]+)$/.exec(t3)) {
            var l4, h3 = (l4 = r3[1]).length;
            if (h3 === 3)
              return this.r = parseInt(l4.charAt(0) + l4.charAt(0), 16) / 255, this.g = parseInt(l4.charAt(1) + l4.charAt(1), 16) / 255, this.b = parseInt(l4.charAt(2) + l4.charAt(2), 16) / 255, this;
            if (h3 === 6)
              return this.r = parseInt(l4.charAt(0) + l4.charAt(1), 16) / 255, this.g = parseInt(l4.charAt(2) + l4.charAt(3), 16) / 255, this.b = parseInt(l4.charAt(4) + l4.charAt(5), 16) / 255, this;
          }
          return t3 && t3.length > 0 && ((l4 = Ct[t3]) !== void 0 ? this.setHex(l4) : console.warn("THREE.Color: Unknown color " + t3)), this;
        }, clone: function() {
          return new this.constructor(this.r, this.g, this.b);
        }, copy: function(t3) {
          return this.r = t3.r, this.g = t3.g, this.b = t3.b, this;
        }, copyGammaToLinear: function(t3, e4) {
          return e4 === void 0 && (e4 = 2), this.r = Math.pow(t3.r, e4), this.g = Math.pow(t3.g, e4), this.b = Math.pow(t3.b, e4), this;
        }, copyLinearToGamma: function(t3, e4) {
          e4 === void 0 && (e4 = 2);
          var r3 = e4 > 0 ? 1 / e4 : 1;
          return this.r = Math.pow(t3.r, r3), this.g = Math.pow(t3.g, r3), this.b = Math.pow(t3.b, r3), this;
        }, convertGammaToLinear: function(t3) {
          return this.copyGammaToLinear(this, t3), this;
        }, convertLinearToGamma: function(t3) {
          return this.copyLinearToGamma(this, t3), this;
        }, copySRGBToLinear: function(t3) {
          return this.r = zt(t3.r), this.g = zt(t3.g), this.b = zt(t3.b), this;
        }, copyLinearToSRGB: function(t3) {
          return this.r = Bt(t3.r), this.g = Bt(t3.g), this.b = Bt(t3.b), this;
        }, convertSRGBToLinear: function() {
          return this.copySRGBToLinear(this), this;
        }, convertLinearToSRGB: function() {
          return this.copyLinearToSRGB(this), this;
        }, getHex: function() {
          return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
        }, getHexString: function() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }, getHSL: function(t3) {
          t3 === void 0 && (console.warn("THREE.Color: .getHSL() target is now required"), t3 = { h: 0, s: 0, l: 0 });
          var e4, r3, n2 = this.r, i3 = this.g, a3 = this.b, o5 = Math.max(n2, i3, a3), s4 = Math.min(n2, i3, a3), c3 = (s4 + o5) / 2;
          if (s4 === o5)
            e4 = 0, r3 = 0;
          else {
            var l4 = o5 - s4;
            switch (r3 = c3 <= 0.5 ? l4 / (o5 + s4) : l4 / (2 - o5 - s4), o5) {
              case n2:
                e4 = (i3 - a3) / l4 + (i3 < a3 ? 6 : 0);
                break;
              case i3:
                e4 = (a3 - n2) / l4 + 2;
                break;
              case a3:
                e4 = (n2 - i3) / l4 + 4;
            }
            e4 /= 6;
          }
          return t3.h = e4, t3.s = r3, t3.l = c3, t3;
        }, getStyle: function() {
          return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
        }, offsetHSL: function(t3, e4, r3) {
          return this.getHSL(Ot), Ot.h += t3, Ot.s += e4, Ot.l += r3, this.setHSL(Ot.h, Ot.s, Ot.l), this;
        }, add: function(t3) {
          return this.r += t3.r, this.g += t3.g, this.b += t3.b, this;
        }, addColors: function(t3, e4) {
          return this.r = t3.r + e4.r, this.g = t3.g + e4.g, this.b = t3.b + e4.b, this;
        }, addScalar: function(t3) {
          return this.r += t3, this.g += t3, this.b += t3, this;
        }, sub: function(t3) {
          return this.r = Math.max(0, this.r - t3.r), this.g = Math.max(0, this.g - t3.g), this.b = Math.max(0, this.b - t3.b), this;
        }, multiply: function(t3) {
          return this.r *= t3.r, this.g *= t3.g, this.b *= t3.b, this;
        }, multiplyScalar: function(t3) {
          return this.r *= t3, this.g *= t3, this.b *= t3, this;
        }, lerp: function(t3, e4) {
          return this.r += (t3.r - this.r) * e4, this.g += (t3.g - this.g) * e4, this.b += (t3.b - this.b) * e4, this;
        }, lerpHSL: function(t3, e4) {
          this.getHSL(Ot), t3.getHSL(Dt);
          var r3 = s3.lerp(Ot.h, Dt.h, e4), n2 = s3.lerp(Ot.s, Dt.s, e4), i3 = s3.lerp(Ot.l, Dt.l, e4);
          return this.setHSL(r3, n2, i3), this;
        }, equals: function(t3) {
          return t3.r === this.r && t3.g === this.g && t3.b === this.b;
        }, fromArray: function(t3, e4) {
          return e4 === void 0 && (e4 = 0), this.r = t3[e4], this.g = t3[e4 + 1], this.b = t3[e4 + 2], this;
        }, toArray: function(t3, e4) {
          return t3 === void 0 && (t3 = []), e4 === void 0 && (e4 = 0), t3[e4] = this.r, t3[e4 + 1] = this.g, t3[e4 + 2] = this.b, t3;
        }, toJSON: function() {
          return this.getHex();
        } }), Object.assign(Ft.prototype, { clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          this.a = t3.a, this.b = t3.b, this.c = t3.c, this.normal.copy(t3.normal), this.color.copy(t3.color), this.materialIndex = t3.materialIndex;
          for (var e4 = 0, r3 = t3.vertexNormals.length; e4 < r3; e4++)
            this.vertexNormals[e4] = t3.vertexNormals[e4].clone();
          for (e4 = 0, r3 = t3.vertexColors.length; e4 < r3; e4++)
            this.vertexColors[e4] = t3.vertexColors[e4].clone();
          return this;
        } });
        var Gt = 0;
        function Ut() {
          Object.defineProperty(this, "id", { value: Gt++ }), this.uuid = s3.generateUUID(), this.name = "", this.type = "Material", this.fog = true, this.lights = true, this.blending = 1, this.side = 0, this.flatShading = false, this.vertexTangents = false, this.vertexColors = 0, this.opacity = 1, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilFunc = 519, this.stencilRef = 0, this.stencilMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaTest = 0, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.needsUpdate = true;
        }
        function Ht(t3) {
          Ut.call(this), this.type = "MeshBasicMaterial", this.color = new Nt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.lights = false, this.setValues(t3);
        }
        function Vt(t3, e4, r3) {
          if (Array.isArray(t3))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          this.name = "", this.array = t3, this.itemSize = e4, this.count = t3 !== void 0 ? t3.length / e4 : 0, this.normalized = r3 === true, this.dynamic = false, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
        }
        function jt(t3, e4, r3) {
          Vt.call(this, new Int8Array(t3), e4, r3);
        }
        function kt(t3, e4, r3) {
          Vt.call(this, new Uint8Array(t3), e4, r3);
        }
        function Wt(t3, e4, r3) {
          Vt.call(this, new Uint8ClampedArray(t3), e4, r3);
        }
        function qt(t3, e4, r3) {
          Vt.call(this, new Int16Array(t3), e4, r3);
        }
        function Xt(t3, e4, r3) {
          Vt.call(this, new Uint16Array(t3), e4, r3);
        }
        function Yt(t3, e4, r3) {
          Vt.call(this, new Int32Array(t3), e4, r3);
        }
        function Jt(t3, e4, r3) {
          Vt.call(this, new Uint32Array(t3), e4, r3);
        }
        function Zt(t3, e4, r3) {
          Vt.call(this, new Float32Array(t3), e4, r3);
        }
        function Qt(t3, e4, r3) {
          Vt.call(this, new Float64Array(t3), e4, r3);
        }
        function Kt() {
          this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = false, this.normalsNeedUpdate = false, this.colorsNeedUpdate = false, this.uvsNeedUpdate = false, this.groupsNeedUpdate = false;
        }
        function $t(t3) {
          if (t3.length === 0)
            return -1 / 0;
          for (var e4 = t3[0], r3 = 1, n2 = t3.length; r3 < n2; ++r3)
            t3[r3] > e4 && (e4 = t3[r3]);
          return e4;
        }
        Ut.prototype = Object.assign(Object.create(e3.prototype), { constructor: Ut, isMaterial: true, onBeforeCompile: function() {
        }, setValues: function(t3) {
          if (t3 !== void 0)
            for (var e4 in t3) {
              var r3 = t3[e4];
              if (r3 !== void 0)
                if (e4 !== "shading") {
                  var n2 = this[e4];
                  n2 !== void 0 ? n2 && n2.isColor ? n2.set(r3) : n2 && n2.isVector3 && r3 && r3.isVector3 ? n2.copy(r3) : this[e4] = r3 : console.warn("THREE." + this.type + ": '" + e4 + "' is not a property of this material.");
                } else
                  console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = r3 === 1;
              else
                console.warn("THREE.Material: '" + e4 + "' parameter is undefined.");
            }
        }, toJSON: function(t3) {
          var e4 = t3 === void 0 || typeof t3 == "string";
          e4 && (t3 = { textures: {}, images: {} });
          var r3 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
          function n2(t4) {
            var e5 = [];
            for (var r4 in t4) {
              var n3 = t4[r4];
              delete n3.metadata, e5.push(n3);
            }
            return e5;
          }
          if (r3.uuid = this.uuid, r3.type = this.type, this.name !== "" && (r3.name = this.name), this.color && this.color.isColor && (r3.color = this.color.getHex()), this.roughness !== void 0 && (r3.roughness = this.roughness), this.metalness !== void 0 && (r3.metalness = this.metalness), this.emissive && this.emissive.isColor && (r3.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (r3.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r3.specular = this.specular.getHex()), this.shininess !== void 0 && (r3.shininess = this.shininess), this.clearcoat !== void 0 && (r3.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r3.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r3.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t3).uuid, r3.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (r3.map = this.map.toJSON(t3).uuid), this.matcap && this.matcap.isTexture && (r3.matcap = this.matcap.toJSON(t3).uuid), this.alphaMap && this.alphaMap.isTexture && (r3.alphaMap = this.alphaMap.toJSON(t3).uuid), this.lightMap && this.lightMap.isTexture && (r3.lightMap = this.lightMap.toJSON(t3).uuid), this.aoMap && this.aoMap.isTexture && (r3.aoMap = this.aoMap.toJSON(t3).uuid, r3.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r3.bumpMap = this.bumpMap.toJSON(t3).uuid, r3.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r3.normalMap = this.normalMap.toJSON(t3).uuid, r3.normalMapType = this.normalMapType, r3.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r3.displacementMap = this.displacementMap.toJSON(t3).uuid, r3.displacementScale = this.displacementScale, r3.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r3.roughnessMap = this.roughnessMap.toJSON(t3).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r3.metalnessMap = this.metalnessMap.toJSON(t3).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r3.emissiveMap = this.emissiveMap.toJSON(t3).uuid), this.specularMap && this.specularMap.isTexture && (r3.specularMap = this.specularMap.toJSON(t3).uuid), this.envMap && this.envMap.isTexture && (r3.envMap = this.envMap.toJSON(t3).uuid, r3.reflectivity = this.reflectivity, r3.refractionRatio = this.refractionRatio, this.combine !== void 0 && (r3.combine = this.combine), this.envMapIntensity !== void 0 && (r3.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (r3.gradientMap = this.gradientMap.toJSON(t3).uuid), this.size !== void 0 && (r3.size = this.size), this.sizeAttenuation !== void 0 && (r3.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (r3.blending = this.blending), this.flatShading === true && (r3.flatShading = this.flatShading), this.side !== 0 && (r3.side = this.side), this.vertexColors !== 0 && (r3.vertexColors = this.vertexColors), this.opacity < 1 && (r3.opacity = this.opacity), this.transparent === true && (r3.transparent = this.transparent), r3.depthFunc = this.depthFunc, r3.depthTest = this.depthTest, r3.depthWrite = this.depthWrite, r3.stencilWrite = this.stencilWrite, r3.stencilFunc = this.stencilFunc, r3.stencilRef = this.stencilRef, r3.stencilMask = this.stencilMask, r3.stencilFail = this.stencilFail, r3.stencilZFail = this.stencilZFail, r3.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (r3.rotation = this.rotation), this.polygonOffset === true && (r3.polygonOffset = true), this.polygonOffsetFactor !== 0 && (r3.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r3.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (r3.linewidth = this.linewidth), this.dashSize !== void 0 && (r3.dashSize = this.dashSize), this.gapSize !== void 0 && (r3.gapSize = this.gapSize), this.scale !== void 0 && (r3.scale = this.scale), this.dithering === true && (r3.dithering = true), this.alphaTest > 0 && (r3.alphaTest = this.alphaTest), this.premultipliedAlpha === true && (r3.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === true && (r3.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r3.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r3.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r3.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === true && (r3.morphTargets = true), this.morphNormals === true && (r3.morphNormals = true), this.skinning === true && (r3.skinning = true), this.visible === false && (r3.visible = false), this.toneMapped === false && (r3.toneMapped = false), JSON.stringify(this.userData) !== "{}" && (r3.userData = this.userData), e4) {
            var i3 = n2(t3.textures), a3 = n2(t3.images);
            i3.length > 0 && (r3.textures = i3), a3.length > 0 && (r3.images = a3);
          }
          return r3;
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          this.name = t3.name, this.fog = t3.fog, this.lights = t3.lights, this.blending = t3.blending, this.side = t3.side, this.flatShading = t3.flatShading, this.vertexColors = t3.vertexColors, this.opacity = t3.opacity, this.transparent = t3.transparent, this.blendSrc = t3.blendSrc, this.blendDst = t3.blendDst, this.blendEquation = t3.blendEquation, this.blendSrcAlpha = t3.blendSrcAlpha, this.blendDstAlpha = t3.blendDstAlpha, this.blendEquationAlpha = t3.blendEquationAlpha, this.depthFunc = t3.depthFunc, this.depthTest = t3.depthTest, this.depthWrite = t3.depthWrite, this.stencilWrite = t3.stencilWrite, this.stencilFunc = t3.stencilFunc, this.stencilRef = t3.stencilRef, this.stencilMask = t3.stencilMask, this.stencilFail = t3.stencilFail, this.stencilZFail = t3.stencilZFail, this.stencilZPass = t3.stencilZPass, this.colorWrite = t3.colorWrite, this.precision = t3.precision, this.polygonOffset = t3.polygonOffset, this.polygonOffsetFactor = t3.polygonOffsetFactor, this.polygonOffsetUnits = t3.polygonOffsetUnits, this.dithering = t3.dithering, this.alphaTest = t3.alphaTest, this.premultipliedAlpha = t3.premultipliedAlpha, this.visible = t3.visible, this.toneMapped = t3.toneMapped, this.userData = JSON.parse(JSON.stringify(t3.userData)), this.clipShadows = t3.clipShadows, this.clipIntersection = t3.clipIntersection;
          var e4 = t3.clippingPlanes, r3 = null;
          if (e4 !== null) {
            var n2 = e4.length;
            r3 = new Array(n2);
            for (var i3 = 0; i3 !== n2; ++i3)
              r3[i3] = e4[i3].clone();
          }
          return this.clippingPlanes = r3, this.shadowSide = t3.shadowSide, this;
        }, dispose: function() {
          this.dispatchEvent({ type: "dispose" });
        } }), Ht.prototype = Object.create(Ut.prototype), Ht.prototype.constructor = Ht, Ht.prototype.isMeshBasicMaterial = true, Ht.prototype.copy = function(t3) {
          return Ut.prototype.copy.call(this, t3), this.color.copy(t3.color), this.map = t3.map, this.lightMap = t3.lightMap, this.lightMapIntensity = t3.lightMapIntensity, this.aoMap = t3.aoMap, this.aoMapIntensity = t3.aoMapIntensity, this.specularMap = t3.specularMap, this.alphaMap = t3.alphaMap, this.envMap = t3.envMap, this.combine = t3.combine, this.reflectivity = t3.reflectivity, this.refractionRatio = t3.refractionRatio, this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this.wireframeLinecap = t3.wireframeLinecap, this.wireframeLinejoin = t3.wireframeLinejoin, this.skinning = t3.skinning, this.morphTargets = t3.morphTargets, this;
        }, Object.defineProperty(Vt.prototype, "needsUpdate", { set: function(t3) {
          t3 === true && this.version++;
        } }), Object.assign(Vt.prototype, { isBufferAttribute: true, onUploadCallback: function() {
        }, setArray: function(t3) {
          if (Array.isArray(t3))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          return this.count = t3 !== void 0 ? t3.length / this.itemSize : 0, this.array = t3, this;
        }, setDynamic: function(t3) {
          return this.dynamic = t3, this;
        }, copy: function(t3) {
          return this.name = t3.name, this.array = new t3.array.constructor(t3.array), this.itemSize = t3.itemSize, this.count = t3.count, this.normalized = t3.normalized, this.dynamic = t3.dynamic, this;
        }, copyAt: function(t3, e4, r3) {
          t3 *= this.itemSize, r3 *= e4.itemSize;
          for (var n2 = 0, i3 = this.itemSize; n2 < i3; n2++)
            this.array[t3 + n2] = e4.array[r3 + n2];
          return this;
        }, copyArray: function(t3) {
          return this.array.set(t3), this;
        }, copyColorsArray: function(t3) {
          for (var e4 = this.array, r3 = 0, n2 = 0, i3 = t3.length; n2 < i3; n2++) {
            var a3 = t3[n2];
            a3 === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n2), a3 = new Nt()), e4[r3++] = a3.r, e4[r3++] = a3.g, e4[r3++] = a3.b;
          }
          return this;
        }, copyVector2sArray: function(t3) {
          for (var e4 = this.array, r3 = 0, n2 = 0, i3 = t3.length; n2 < i3; n2++) {
            var a3 = t3[n2];
            a3 === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n2), a3 = new l3()), e4[r3++] = a3.x, e4[r3++] = a3.y;
          }
          return this;
        }, copyVector3sArray: function(t3) {
          for (var e4 = this.array, r3 = 0, n2 = 0, i3 = t3.length; n2 < i3; n2++) {
            var a3 = t3[n2];
            a3 === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n2), a3 = new d2()), e4[r3++] = a3.x, e4[r3++] = a3.y, e4[r3++] = a3.z;
          }
          return this;
        }, copyVector4sArray: function(t3) {
          for (var e4 = this.array, r3 = 0, n2 = 0, i3 = t3.length; n2 < i3; n2++) {
            var a3 = t3[n2];
            a3 === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n2), a3 = new x2()), e4[r3++] = a3.x, e4[r3++] = a3.y, e4[r3++] = a3.z, e4[r3++] = a3.w;
          }
          return this;
        }, set: function(t3, e4) {
          return e4 === void 0 && (e4 = 0), this.array.set(t3, e4), this;
        }, getX: function(t3) {
          return this.array[t3 * this.itemSize];
        }, setX: function(t3, e4) {
          return this.array[t3 * this.itemSize] = e4, this;
        }, getY: function(t3) {
          return this.array[t3 * this.itemSize + 1];
        }, setY: function(t3, e4) {
          return this.array[t3 * this.itemSize + 1] = e4, this;
        }, getZ: function(t3) {
          return this.array[t3 * this.itemSize + 2];
        }, setZ: function(t3, e4) {
          return this.array[t3 * this.itemSize + 2] = e4, this;
        }, getW: function(t3) {
          return this.array[t3 * this.itemSize + 3];
        }, setW: function(t3, e4) {
          return this.array[t3 * this.itemSize + 3] = e4, this;
        }, setXY: function(t3, e4, r3) {
          return t3 *= this.itemSize, this.array[t3 + 0] = e4, this.array[t3 + 1] = r3, this;
        }, setXYZ: function(t3, e4, r3, n2) {
          return t3 *= this.itemSize, this.array[t3 + 0] = e4, this.array[t3 + 1] = r3, this.array[t3 + 2] = n2, this;
        }, setXYZW: function(t3, e4, r3, n2, i3) {
          return t3 *= this.itemSize, this.array[t3 + 0] = e4, this.array[t3 + 1] = r3, this.array[t3 + 2] = n2, this.array[t3 + 3] = i3, this;
        }, onUpload: function(t3) {
          return this.onUploadCallback = t3, this;
        }, clone: function() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }, toJSON: function() {
          return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
        } }), jt.prototype = Object.create(Vt.prototype), jt.prototype.constructor = jt, kt.prototype = Object.create(Vt.prototype), kt.prototype.constructor = kt, Wt.prototype = Object.create(Vt.prototype), Wt.prototype.constructor = Wt, qt.prototype = Object.create(Vt.prototype), qt.prototype.constructor = qt, Xt.prototype = Object.create(Vt.prototype), Xt.prototype.constructor = Xt, Yt.prototype = Object.create(Vt.prototype), Yt.prototype.constructor = Yt, Jt.prototype = Object.create(Vt.prototype), Jt.prototype.constructor = Jt, Zt.prototype = Object.create(Vt.prototype), Zt.prototype.constructor = Zt, Qt.prototype = Object.create(Vt.prototype), Qt.prototype.constructor = Qt, Object.assign(Kt.prototype, { computeGroups: function(t3) {
          for (var e4, r3 = [], n2 = void 0, i3 = t3.faces, a3 = 0; a3 < i3.length; a3++) {
            var o5 = i3[a3];
            o5.materialIndex !== n2 && (n2 = o5.materialIndex, e4 !== void 0 && (e4.count = 3 * a3 - e4.start, r3.push(e4)), e4 = { start: 3 * a3, materialIndex: n2 });
          }
          e4 !== void 0 && (e4.count = 3 * a3 - e4.start, r3.push(e4)), this.groups = r3;
        }, fromGeometry: function(t3) {
          var e4, r3 = t3.faces, n2 = t3.vertices, i3 = t3.faceVertexUvs, a3 = i3[0] && i3[0].length > 0, o5 = i3[1] && i3[1].length > 0, s4 = t3.morphTargets, c3 = s4.length;
          if (c3 > 0) {
            e4 = [];
            for (var h3 = 0; h3 < c3; h3++)
              e4[h3] = { name: s4[h3].name, data: [] };
            this.morphTargets.position = e4;
          }
          var u3, p3 = t3.morphNormals, d3 = p3.length;
          if (d3 > 0) {
            for (u3 = [], h3 = 0; h3 < d3; h3++)
              u3[h3] = { name: p3[h3].name, data: [] };
            this.morphTargets.normal = u3;
          }
          var f3 = t3.skinIndices, m3 = t3.skinWeights, g3 = f3.length === n2.length, v3 = m3.length === n2.length;
          for (n2.length > 0 && r3.length === 0 && console.error("THREE.DirectGeometry: Faceless geometries are not supported."), h3 = 0; h3 < r3.length; h3++) {
            var y3 = r3[h3];
            this.vertices.push(n2[y3.a], n2[y3.b], n2[y3.c]);
            var x3 = y3.vertexNormals;
            if (x3.length === 3)
              this.normals.push(x3[0], x3[1], x3[2]);
            else {
              var b3 = y3.normal;
              this.normals.push(b3, b3, b3);
            }
            var w3, _3 = y3.vertexColors;
            if (_3.length === 3)
              this.colors.push(_3[0], _3[1], _3[2]);
            else {
              var M3 = y3.color;
              this.colors.push(M3, M3, M3);
            }
            a3 === true && ((w3 = i3[0][h3]) !== void 0 ? this.uvs.push(w3[0], w3[1], w3[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h3), this.uvs.push(new l3(), new l3(), new l3()))), o5 === true && ((w3 = i3[1][h3]) !== void 0 ? this.uvs2.push(w3[0], w3[1], w3[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h3), this.uvs2.push(new l3(), new l3(), new l3())));
            for (var S3 = 0; S3 < c3; S3++) {
              var T3 = s4[S3].vertices;
              e4[S3].data.push(T3[y3.a], T3[y3.b], T3[y3.c]);
            }
            for (S3 = 0; S3 < d3; S3++) {
              var E4 = p3[S3].vertexNormals[h3];
              u3[S3].data.push(E4.a, E4.b, E4.c);
            }
            g3 && this.skinIndices.push(f3[y3.a], f3[y3.b], f3[y3.c]), v3 && this.skinWeights.push(m3[y3.a], m3[y3.b], m3[y3.c]);
          }
          return this.computeGroups(t3), this.verticesNeedUpdate = t3.verticesNeedUpdate, this.normalsNeedUpdate = t3.normalsNeedUpdate, this.colorsNeedUpdate = t3.colorsNeedUpdate, this.uvsNeedUpdate = t3.uvsNeedUpdate, this.groupsNeedUpdate = t3.groupsNeedUpdate, t3.boundingSphere !== null && (this.boundingSphere = t3.boundingSphere.clone()), t3.boundingBox !== null && (this.boundingBox = t3.boundingBox.clone()), this;
        } });
        var te = 1, ee = new P2(), re = new Y(), ne = new d2(), ie = new ct(), ae = new ct(), oe = new d2();
        function se() {
          Object.defineProperty(this, "id", { value: te += 2 }), this.uuid = s3.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
        }
        se.prototype = Object.assign(Object.create(e3.prototype), { constructor: se, isBufferGeometry: true, getIndex: function() {
          return this.index;
        }, setIndex: function(t3) {
          Array.isArray(t3) ? this.index = new ($t(t3) > 65535 ? Jt : Xt)(t3, 1) : this.index = t3;
        }, addAttribute: function(t3, e4) {
          return e4 && e4.isBufferAttribute || e4 && e4.isInterleavedBufferAttribute ? t3 === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e4), this) : (this.attributes[t3] = e4, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t3, new Vt(arguments[1], arguments[2])));
        }, getAttribute: function(t3) {
          return this.attributes[t3];
        }, removeAttribute: function(t3) {
          return delete this.attributes[t3], this;
        }, addGroup: function(t3, e4, r3) {
          this.groups.push({ start: t3, count: e4, materialIndex: r3 !== void 0 ? r3 : 0 });
        }, clearGroups: function() {
          this.groups = [];
        }, setDrawRange: function(t3, e4) {
          this.drawRange.start = t3, this.drawRange.count = e4;
        }, applyMatrix: function(t3) {
          var e4 = this.attributes.position;
          e4 !== void 0 && (t3.applyToBufferAttribute(e4), e4.needsUpdate = true);
          var r3 = this.attributes.normal;
          r3 !== void 0 && (new m2().getNormalMatrix(t3).applyToBufferAttribute(r3), r3.needsUpdate = true);
          var n2 = this.attributes.tangent;
          return n2 !== void 0 && (new m2().getNormalMatrix(t3).applyToBufferAttribute(n2), n2.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
        }, rotateX: function(t3) {
          return ee.makeRotationX(t3), this.applyMatrix(ee), this;
        }, rotateY: function(t3) {
          return ee.makeRotationY(t3), this.applyMatrix(ee), this;
        }, rotateZ: function(t3) {
          return ee.makeRotationZ(t3), this.applyMatrix(ee), this;
        }, translate: function(t3, e4, r3) {
          return ee.makeTranslation(t3, e4, r3), this.applyMatrix(ee), this;
        }, scale: function(t3, e4, r3) {
          return ee.makeScale(t3, e4, r3), this.applyMatrix(ee), this;
        }, lookAt: function(t3) {
          return re.lookAt(t3), re.updateMatrix(), this.applyMatrix(re.matrix), this;
        }, center: function() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(ne).negate(), this.translate(ne.x, ne.y, ne.z), this;
        }, setFromObject: function(t3) {
          var e4 = t3.geometry;
          if (t3.isPoints || t3.isLine) {
            var r3 = new Zt(3 * e4.vertices.length, 3), n2 = new Zt(3 * e4.colors.length, 3);
            if (this.addAttribute("position", r3.copyVector3sArray(e4.vertices)), this.addAttribute("color", n2.copyColorsArray(e4.colors)), e4.lineDistances && e4.lineDistances.length === e4.vertices.length) {
              var i3 = new Zt(e4.lineDistances.length, 1);
              this.addAttribute("lineDistance", i3.copyArray(e4.lineDistances));
            }
            e4.boundingSphere !== null && (this.boundingSphere = e4.boundingSphere.clone()), e4.boundingBox !== null && (this.boundingBox = e4.boundingBox.clone());
          } else
            t3.isMesh && e4 && e4.isGeometry && this.fromGeometry(e4);
          return this;
        }, setFromPoints: function(t3) {
          for (var e4 = [], r3 = 0, n2 = t3.length; r3 < n2; r3++) {
            var i3 = t3[r3];
            e4.push(i3.x, i3.y, i3.z || 0);
          }
          return this.addAttribute("position", new Zt(e4, 3)), this;
        }, updateFromObject: function(t3) {
          var e4, r3 = t3.geometry;
          if (t3.isMesh) {
            var n2 = r3.__directGeometry;
            if (r3.elementsNeedUpdate === true && (n2 = void 0, r3.elementsNeedUpdate = false), n2 === void 0)
              return this.fromGeometry(r3);
            n2.verticesNeedUpdate = r3.verticesNeedUpdate, n2.normalsNeedUpdate = r3.normalsNeedUpdate, n2.colorsNeedUpdate = r3.colorsNeedUpdate, n2.uvsNeedUpdate = r3.uvsNeedUpdate, n2.groupsNeedUpdate = r3.groupsNeedUpdate, r3.verticesNeedUpdate = false, r3.normalsNeedUpdate = false, r3.colorsNeedUpdate = false, r3.uvsNeedUpdate = false, r3.groupsNeedUpdate = false, r3 = n2;
          }
          return r3.verticesNeedUpdate === true && ((e4 = this.attributes.position) !== void 0 && (e4.copyVector3sArray(r3.vertices), e4.needsUpdate = true), r3.verticesNeedUpdate = false), r3.normalsNeedUpdate === true && ((e4 = this.attributes.normal) !== void 0 && (e4.copyVector3sArray(r3.normals), e4.needsUpdate = true), r3.normalsNeedUpdate = false), r3.colorsNeedUpdate === true && ((e4 = this.attributes.color) !== void 0 && (e4.copyColorsArray(r3.colors), e4.needsUpdate = true), r3.colorsNeedUpdate = false), r3.uvsNeedUpdate && ((e4 = this.attributes.uv) !== void 0 && (e4.copyVector2sArray(r3.uvs), e4.needsUpdate = true), r3.uvsNeedUpdate = false), r3.lineDistancesNeedUpdate && ((e4 = this.attributes.lineDistance) !== void 0 && (e4.copyArray(r3.lineDistances), e4.needsUpdate = true), r3.lineDistancesNeedUpdate = false), r3.groupsNeedUpdate && (r3.computeGroups(t3.geometry), this.groups = r3.groups, r3.groupsNeedUpdate = false), this;
        }, fromGeometry: function(t3) {
          return t3.__directGeometry = new Kt().fromGeometry(t3), this.fromDirectGeometry(t3.__directGeometry);
        }, fromDirectGeometry: function(t3) {
          var e4 = new Float32Array(3 * t3.vertices.length);
          if (this.addAttribute("position", new Vt(e4, 3).copyVector3sArray(t3.vertices)), t3.normals.length > 0) {
            var r3 = new Float32Array(3 * t3.normals.length);
            this.addAttribute("normal", new Vt(r3, 3).copyVector3sArray(t3.normals));
          }
          if (t3.colors.length > 0) {
            var n2 = new Float32Array(3 * t3.colors.length);
            this.addAttribute("color", new Vt(n2, 3).copyColorsArray(t3.colors));
          }
          if (t3.uvs.length > 0) {
            var i3 = new Float32Array(2 * t3.uvs.length);
            this.addAttribute("uv", new Vt(i3, 2).copyVector2sArray(t3.uvs));
          }
          if (t3.uvs2.length > 0) {
            var a3 = new Float32Array(2 * t3.uvs2.length);
            this.addAttribute("uv2", new Vt(a3, 2).copyVector2sArray(t3.uvs2));
          }
          for (var o5 in this.groups = t3.groups, t3.morphTargets) {
            for (var s4 = [], c3 = t3.morphTargets[o5], l4 = 0, h3 = c3.length; l4 < h3; l4++) {
              var u3 = c3[l4], p3 = new Zt(3 * u3.data.length, 3);
              p3.name = u3.name, s4.push(p3.copyVector3sArray(u3.data));
            }
            this.morphAttributes[o5] = s4;
          }
          if (t3.skinIndices.length > 0) {
            var d3 = new Zt(4 * t3.skinIndices.length, 4);
            this.addAttribute("skinIndex", d3.copyVector4sArray(t3.skinIndices));
          }
          if (t3.skinWeights.length > 0) {
            var f3 = new Zt(4 * t3.skinWeights.length, 4);
            this.addAttribute("skinWeight", f3.copyVector4sArray(t3.skinWeights));
          }
          return t3.boundingSphere !== null && (this.boundingSphere = t3.boundingSphere.clone()), t3.boundingBox !== null && (this.boundingBox = t3.boundingBox.clone()), this;
        }, computeBoundingBox: function() {
          this.boundingBox === null && (this.boundingBox = new ct());
          var t3 = this.attributes.position, e4 = this.morphAttributes.position;
          if (t3 !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(t3), e4)
              for (var r3 = 0, n2 = e4.length; r3 < n2; r3++) {
                var i3 = e4[r3];
                ie.setFromBufferAttribute(i3), this.boundingBox.expandByPoint(ie.min), this.boundingBox.expandByPoint(ie.max);
              }
          } else
            this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }, computeBoundingSphere: function() {
          this.boundingSphere === null && (this.boundingSphere = new ut());
          var t3 = this.attributes.position, e4 = this.morphAttributes.position;
          if (t3) {
            var r3 = this.boundingSphere.center;
            if (ie.setFromBufferAttribute(t3), e4)
              for (var n2 = 0, i3 = e4.length; n2 < i3; n2++) {
                var a3 = e4[n2];
                ae.setFromBufferAttribute(a3), ie.expandByPoint(ae.min), ie.expandByPoint(ae.max);
              }
            ie.getCenter(r3);
            var o5 = 0;
            for (n2 = 0, i3 = t3.count; n2 < i3; n2++)
              oe.fromBufferAttribute(t3, n2), o5 = Math.max(o5, r3.distanceToSquared(oe));
            if (e4)
              for (n2 = 0, i3 = e4.length; n2 < i3; n2++)
                for (var s4 = 0, c3 = (a3 = e4[n2]).count; s4 < c3; s4++)
                  oe.fromBufferAttribute(a3, s4), o5 = Math.max(o5, r3.distanceToSquared(oe));
            this.boundingSphere.radius = Math.sqrt(o5), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }, computeFaceNormals: function() {
        }, computeVertexNormals: function() {
          var t3 = this.index, e4 = this.attributes;
          if (e4.position) {
            var r3 = e4.position.array;
            if (e4.normal === void 0)
              this.addAttribute("normal", new Vt(new Float32Array(r3.length), 3));
            else
              for (var n2 = e4.normal.array, i3 = 0, a3 = n2.length; i3 < a3; i3++)
                n2[i3] = 0;
            var o5, s4, c3, l4 = e4.normal.array, h3 = new d2(), u3 = new d2(), p3 = new d2(), f3 = new d2(), m3 = new d2();
            if (t3) {
              var g3 = t3.array;
              for (i3 = 0, a3 = t3.count; i3 < a3; i3 += 3)
                o5 = 3 * g3[i3 + 0], s4 = 3 * g3[i3 + 1], c3 = 3 * g3[i3 + 2], h3.fromArray(r3, o5), u3.fromArray(r3, s4), p3.fromArray(r3, c3), f3.subVectors(p3, u3), m3.subVectors(h3, u3), f3.cross(m3), l4[o5] += f3.x, l4[o5 + 1] += f3.y, l4[o5 + 2] += f3.z, l4[s4] += f3.x, l4[s4 + 1] += f3.y, l4[s4 + 2] += f3.z, l4[c3] += f3.x, l4[c3 + 1] += f3.y, l4[c3 + 2] += f3.z;
            } else
              for (i3 = 0, a3 = r3.length; i3 < a3; i3 += 9)
                h3.fromArray(r3, i3), u3.fromArray(r3, i3 + 3), p3.fromArray(r3, i3 + 6), f3.subVectors(p3, u3), m3.subVectors(h3, u3), f3.cross(m3), l4[i3] = f3.x, l4[i3 + 1] = f3.y, l4[i3 + 2] = f3.z, l4[i3 + 3] = f3.x, l4[i3 + 4] = f3.y, l4[i3 + 5] = f3.z, l4[i3 + 6] = f3.x, l4[i3 + 7] = f3.y, l4[i3 + 8] = f3.z;
            this.normalizeNormals(), e4.normal.needsUpdate = true;
          }
        }, merge: function(t3, e4) {
          if (t3 && t3.isBufferGeometry) {
            e4 === void 0 && (e4 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
            var r3 = this.attributes;
            for (var n2 in r3)
              if (t3.attributes[n2] !== void 0)
                for (var i3 = r3[n2].array, a3 = t3.attributes[n2], o5 = a3.array, s4 = a3.itemSize * e4, c3 = Math.min(o5.length, i3.length - s4), l4 = 0, h3 = s4; l4 < c3; l4++, h3++)
                  i3[h3] = o5[l4];
            return this;
          }
          console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t3);
        }, normalizeNormals: function() {
          for (var t3 = this.attributes.normal, e4 = 0, r3 = t3.count; e4 < r3; e4++)
            oe.x = t3.getX(e4), oe.y = t3.getY(e4), oe.z = t3.getZ(e4), oe.normalize(), t3.setXYZ(e4, oe.x, oe.y, oe.z);
        }, toNonIndexed: function() {
          function t3(t4, e5) {
            for (var r4 = t4.array, n3 = t4.itemSize, i4 = new r4.constructor(e5.length * n3), a4 = 0, o6 = 0, s5 = 0, c4 = e5.length; s5 < c4; s5++) {
              a4 = e5[s5] * n3;
              for (var l5 = 0; l5 < n3; l5++)
                i4[o6++] = r4[a4++];
            }
            return new Vt(i4, n3);
          }
          if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
          var e4 = new se(), r3 = this.index.array, n2 = this.attributes;
          for (var i3 in n2) {
            var a3 = t3(n2[i3], r3);
            e4.addAttribute(i3, a3);
          }
          var o5 = this.morphAttributes;
          for (i3 in o5) {
            for (var s4 = [], c3 = o5[i3], l4 = 0, h3 = c3.length; l4 < h3; l4++)
              a3 = t3(c3[l4], r3), s4.push(a3);
            e4.morphAttributes[i3] = s4;
          }
          for (var u3 = this.groups, p3 = (l4 = 0, u3.length); l4 < p3; l4++) {
            var d3 = u3[l4];
            e4.addGroup(d3.start, d3.count, d3.materialIndex);
          }
          return e4;
        }, toJSON: function() {
          var t3 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
          if (t3.uuid = this.uuid, t3.type = this.type, this.name !== "" && (t3.name = this.name), Object.keys(this.userData).length > 0 && (t3.userData = this.userData), this.parameters !== void 0) {
            var e4 = this.parameters;
            for (var r3 in e4)
              e4[r3] !== void 0 && (t3[r3] = e4[r3]);
            return t3;
          }
          t3.data = { attributes: {} };
          var n2 = this.index;
          n2 !== null && (t3.data.index = { type: n2.array.constructor.name, array: Array.prototype.slice.call(n2.array) });
          var i3 = this.attributes;
          for (var r3 in i3) {
            var a3 = (p3 = i3[r3]).toJSON();
            p3.name !== "" && (a3.name = p3.name), t3.data.attributes[r3] = a3;
          }
          var o5 = {}, s4 = false;
          for (var r3 in this.morphAttributes) {
            for (var c3 = this.morphAttributes[r3], l4 = [], h3 = 0, u3 = c3.length; h3 < u3; h3++) {
              var p3;
              a3 = (p3 = c3[h3]).toJSON(), p3.name !== "" && (a3.name = p3.name), l4.push(a3);
            }
            l4.length > 0 && (o5[r3] = l4, s4 = true);
          }
          s4 && (t3.data.morphAttributes = o5);
          var d3 = this.groups;
          d3.length > 0 && (t3.data.groups = JSON.parse(JSON.stringify(d3)));
          var f3 = this.boundingSphere;
          return f3 !== null && (t3.data.boundingSphere = { center: f3.center.toArray(), radius: f3.radius }), t3;
        }, clone: function() {
          return new se().copy(this);
        }, copy: function(t3) {
          var e4, r3, n2;
          this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t3.name;
          var i3 = t3.index;
          i3 !== null && this.setIndex(i3.clone());
          var a3 = t3.attributes;
          for (e4 in a3) {
            var o5 = a3[e4];
            this.addAttribute(e4, o5.clone());
          }
          var s4 = t3.morphAttributes;
          for (e4 in s4) {
            var c3 = [], l4 = s4[e4];
            for (r3 = 0, n2 = l4.length; r3 < n2; r3++)
              c3.push(l4[r3].clone());
            this.morphAttributes[e4] = c3;
          }
          var h3 = t3.groups;
          for (r3 = 0, n2 = h3.length; r3 < n2; r3++) {
            var u3 = h3[r3];
            this.addGroup(u3.start, u3.count, u3.materialIndex);
          }
          var p3 = t3.boundingBox;
          p3 !== null && (this.boundingBox = p3.clone());
          var d3 = t3.boundingSphere;
          return d3 !== null && (this.boundingSphere = d3.clone()), this.drawRange.start = t3.drawRange.start, this.drawRange.count = t3.drawRange.count, this.userData = t3.userData, this;
        }, dispose: function() {
          this.dispatchEvent({ type: "dispose" });
        } });
        var ce = new P2(), le = new xt(), he = new ut(), ue = new d2(), pe = new d2(), de = new d2(), fe = new d2(), me = new d2(), ge = new d2(), ve = new d2(), ye = new d2(), xe = new d2(), be = new l3(), we = new l3(), _e = new l3(), Me = new d2(), Se = new d2();
        function Te(t3, e4) {
          Y.call(this), this.type = "Mesh", this.geometry = t3 !== void 0 ? t3 : new se(), this.material = e4 !== void 0 ? e4 : new Ht({ color: 16777215 * Math.random() }), this.drawMode = 0, this.updateMorphTargets();
        }
        function Ee(t3, e4, r3, n2, i3, a3, o5, s4) {
          if ((e4.side === 1 ? n2.intersectTriangle(o5, a3, i3, true, s4) : n2.intersectTriangle(i3, a3, o5, e4.side !== 2, s4)) === null)
            return null;
          Se.copy(s4), Se.applyMatrix4(t3.matrixWorld);
          var c3 = r3.ray.origin.distanceTo(Se);
          return c3 < r3.near || c3 > r3.far ? null : { distance: c3, point: Se.clone(), object: t3 };
        }
        function Ae(t3, e4, r3, n2, i3, a3, o5, s4, c3, h3, u3) {
          ue.fromBufferAttribute(i3, c3), pe.fromBufferAttribute(i3, h3), de.fromBufferAttribute(i3, u3);
          var p3 = t3.morphTargetInfluences;
          if (e4.morphTargets && a3 && p3) {
            ve.set(0, 0, 0), ye.set(0, 0, 0), xe.set(0, 0, 0);
            for (var d3 = 0, f3 = a3.length; d3 < f3; d3++) {
              var m3 = p3[d3], g3 = a3[d3];
              m3 !== 0 && (fe.fromBufferAttribute(g3, c3), me.fromBufferAttribute(g3, h3), ge.fromBufferAttribute(g3, u3), ve.addScaledVector(fe.sub(ue), m3), ye.addScaledVector(me.sub(pe), m3), xe.addScaledVector(ge.sub(de), m3));
            }
            ue.add(ve), pe.add(ye), de.add(xe);
          }
          var v3 = Ee(t3, e4, r3, n2, ue, pe, de, Me);
          if (v3) {
            o5 && (be.fromBufferAttribute(o5, c3), we.fromBufferAttribute(o5, h3), _e.fromBufferAttribute(o5, u3), v3.uv = Pt.getUV(Me, ue, pe, de, be, we, _e, new l3())), s4 && (be.fromBufferAttribute(s4, c3), we.fromBufferAttribute(s4, h3), _e.fromBufferAttribute(s4, u3), v3.uv2 = Pt.getUV(Me, ue, pe, de, be, we, _e, new l3()));
            var y3 = new Ft(c3, h3, u3);
            Pt.getNormal(ue, pe, de, y3.normal), v3.face = y3;
          }
          return v3;
        }
        Te.prototype = Object.assign(Object.create(Y.prototype), { constructor: Te, isMesh: true, setDrawMode: function(t3) {
          this.drawMode = t3;
        }, copy: function(t3) {
          return Y.prototype.copy.call(this, t3), this.drawMode = t3.drawMode, t3.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t3.morphTargetInfluences.slice()), t3.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t3.morphTargetDictionary)), this;
        }, updateMorphTargets: function() {
          var t3, e4, r3, n2 = this.geometry;
          if (n2.isBufferGeometry) {
            var i3 = n2.morphAttributes, a3 = Object.keys(i3);
            if (a3.length > 0) {
              var o5 = i3[a3[0]];
              if (o5 !== void 0)
                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t3 = 0, e4 = o5.length; t3 < e4; t3++)
                  r3 = o5[t3].name || String(t3), this.morphTargetInfluences.push(0), this.morphTargetDictionary[r3] = t3;
            }
          } else {
            var s4 = n2.morphTargets;
            s4 !== void 0 && s4.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }, raycast: function(t3, e4) {
          var r3, n2 = this.geometry, i3 = this.material, a3 = this.matrixWorld;
          if (i3 !== void 0 && (n2.boundingSphere === null && n2.computeBoundingSphere(), he.copy(n2.boundingSphere), he.applyMatrix4(a3), t3.ray.intersectsSphere(he) !== false && (ce.getInverse(a3), le.copy(t3.ray).applyMatrix4(ce), n2.boundingBox === null || le.intersectsBox(n2.boundingBox) !== false))) {
            if (n2.isBufferGeometry) {
              var o5, s4, c3, h3, u3, p3, d3, f3, m3, g3 = n2.index, v3 = n2.attributes.position, y3 = n2.morphAttributes.position, x3 = n2.attributes.uv, b3 = n2.attributes.uv2, w3 = n2.groups, _3 = n2.drawRange;
              if (g3 !== null)
                if (Array.isArray(i3))
                  for (h3 = 0, p3 = w3.length; h3 < p3; h3++)
                    for (m3 = i3[(f3 = w3[h3]).materialIndex], u3 = Math.max(f3.start, _3.start), d3 = Math.min(f3.start + f3.count, _3.start + _3.count); u3 < d3; u3 += 3)
                      o5 = g3.getX(u3), s4 = g3.getX(u3 + 1), c3 = g3.getX(u3 + 2), (r3 = Ae(this, m3, t3, le, v3, y3, x3, b3, o5, s4, c3)) && (r3.faceIndex = Math.floor(u3 / 3), r3.face.materialIndex = f3.materialIndex, e4.push(r3));
                else
                  for (h3 = Math.max(0, _3.start), p3 = Math.min(g3.count, _3.start + _3.count); h3 < p3; h3 += 3)
                    o5 = g3.getX(h3), s4 = g3.getX(h3 + 1), c3 = g3.getX(h3 + 2), (r3 = Ae(this, i3, t3, le, v3, y3, x3, b3, o5, s4, c3)) && (r3.faceIndex = Math.floor(h3 / 3), e4.push(r3));
              else if (v3 !== void 0)
                if (Array.isArray(i3))
                  for (h3 = 0, p3 = w3.length; h3 < p3; h3++)
                    for (m3 = i3[(f3 = w3[h3]).materialIndex], u3 = Math.max(f3.start, _3.start), d3 = Math.min(f3.start + f3.count, _3.start + _3.count); u3 < d3; u3 += 3)
                      (r3 = Ae(this, m3, t3, le, v3, y3, x3, b3, o5 = u3, s4 = u3 + 1, c3 = u3 + 2)) && (r3.faceIndex = Math.floor(u3 / 3), r3.face.materialIndex = f3.materialIndex, e4.push(r3));
                else
                  for (h3 = Math.max(0, _3.start), p3 = Math.min(v3.count, _3.start + _3.count); h3 < p3; h3 += 3)
                    (r3 = Ae(this, i3, t3, le, v3, y3, x3, b3, o5 = h3, s4 = h3 + 1, c3 = h3 + 2)) && (r3.faceIndex = Math.floor(h3 / 3), e4.push(r3));
            } else if (n2.isGeometry) {
              var M3, S3, T3, E4, A3 = Array.isArray(i3), L3 = n2.vertices, R2 = n2.faces, P3 = n2.faceVertexUvs[0];
              P3.length > 0 && (E4 = P3);
              for (var C2 = 0, O2 = R2.length; C2 < O2; C2++) {
                var D2 = R2[C2], N2 = A3 ? i3[D2.materialIndex] : i3;
                if (N2 !== void 0 && (M3 = L3[D2.a], S3 = L3[D2.b], T3 = L3[D2.c], r3 = Ee(this, N2, t3, le, M3, S3, T3, Me))) {
                  if (E4 && E4[C2]) {
                    var I2 = E4[C2];
                    be.copy(I2[0]), we.copy(I2[1]), _e.copy(I2[2]), r3.uv = Pt.getUV(Me, M3, S3, T3, be, we, _e, new l3());
                  }
                  r3.face = D2, r3.faceIndex = C2, e4.push(r3);
                }
              }
            }
          }
        }, clone: function() {
          return new this.constructor(this.geometry, this.material).copy(this);
        } });
        var Le = 0, Re = new P2(), Pe = new Y(), Ce = new d2();
        function Oe() {
          Object.defineProperty(this, "id", { value: Le += 2 }), this.uuid = s3.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = false, this.verticesNeedUpdate = false, this.uvsNeedUpdate = false, this.normalsNeedUpdate = false, this.colorsNeedUpdate = false, this.lineDistancesNeedUpdate = false, this.groupsNeedUpdate = false;
        }
        function De(t3, e4, r3, n2, i3, a3) {
          Oe.call(this), this.type = "BoxGeometry", this.parameters = { width: t3, height: e4, depth: r3, widthSegments: n2, heightSegments: i3, depthSegments: a3 }, this.fromBufferGeometry(new Ne(t3, e4, r3, n2, i3, a3)), this.mergeVertices();
        }
        function Ne(t3, e4, r3, n2, i3, a3) {
          se.call(this), this.type = "BoxBufferGeometry", this.parameters = { width: t3, height: e4, depth: r3, widthSegments: n2, heightSegments: i3, depthSegments: a3 };
          var o5 = this;
          t3 = t3 || 1, e4 = e4 || 1, r3 = r3 || 1, n2 = Math.floor(n2) || 1, i3 = Math.floor(i3) || 1, a3 = Math.floor(a3) || 1;
          var s4 = [], c3 = [], l4 = [], h3 = [], u3 = 0, p3 = 0;
          function f3(t4, e5, r4, n3, i4, a4, f4, m3, g3, v3, y3) {
            var x3, b3, w3 = a4 / g3, _3 = f4 / v3, M3 = a4 / 2, S3 = f4 / 2, T3 = m3 / 2, E4 = g3 + 1, A3 = v3 + 1, L3 = 0, R2 = 0, P3 = new d2();
            for (b3 = 0; b3 < A3; b3++) {
              var C2 = b3 * _3 - S3;
              for (x3 = 0; x3 < E4; x3++) {
                var O2 = x3 * w3 - M3;
                P3[t4] = O2 * n3, P3[e5] = C2 * i4, P3[r4] = T3, c3.push(P3.x, P3.y, P3.z), P3[t4] = 0, P3[e5] = 0, P3[r4] = m3 > 0 ? 1 : -1, l4.push(P3.x, P3.y, P3.z), h3.push(x3 / g3), h3.push(1 - b3 / v3), L3 += 1;
              }
            }
            for (b3 = 0; b3 < v3; b3++)
              for (x3 = 0; x3 < g3; x3++) {
                var D2 = u3 + x3 + E4 * b3, N2 = u3 + x3 + E4 * (b3 + 1), I2 = u3 + (x3 + 1) + E4 * (b3 + 1), z2 = u3 + (x3 + 1) + E4 * b3;
                s4.push(D2, N2, z2), s4.push(N2, I2, z2), R2 += 6;
              }
            o5.addGroup(p3, R2, y3), p3 += R2, u3 += L3;
          }
          f3("z", "y", "x", -1, -1, r3, e4, t3, a3, i3, 0), f3("z", "y", "x", 1, -1, r3, e4, -t3, a3, i3, 1), f3("x", "z", "y", 1, 1, t3, r3, e4, n2, a3, 2), f3("x", "z", "y", 1, -1, t3, r3, -e4, n2, a3, 3), f3("x", "y", "z", 1, -1, t3, e4, r3, n2, i3, 4), f3("x", "y", "z", -1, -1, t3, e4, -r3, n2, i3, 5), this.setIndex(s4), this.addAttribute("position", new Zt(c3, 3)), this.addAttribute("normal", new Zt(l4, 3)), this.addAttribute("uv", new Zt(h3, 2));
        }
        function Ie(t3) {
          var e4 = {};
          for (var r3 in t3)
            for (var n2 in e4[r3] = {}, t3[r3]) {
              var i3 = t3[r3][n2];
              i3 && (i3.isColor || i3.isMatrix3 || i3.isMatrix4 || i3.isVector2 || i3.isVector3 || i3.isVector4 || i3.isTexture) ? e4[r3][n2] = i3.clone() : Array.isArray(i3) ? e4[r3][n2] = i3.slice() : e4[r3][n2] = i3;
            }
          return e4;
        }
        function ze(t3) {
          for (var e4 = {}, r3 = 0; r3 < t3.length; r3++) {
            var n2 = Ie(t3[r3]);
            for (var i3 in n2)
              e4[i3] = n2[i3];
          }
          return e4;
        }
        Oe.prototype = Object.assign(Object.create(e3.prototype), { constructor: Oe, isGeometry: true, applyMatrix: function(t3) {
          for (var e4 = new m2().getNormalMatrix(t3), r3 = 0, n2 = this.vertices.length; r3 < n2; r3++)
            this.vertices[r3].applyMatrix4(t3);
          for (r3 = 0, n2 = this.faces.length; r3 < n2; r3++) {
            var i3 = this.faces[r3];
            i3.normal.applyMatrix3(e4).normalize();
            for (var a3 = 0, o5 = i3.vertexNormals.length; a3 < o5; a3++)
              i3.vertexNormals[a3].applyMatrix3(e4).normalize();
          }
          return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.verticesNeedUpdate = true, this.normalsNeedUpdate = true, this;
        }, rotateX: function(t3) {
          return Re.makeRotationX(t3), this.applyMatrix(Re), this;
        }, rotateY: function(t3) {
          return Re.makeRotationY(t3), this.applyMatrix(Re), this;
        }, rotateZ: function(t3) {
          return Re.makeRotationZ(t3), this.applyMatrix(Re), this;
        }, translate: function(t3, e4, r3) {
          return Re.makeTranslation(t3, e4, r3), this.applyMatrix(Re), this;
        }, scale: function(t3, e4, r3) {
          return Re.makeScale(t3, e4, r3), this.applyMatrix(Re), this;
        }, lookAt: function(t3) {
          return Pe.lookAt(t3), Pe.updateMatrix(), this.applyMatrix(Pe.matrix), this;
        }, fromBufferGeometry: function(t3) {
          var e4 = this, r3 = t3.index !== null ? t3.index.array : void 0, n2 = t3.attributes, i3 = n2.position.array, a3 = n2.normal !== void 0 ? n2.normal.array : void 0, o5 = n2.color !== void 0 ? n2.color.array : void 0, s4 = n2.uv !== void 0 ? n2.uv.array : void 0, c3 = n2.uv2 !== void 0 ? n2.uv2.array : void 0;
          c3 !== void 0 && (this.faceVertexUvs[1] = []);
          for (var h3 = 0; h3 < i3.length; h3 += 3)
            e4.vertices.push(new d2().fromArray(i3, h3)), o5 !== void 0 && e4.colors.push(new Nt().fromArray(o5, h3));
          function u3(t4, r4, n3, i4) {
            var h4 = o5 === void 0 ? [] : [e4.colors[t4].clone(), e4.colors[r4].clone(), e4.colors[n3].clone()], u4 = new Ft(t4, r4, n3, a3 === void 0 ? [] : [new d2().fromArray(a3, 3 * t4), new d2().fromArray(a3, 3 * r4), new d2().fromArray(a3, 3 * n3)], h4, i4);
            e4.faces.push(u4), s4 !== void 0 && e4.faceVertexUvs[0].push([new l3().fromArray(s4, 2 * t4), new l3().fromArray(s4, 2 * r4), new l3().fromArray(s4, 2 * n3)]), c3 !== void 0 && e4.faceVertexUvs[1].push([new l3().fromArray(c3, 2 * t4), new l3().fromArray(c3, 2 * r4), new l3().fromArray(c3, 2 * n3)]);
          }
          var p3 = t3.groups;
          if (p3.length > 0)
            for (h3 = 0; h3 < p3.length; h3++)
              for (var f3 = p3[h3], m3 = f3.start, g3 = m3, v3 = m3 + f3.count; g3 < v3; g3 += 3)
                r3 !== void 0 ? u3(r3[g3], r3[g3 + 1], r3[g3 + 2], f3.materialIndex) : u3(g3, g3 + 1, g3 + 2, f3.materialIndex);
          else if (r3 !== void 0)
            for (h3 = 0; h3 < r3.length; h3 += 3)
              u3(r3[h3], r3[h3 + 1], r3[h3 + 2]);
          else
            for (h3 = 0; h3 < i3.length / 3; h3 += 3)
              u3(h3, h3 + 1, h3 + 2);
          return this.computeFaceNormals(), t3.boundingBox !== null && (this.boundingBox = t3.boundingBox.clone()), t3.boundingSphere !== null && (this.boundingSphere = t3.boundingSphere.clone()), this;
        }, center: function() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(Ce).negate(), this.translate(Ce.x, Ce.y, Ce.z), this;
        }, normalize: function() {
          this.computeBoundingSphere();
          var t3 = this.boundingSphere.center, e4 = this.boundingSphere.radius, r3 = e4 === 0 ? 1 : 1 / e4, n2 = new P2();
          return n2.set(r3, 0, 0, -r3 * t3.x, 0, r3, 0, -r3 * t3.y, 0, 0, r3, -r3 * t3.z, 0, 0, 0, 1), this.applyMatrix(n2), this;
        }, computeFaceNormals: function() {
          for (var t3 = new d2(), e4 = new d2(), r3 = 0, n2 = this.faces.length; r3 < n2; r3++) {
            var i3 = this.faces[r3], a3 = this.vertices[i3.a], o5 = this.vertices[i3.b], s4 = this.vertices[i3.c];
            t3.subVectors(s4, o5), e4.subVectors(a3, o5), t3.cross(e4), t3.normalize(), i3.normal.copy(t3);
          }
        }, computeVertexNormals: function(t3) {
          var e4, r3, n2, i3, a3, o5;
          for (t3 === void 0 && (t3 = true), o5 = new Array(this.vertices.length), e4 = 0, r3 = this.vertices.length; e4 < r3; e4++)
            o5[e4] = new d2();
          if (t3) {
            var s4, c3, l4, h3 = new d2(), u3 = new d2();
            for (n2 = 0, i3 = this.faces.length; n2 < i3; n2++)
              a3 = this.faces[n2], s4 = this.vertices[a3.a], c3 = this.vertices[a3.b], l4 = this.vertices[a3.c], h3.subVectors(l4, c3), u3.subVectors(s4, c3), h3.cross(u3), o5[a3.a].add(h3), o5[a3.b].add(h3), o5[a3.c].add(h3);
          } else
            for (this.computeFaceNormals(), n2 = 0, i3 = this.faces.length; n2 < i3; n2++)
              o5[(a3 = this.faces[n2]).a].add(a3.normal), o5[a3.b].add(a3.normal), o5[a3.c].add(a3.normal);
          for (e4 = 0, r3 = this.vertices.length; e4 < r3; e4++)
            o5[e4].normalize();
          for (n2 = 0, i3 = this.faces.length; n2 < i3; n2++) {
            var p3 = (a3 = this.faces[n2]).vertexNormals;
            p3.length === 3 ? (p3[0].copy(o5[a3.a]), p3[1].copy(o5[a3.b]), p3[2].copy(o5[a3.c])) : (p3[0] = o5[a3.a].clone(), p3[1] = o5[a3.b].clone(), p3[2] = o5[a3.c].clone());
          }
          this.faces.length > 0 && (this.normalsNeedUpdate = true);
        }, computeFlatVertexNormals: function() {
          var t3, e4, r3;
          for (this.computeFaceNormals(), t3 = 0, e4 = this.faces.length; t3 < e4; t3++) {
            var n2 = (r3 = this.faces[t3]).vertexNormals;
            n2.length === 3 ? (n2[0].copy(r3.normal), n2[1].copy(r3.normal), n2[2].copy(r3.normal)) : (n2[0] = r3.normal.clone(), n2[1] = r3.normal.clone(), n2[2] = r3.normal.clone());
          }
          this.faces.length > 0 && (this.normalsNeedUpdate = true);
        }, computeMorphNormals: function() {
          var t3, e4, r3, n2, i3;
          for (r3 = 0, n2 = this.faces.length; r3 < n2; r3++)
            for ((i3 = this.faces[r3]).__originalFaceNormal ? i3.__originalFaceNormal.copy(i3.normal) : i3.__originalFaceNormal = i3.normal.clone(), i3.__originalVertexNormals || (i3.__originalVertexNormals = []), t3 = 0, e4 = i3.vertexNormals.length; t3 < e4; t3++)
              i3.__originalVertexNormals[t3] ? i3.__originalVertexNormals[t3].copy(i3.vertexNormals[t3]) : i3.__originalVertexNormals[t3] = i3.vertexNormals[t3].clone();
          var a3 = new Oe();
          for (a3.faces = this.faces, t3 = 0, e4 = this.morphTargets.length; t3 < e4; t3++) {
            if (!this.morphNormals[t3]) {
              this.morphNormals[t3] = {}, this.morphNormals[t3].faceNormals = [], this.morphNormals[t3].vertexNormals = [];
              var o5 = this.morphNormals[t3].faceNormals, s4 = this.morphNormals[t3].vertexNormals;
              for (r3 = 0, n2 = this.faces.length; r3 < n2; r3++)
                c3 = new d2(), l4 = { a: new d2(), b: new d2(), c: new d2() }, o5.push(c3), s4.push(l4);
            }
            var c3, l4, h3 = this.morphNormals[t3];
            for (a3.vertices = this.morphTargets[t3].vertices, a3.computeFaceNormals(), a3.computeVertexNormals(), r3 = 0, n2 = this.faces.length; r3 < n2; r3++)
              i3 = this.faces[r3], c3 = h3.faceNormals[r3], l4 = h3.vertexNormals[r3], c3.copy(i3.normal), l4.a.copy(i3.vertexNormals[0]), l4.b.copy(i3.vertexNormals[1]), l4.c.copy(i3.vertexNormals[2]);
          }
          for (r3 = 0, n2 = this.faces.length; r3 < n2; r3++)
            (i3 = this.faces[r3]).normal = i3.__originalFaceNormal, i3.vertexNormals = i3.__originalVertexNormals;
        }, computeBoundingBox: function() {
          this.boundingBox === null && (this.boundingBox = new ct()), this.boundingBox.setFromPoints(this.vertices);
        }, computeBoundingSphere: function() {
          this.boundingSphere === null && (this.boundingSphere = new ut()), this.boundingSphere.setFromPoints(this.vertices);
        }, merge: function(t3, e4, r3) {
          if (t3 && t3.isGeometry) {
            var n2, i3 = this.vertices.length, a3 = this.vertices, o5 = t3.vertices, s4 = this.faces, c3 = t3.faces, l4 = this.colors, h3 = t3.colors;
            r3 === void 0 && (r3 = 0), e4 !== void 0 && (n2 = new m2().getNormalMatrix(e4));
            for (var u3 = 0, p3 = o5.length; u3 < p3; u3++) {
              var d3 = o5[u3].clone();
              e4 !== void 0 && d3.applyMatrix4(e4), a3.push(d3);
            }
            for (u3 = 0, p3 = h3.length; u3 < p3; u3++)
              l4.push(h3[u3].clone());
            for (u3 = 0, p3 = c3.length; u3 < p3; u3++) {
              var f3, g3, v3, y3 = c3[u3], x3 = y3.vertexNormals, b3 = y3.vertexColors;
              (f3 = new Ft(y3.a + i3, y3.b + i3, y3.c + i3)).normal.copy(y3.normal), n2 !== void 0 && f3.normal.applyMatrix3(n2).normalize();
              for (var w3 = 0, _3 = x3.length; w3 < _3; w3++)
                g3 = x3[w3].clone(), n2 !== void 0 && g3.applyMatrix3(n2).normalize(), f3.vertexNormals.push(g3);
              for (f3.color.copy(y3.color), w3 = 0, _3 = b3.length; w3 < _3; w3++)
                v3 = b3[w3], f3.vertexColors.push(v3.clone());
              f3.materialIndex = y3.materialIndex + r3, s4.push(f3);
            }
            for (u3 = 0, p3 = t3.faceVertexUvs.length; u3 < p3; u3++) {
              var M3 = t3.faceVertexUvs[u3];
              for (this.faceVertexUvs[u3] === void 0 && (this.faceVertexUvs[u3] = []), w3 = 0, _3 = M3.length; w3 < _3; w3++) {
                for (var S3 = M3[w3], T3 = [], E4 = 0, A3 = S3.length; E4 < A3; E4++)
                  T3.push(S3[E4].clone());
                this.faceVertexUvs[u3].push(T3);
              }
            }
          } else
            console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t3);
        }, mergeMesh: function(t3) {
          t3 && t3.isMesh ? (t3.matrixAutoUpdate && t3.updateMatrix(), this.merge(t3.geometry, t3.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t3);
        }, mergeVertices: function() {
          var t3, e4, r3, n2, i3, a3, o5, s4, c3 = {}, l4 = [], h3 = [], u3 = Math.pow(10, 4);
          for (r3 = 0, n2 = this.vertices.length; r3 < n2; r3++)
            t3 = this.vertices[r3], c3[e4 = Math.round(t3.x * u3) + "_" + Math.round(t3.y * u3) + "_" + Math.round(t3.z * u3)] === void 0 ? (c3[e4] = r3, l4.push(this.vertices[r3]), h3[r3] = l4.length - 1) : h3[r3] = h3[c3[e4]];
          var p3 = [];
          for (r3 = 0, n2 = this.faces.length; r3 < n2; r3++) {
            (i3 = this.faces[r3]).a = h3[i3.a], i3.b = h3[i3.b], i3.c = h3[i3.c], a3 = [i3.a, i3.b, i3.c];
            for (var d3 = 0; d3 < 3; d3++)
              if (a3[d3] === a3[(d3 + 1) % 3]) {
                p3.push(r3);
                break;
              }
          }
          for (r3 = p3.length - 1; r3 >= 0; r3--) {
            var f3 = p3[r3];
            for (this.faces.splice(f3, 1), o5 = 0, s4 = this.faceVertexUvs.length; o5 < s4; o5++)
              this.faceVertexUvs[o5].splice(f3, 1);
          }
          var m3 = this.vertices.length - l4.length;
          return this.vertices = l4, m3;
        }, setFromPoints: function(t3) {
          this.vertices = [];
          for (var e4 = 0, r3 = t3.length; e4 < r3; e4++) {
            var n2 = t3[e4];
            this.vertices.push(new d2(n2.x, n2.y, n2.z || 0));
          }
          return this;
        }, sortFacesByMaterialIndex: function() {
          for (var t3 = this.faces, e4 = t3.length, r3 = 0; r3 < e4; r3++)
            t3[r3]._id = r3;
          t3.sort(function(t4, e5) {
            return t4.materialIndex - e5.materialIndex;
          });
          var n2, i3, a3 = this.faceVertexUvs[0], o5 = this.faceVertexUvs[1];
          for (a3 && a3.length === e4 && (n2 = []), o5 && o5.length === e4 && (i3 = []), r3 = 0; r3 < e4; r3++) {
            var s4 = t3[r3]._id;
            n2 && n2.push(a3[s4]), i3 && i3.push(o5[s4]);
          }
          n2 && (this.faceVertexUvs[0] = n2), i3 && (this.faceVertexUvs[1] = i3);
        }, toJSON: function() {
          var t3 = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };
          if (t3.uuid = this.uuid, t3.type = this.type, this.name !== "" && (t3.name = this.name), this.parameters !== void 0) {
            var e4 = this.parameters;
            for (var r3 in e4)
              e4[r3] !== void 0 && (t3[r3] = e4[r3]);
            return t3;
          }
          for (var n2 = [], i3 = 0; i3 < this.vertices.length; i3++) {
            var a3 = this.vertices[i3];
            n2.push(a3.x, a3.y, a3.z);
          }
          var o5 = [], s4 = [], c3 = {}, l4 = [], h3 = {}, u3 = [], p3 = {};
          for (i3 = 0; i3 < this.faces.length; i3++) {
            var d3 = this.faces[i3], f3 = this.faceVertexUvs[0][i3] !== void 0, m3 = d3.normal.length() > 0, g3 = d3.vertexNormals.length > 0, v3 = d3.color.r !== 1 || d3.color.g !== 1 || d3.color.b !== 1, y3 = d3.vertexColors.length > 0, x3 = 0;
            if (x3 = M3(x3, 0, 0), x3 = M3(x3, 1, true), x3 = M3(x3, 2, false), x3 = M3(x3, 3, f3), x3 = M3(x3, 4, m3), x3 = M3(x3, 5, g3), x3 = M3(x3, 6, v3), x3 = M3(x3, 7, y3), o5.push(x3), o5.push(d3.a, d3.b, d3.c), o5.push(d3.materialIndex), f3) {
              var b3 = this.faceVertexUvs[0][i3];
              o5.push(E4(b3[0]), E4(b3[1]), E4(b3[2]));
            }
            if (m3 && o5.push(S3(d3.normal)), g3) {
              var w3 = d3.vertexNormals;
              o5.push(S3(w3[0]), S3(w3[1]), S3(w3[2]));
            }
            if (v3 && o5.push(T3(d3.color)), y3) {
              var _3 = d3.vertexColors;
              o5.push(T3(_3[0]), T3(_3[1]), T3(_3[2]));
            }
          }
          function M3(t4, e5, r4) {
            return r4 ? t4 | 1 << e5 : t4 & ~(1 << e5);
          }
          function S3(t4) {
            var e5 = t4.x.toString() + t4.y.toString() + t4.z.toString();
            return c3[e5] !== void 0 || (c3[e5] = s4.length / 3, s4.push(t4.x, t4.y, t4.z)), c3[e5];
          }
          function T3(t4) {
            var e5 = t4.r.toString() + t4.g.toString() + t4.b.toString();
            return h3[e5] !== void 0 || (h3[e5] = l4.length, l4.push(t4.getHex())), h3[e5];
          }
          function E4(t4) {
            var e5 = t4.x.toString() + t4.y.toString();
            return p3[e5] !== void 0 || (p3[e5] = u3.length / 2, u3.push(t4.x, t4.y)), p3[e5];
          }
          return t3.data = {}, t3.data.vertices = n2, t3.data.normals = s4, l4.length > 0 && (t3.data.colors = l4), u3.length > 0 && (t3.data.uvs = [u3]), t3.data.faces = o5, t3;
        }, clone: function() {
          return new Oe().copy(this);
        }, copy: function(t3) {
          var e4, r3, n2, i3, a3, o5;
          this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t3.name;
          var s4 = t3.vertices;
          for (e4 = 0, r3 = s4.length; e4 < r3; e4++)
            this.vertices.push(s4[e4].clone());
          var c3 = t3.colors;
          for (e4 = 0, r3 = c3.length; e4 < r3; e4++)
            this.colors.push(c3[e4].clone());
          var l4 = t3.faces;
          for (e4 = 0, r3 = l4.length; e4 < r3; e4++)
            this.faces.push(l4[e4].clone());
          for (e4 = 0, r3 = t3.faceVertexUvs.length; e4 < r3; e4++) {
            var h3 = t3.faceVertexUvs[e4];
            for (this.faceVertexUvs[e4] === void 0 && (this.faceVertexUvs[e4] = []), n2 = 0, i3 = h3.length; n2 < i3; n2++) {
              var u3 = h3[n2], p3 = [];
              for (a3 = 0, o5 = u3.length; a3 < o5; a3++) {
                var d3 = u3[a3];
                p3.push(d3.clone());
              }
              this.faceVertexUvs[e4].push(p3);
            }
          }
          var f3 = t3.morphTargets;
          for (e4 = 0, r3 = f3.length; e4 < r3; e4++) {
            var m3 = {};
            if (m3.name = f3[e4].name, f3[e4].vertices !== void 0)
              for (m3.vertices = [], n2 = 0, i3 = f3[e4].vertices.length; n2 < i3; n2++)
                m3.vertices.push(f3[e4].vertices[n2].clone());
            if (f3[e4].normals !== void 0)
              for (m3.normals = [], n2 = 0, i3 = f3[e4].normals.length; n2 < i3; n2++)
                m3.normals.push(f3[e4].normals[n2].clone());
            this.morphTargets.push(m3);
          }
          var g3 = t3.morphNormals;
          for (e4 = 0, r3 = g3.length; e4 < r3; e4++) {
            var v3 = {};
            if (g3[e4].vertexNormals !== void 0)
              for (v3.vertexNormals = [], n2 = 0, i3 = g3[e4].vertexNormals.length; n2 < i3; n2++) {
                var y3 = g3[e4].vertexNormals[n2], x3 = {};
                x3.a = y3.a.clone(), x3.b = y3.b.clone(), x3.c = y3.c.clone(), v3.vertexNormals.push(x3);
              }
            if (g3[e4].faceNormals !== void 0)
              for (v3.faceNormals = [], n2 = 0, i3 = g3[e4].faceNormals.length; n2 < i3; n2++)
                v3.faceNormals.push(g3[e4].faceNormals[n2].clone());
            this.morphNormals.push(v3);
          }
          var b3 = t3.skinWeights;
          for (e4 = 0, r3 = b3.length; e4 < r3; e4++)
            this.skinWeights.push(b3[e4].clone());
          var w3 = t3.skinIndices;
          for (e4 = 0, r3 = w3.length; e4 < r3; e4++)
            this.skinIndices.push(w3[e4].clone());
          var _3 = t3.lineDistances;
          for (e4 = 0, r3 = _3.length; e4 < r3; e4++)
            this.lineDistances.push(_3[e4]);
          var M3 = t3.boundingBox;
          M3 !== null && (this.boundingBox = M3.clone());
          var S3 = t3.boundingSphere;
          return S3 !== null && (this.boundingSphere = S3.clone()), this.elementsNeedUpdate = t3.elementsNeedUpdate, this.verticesNeedUpdate = t3.verticesNeedUpdate, this.uvsNeedUpdate = t3.uvsNeedUpdate, this.normalsNeedUpdate = t3.normalsNeedUpdate, this.colorsNeedUpdate = t3.colorsNeedUpdate, this.lineDistancesNeedUpdate = t3.lineDistancesNeedUpdate, this.groupsNeedUpdate = t3.groupsNeedUpdate, this;
        }, dispose: function() {
          this.dispatchEvent({ type: "dispose" });
        } }), De.prototype = Object.create(Oe.prototype), De.prototype.constructor = De, Ne.prototype = Object.create(se.prototype), Ne.prototype.constructor = Ne;
        var Be = { clone: Ie, merge: ze };
        function Fe(t3) {
          Ut.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, t3 !== void 0 && (t3.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t3));
        }
        function Ge() {
          Y.call(this), this.type = "Camera", this.matrixWorldInverse = new P2(), this.projectionMatrix = new P2(), this.projectionMatrixInverse = new P2();
        }
        function Ue(t3, e4, r3, n2) {
          Ge.call(this), this.type = "PerspectiveCamera", this.fov = t3 !== void 0 ? t3 : 50, this.zoom = 1, this.near = r3 !== void 0 ? r3 : 0.1, this.far = n2 !== void 0 ? n2 : 2e3, this.focus = 10, this.aspect = e4 !== void 0 ? e4 : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        function He(t3, e4, r3, n2) {
          Y.call(this), this.type = "CubeCamera";
          var i3 = new Ue(90, 1, t3, e4);
          i3.up.set(0, -1, 0), i3.lookAt(new d2(1, 0, 0)), this.add(i3);
          var a3 = new Ue(90, 1, t3, e4);
          a3.up.set(0, -1, 0), a3.lookAt(new d2(-1, 0, 0)), this.add(a3);
          var o5 = new Ue(90, 1, t3, e4);
          o5.up.set(0, 0, 1), o5.lookAt(new d2(0, 1, 0)), this.add(o5);
          var s4 = new Ue(90, 1, t3, e4);
          s4.up.set(0, 0, -1), s4.lookAt(new d2(0, -1, 0)), this.add(s4);
          var c3 = new Ue(90, 1, t3, e4);
          c3.up.set(0, -1, 0), c3.lookAt(new d2(0, 0, 1)), this.add(c3);
          var l4 = new Ue(90, 1, t3, e4);
          l4.up.set(0, -1, 0), l4.lookAt(new d2(0, 0, -1)), this.add(l4), n2 = n2 || { format: 1022, magFilter: 1006, minFilter: 1006 }, this.renderTarget = new Ve(r3, r3, n2), this.renderTarget.texture.name = "CubeCamera", this.update = function(t4, e5) {
            this.parent === null && this.updateMatrixWorld();
            var r4 = t4.getRenderTarget(), n3 = this.renderTarget, h3 = n3.texture.generateMipmaps;
            n3.texture.generateMipmaps = false, t4.setRenderTarget(n3, 0), t4.render(e5, i3), t4.setRenderTarget(n3, 1), t4.render(e5, a3), t4.setRenderTarget(n3, 2), t4.render(e5, o5), t4.setRenderTarget(n3, 3), t4.render(e5, s4), t4.setRenderTarget(n3, 4), t4.render(e5, c3), n3.texture.generateMipmaps = h3, t4.setRenderTarget(n3, 5), t4.render(e5, l4), t4.setRenderTarget(r4);
          }, this.clear = function(t4, e5, r4, n3) {
            for (var i4 = t4.getRenderTarget(), a4 = this.renderTarget, o6 = 0; o6 < 6; o6++)
              t4.setRenderTarget(a4, o6), t4.clear(e5, r4, n3);
            t4.setRenderTarget(i4);
          };
        }
        function Ve(t3, e4, r3) {
          b2.call(this, t3, e4, r3);
        }
        function je(t3, e4, r3, n2, i3, a3, o5, s4, c3, l4, h3, u3) {
          y2.call(this, null, a3, o5, s4, c3, l4, n2, i3, h3, u3), this.image = { data: t3, width: e4, height: r3 }, this.magFilter = c3 !== void 0 ? c3 : 1003, this.minFilter = l4 !== void 0 ? l4 : 1003, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
        Fe.prototype = Object.create(Ut.prototype), Fe.prototype.constructor = Fe, Fe.prototype.isShaderMaterial = true, Fe.prototype.copy = function(t3) {
          return Ut.prototype.copy.call(this, t3), this.fragmentShader = t3.fragmentShader, this.vertexShader = t3.vertexShader, this.uniforms = Ie(t3.uniforms), this.defines = Object.assign({}, t3.defines), this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this.lights = t3.lights, this.clipping = t3.clipping, this.skinning = t3.skinning, this.morphTargets = t3.morphTargets, this.morphNormals = t3.morphNormals, this.extensions = t3.extensions, this;
        }, Fe.prototype.toJSON = function(t3) {
          var e4 = Ut.prototype.toJSON.call(this, t3);
          for (var r3 in e4.uniforms = {}, this.uniforms) {
            var n2 = this.uniforms[r3].value;
            n2 && n2.isTexture ? e4.uniforms[r3] = { type: "t", value: n2.toJSON(t3).uuid } : n2 && n2.isColor ? e4.uniforms[r3] = { type: "c", value: n2.getHex() } : n2 && n2.isVector2 ? e4.uniforms[r3] = { type: "v2", value: n2.toArray() } : n2 && n2.isVector3 ? e4.uniforms[r3] = { type: "v3", value: n2.toArray() } : n2 && n2.isVector4 ? e4.uniforms[r3] = { type: "v4", value: n2.toArray() } : n2 && n2.isMatrix3 ? e4.uniforms[r3] = { type: "m3", value: n2.toArray() } : n2 && n2.isMatrix4 ? e4.uniforms[r3] = { type: "m4", value: n2.toArray() } : e4.uniforms[r3] = { value: n2 };
          }
          Object.keys(this.defines).length > 0 && (e4.defines = this.defines), e4.vertexShader = this.vertexShader, e4.fragmentShader = this.fragmentShader;
          var i3 = {};
          for (var a3 in this.extensions)
            this.extensions[a3] === true && (i3[a3] = true);
          return Object.keys(i3).length > 0 && (e4.extensions = i3), e4;
        }, Ge.prototype = Object.assign(Object.create(Y.prototype), { constructor: Ge, isCamera: true, copy: function(t3, e4) {
          return Y.prototype.copy.call(this, t3, e4), this.matrixWorldInverse.copy(t3.matrixWorldInverse), this.projectionMatrix.copy(t3.projectionMatrix), this.projectionMatrixInverse.copy(t3.projectionMatrixInverse), this;
        }, getWorldDirection: function(t3) {
          t3 === void 0 && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t3 = new d2()), this.updateMatrixWorld(true);
          var e4 = this.matrixWorld.elements;
          return t3.set(-e4[8], -e4[9], -e4[10]).normalize();
        }, updateMatrixWorld: function(t3) {
          Y.prototype.updateMatrixWorld.call(this, t3), this.matrixWorldInverse.getInverse(this.matrixWorld);
        }, clone: function() {
          return new this.constructor().copy(this);
        } }), Ue.prototype = Object.assign(Object.create(Ge.prototype), { constructor: Ue, isPerspectiveCamera: true, copy: function(t3, e4) {
          return Ge.prototype.copy.call(this, t3, e4), this.fov = t3.fov, this.zoom = t3.zoom, this.near = t3.near, this.far = t3.far, this.focus = t3.focus, this.aspect = t3.aspect, this.view = t3.view === null ? null : Object.assign({}, t3.view), this.filmGauge = t3.filmGauge, this.filmOffset = t3.filmOffset, this;
        }, setFocalLength: function(t3) {
          var e4 = 0.5 * this.getFilmHeight() / t3;
          this.fov = 2 * s3.RAD2DEG * Math.atan(e4), this.updateProjectionMatrix();
        }, getFocalLength: function() {
          var t3 = Math.tan(0.5 * s3.DEG2RAD * this.fov);
          return 0.5 * this.getFilmHeight() / t3;
        }, getEffectiveFOV: function() {
          return 2 * s3.RAD2DEG * Math.atan(Math.tan(0.5 * s3.DEG2RAD * this.fov) / this.zoom);
        }, getFilmWidth: function() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }, getFilmHeight: function() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }, setViewOffset: function(t3, e4, r3, n2, i3, a3) {
          this.aspect = t3 / e4, this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t3, this.view.fullHeight = e4, this.view.offsetX = r3, this.view.offsetY = n2, this.view.width = i3, this.view.height = a3, this.updateProjectionMatrix();
        }, clearViewOffset: function() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }, updateProjectionMatrix: function() {
          var t3 = this.near, e4 = t3 * Math.tan(0.5 * s3.DEG2RAD * this.fov) / this.zoom, r3 = 2 * e4, n2 = this.aspect * r3, i3 = -0.5 * n2, a3 = this.view;
          if (this.view !== null && this.view.enabled) {
            var o5 = a3.fullWidth, c3 = a3.fullHeight;
            i3 += a3.offsetX * n2 / o5, e4 -= a3.offsetY * r3 / c3, n2 *= a3.width / o5, r3 *= a3.height / c3;
          }
          var l4 = this.filmOffset;
          l4 !== 0 && (i3 += t3 * l4 / this.getFilmWidth()), this.projectionMatrix.makePerspective(i3, i3 + n2, e4, e4 - r3, t3, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        }, toJSON: function(t3) {
          var e4 = Y.prototype.toJSON.call(this, t3);
          return e4.object.fov = this.fov, e4.object.zoom = this.zoom, e4.object.near = this.near, e4.object.far = this.far, e4.object.focus = this.focus, e4.object.aspect = this.aspect, this.view !== null && (e4.object.view = Object.assign({}, this.view)), e4.object.filmGauge = this.filmGauge, e4.object.filmOffset = this.filmOffset, e4;
        } }), He.prototype = Object.create(Y.prototype), He.prototype.constructor = He, Ve.prototype = Object.create(b2.prototype), Ve.prototype.constructor = Ve, Ve.prototype.isWebGLRenderTargetCube = true, Ve.prototype.fromEquirectangularTexture = function(t3, e4) {
          this.texture.type = e4.type, this.texture.format = e4.format, this.texture.encoding = e4.encoding;
          var r3 = new J(), n2 = { uniforms: { tEquirect: { value: null } }, vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "	vWorldDirection = transformDirection( position, modelMatrix );", "	#include <begin_vertex>", "	#include <project_vertex>", "}"].join("\n"), fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "	vec3 direction = normalize( vWorldDirection );", "	vec2 sampleUV;", "	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;", "	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "	gl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n") }, i3 = new Fe({ type: "CubemapFromEquirect", uniforms: Ie(n2.uniforms), vertexShader: n2.vertexShader, fragmentShader: n2.fragmentShader, side: 1, blending: 0 });
          i3.uniforms.tEquirect.value = e4;
          var a3 = new Te(new Ne(5, 5, 5), i3);
          r3.add(a3);
          var o5 = new He(1, 10, 1);
          return o5.renderTarget = this, o5.renderTarget.texture.name = "CubeCameraTexture", o5.update(t3, r3), a3.geometry.dispose(), a3.material.dispose(), this;
        }, je.prototype = Object.create(y2.prototype), je.prototype.constructor = je, je.prototype.isDataTexture = true;
        var ke = new d2(), We = new d2(), qe = new m2();
        function Xe(t3, e4) {
          this.normal = t3 !== void 0 ? t3 : new d2(1, 0, 0), this.constant = e4 !== void 0 ? e4 : 0;
        }
        Object.assign(Xe.prototype, { isPlane: true, set: function(t3, e4) {
          return this.normal.copy(t3), this.constant = e4, this;
        }, setComponents: function(t3, e4, r3, n2) {
          return this.normal.set(t3, e4, r3), this.constant = n2, this;
        }, setFromNormalAndCoplanarPoint: function(t3, e4) {
          return this.normal.copy(t3), this.constant = -e4.dot(this.normal), this;
        }, setFromCoplanarPoints: function(t3, e4, r3) {
          var n2 = ke.subVectors(r3, e4).cross(We.subVectors(t3, e4)).normalize();
          return this.setFromNormalAndCoplanarPoint(n2, t3), this;
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          return this.normal.copy(t3.normal), this.constant = t3.constant, this;
        }, normalize: function() {
          var t3 = 1 / this.normal.length();
          return this.normal.multiplyScalar(t3), this.constant *= t3, this;
        }, negate: function() {
          return this.constant *= -1, this.normal.negate(), this;
        }, distanceToPoint: function(t3) {
          return this.normal.dot(t3) + this.constant;
        }, distanceToSphere: function(t3) {
          return this.distanceToPoint(t3.center) - t3.radius;
        }, projectPoint: function(t3, e4) {
          return e4 === void 0 && (console.warn("THREE.Plane: .projectPoint() target is now required"), e4 = new d2()), e4.copy(this.normal).multiplyScalar(-this.distanceToPoint(t3)).add(t3);
        }, intersectLine: function(t3, e4) {
          e4 === void 0 && (console.warn("THREE.Plane: .intersectLine() target is now required"), e4 = new d2());
          var r3 = t3.delta(ke), n2 = this.normal.dot(r3);
          if (n2 === 0)
            return this.distanceToPoint(t3.start) === 0 ? e4.copy(t3.start) : void 0;
          var i3 = -(t3.start.dot(this.normal) + this.constant) / n2;
          return i3 < 0 || i3 > 1 ? void 0 : e4.copy(r3).multiplyScalar(i3).add(t3.start);
        }, intersectsLine: function(t3) {
          var e4 = this.distanceToPoint(t3.start), r3 = this.distanceToPoint(t3.end);
          return e4 < 0 && r3 > 0 || r3 < 0 && e4 > 0;
        }, intersectsBox: function(t3) {
          return t3.intersectsPlane(this);
        }, intersectsSphere: function(t3) {
          return t3.intersectsPlane(this);
        }, coplanarPoint: function(t3) {
          return t3 === void 0 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t3 = new d2()), t3.copy(this.normal).multiplyScalar(-this.constant);
        }, applyMatrix4: function(t3, e4) {
          var r3 = e4 || qe.getNormalMatrix(t3), n2 = this.coplanarPoint(ke).applyMatrix4(t3), i3 = this.normal.applyMatrix3(r3).normalize();
          return this.constant = -n2.dot(i3), this;
        }, translate: function(t3) {
          return this.constant -= t3.dot(this.normal), this;
        }, equals: function(t3) {
          return t3.normal.equals(this.normal) && t3.constant === this.constant;
        } });
        var Ye = new ut(), Je = new d2();
        function Ze(t3, e4, r3, n2, i3, a3) {
          this.planes = [t3 !== void 0 ? t3 : new Xe(), e4 !== void 0 ? e4 : new Xe(), r3 !== void 0 ? r3 : new Xe(), n2 !== void 0 ? n2 : new Xe(), i3 !== void 0 ? i3 : new Xe(), a3 !== void 0 ? a3 : new Xe()];
        }
        Object.assign(Ze.prototype, { set: function(t3, e4, r3, n2, i3, a3) {
          var o5 = this.planes;
          return o5[0].copy(t3), o5[1].copy(e4), o5[2].copy(r3), o5[3].copy(n2), o5[4].copy(i3), o5[5].copy(a3), this;
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          for (var e4 = this.planes, r3 = 0; r3 < 6; r3++)
            e4[r3].copy(t3.planes[r3]);
          return this;
        }, setFromMatrix: function(t3) {
          var e4 = this.planes, r3 = t3.elements, n2 = r3[0], i3 = r3[1], a3 = r3[2], o5 = r3[3], s4 = r3[4], c3 = r3[5], l4 = r3[6], h3 = r3[7], u3 = r3[8], p3 = r3[9], d3 = r3[10], f3 = r3[11], m3 = r3[12], g3 = r3[13], v3 = r3[14], y3 = r3[15];
          return e4[0].setComponents(o5 - n2, h3 - s4, f3 - u3, y3 - m3).normalize(), e4[1].setComponents(o5 + n2, h3 + s4, f3 + u3, y3 + m3).normalize(), e4[2].setComponents(o5 + i3, h3 + c3, f3 + p3, y3 + g3).normalize(), e4[3].setComponents(o5 - i3, h3 - c3, f3 - p3, y3 - g3).normalize(), e4[4].setComponents(o5 - a3, h3 - l4, f3 - d3, y3 - v3).normalize(), e4[5].setComponents(o5 + a3, h3 + l4, f3 + d3, y3 + v3).normalize(), this;
        }, intersectsObject: function(t3) {
          var e4 = t3.geometry;
          return e4.boundingSphere === null && e4.computeBoundingSphere(), Ye.copy(e4.boundingSphere).applyMatrix4(t3.matrixWorld), this.intersectsSphere(Ye);
        }, intersectsSprite: function(t3) {
          return Ye.center.set(0, 0, 0), Ye.radius = 0.7071067811865476, Ye.applyMatrix4(t3.matrixWorld), this.intersectsSphere(Ye);
        }, intersectsSphere: function(t3) {
          for (var e4 = this.planes, r3 = t3.center, n2 = -t3.radius, i3 = 0; i3 < 6; i3++)
            if (e4[i3].distanceToPoint(r3) < n2)
              return false;
          return true;
        }, intersectsBox: function(t3) {
          for (var e4 = this.planes, r3 = 0; r3 < 6; r3++) {
            var n2 = e4[r3];
            if (Je.x = n2.normal.x > 0 ? t3.max.x : t3.min.x, Je.y = n2.normal.y > 0 ? t3.max.y : t3.min.y, Je.z = n2.normal.z > 0 ? t3.max.z : t3.min.z, n2.distanceToPoint(Je) < 0)
              return false;
          }
          return true;
        }, containsPoint: function(t3) {
          for (var e4 = this.planes, r3 = 0; r3 < 6; r3++)
            if (e4[r3].distanceToPoint(t3) < 0)
              return false;
          return true;
        } });
        var Qe = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE  = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS  = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha  = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n	varying vec3 vViewPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n	vViewPosition = - mvPosition.xyz;\n#endif", color_fragment: "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = normalMatrix * objectTangent;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = min( floor( D ) / 255.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		reflectVec = normalize( reflectVec );\n		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		reflectVec = normalize( reflectVec );\n		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n		  vec3 reflectVec = reflect( -viewDir, normal );\n		  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n		  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	fogDepth = -mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef TOON\n	uniform sampler2D gradientMap;\n	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n		float dotNL = dot( normal, lightDirection );\n		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n		#ifdef USE_GRADIENTMAP\n			return texture2D( gradientMap, coord ).rgb;\n		#else\n			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n		#endif\n	}\n#endif", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif", lights_pars_begin: "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n		float shadowCameraNear;\n		float shadowCameraFar;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifdef TOON\n		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#else\n		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n		vec3 irradiance = dotNL * directLight.color;\n	#endif\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = saturate( clearcoat );	material.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n		gl_Position.z *= gl_Position.w;\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#ifdef USE_MAP\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif", map_particle_pars_fragment: "#ifdef USE_MAP\n	uniform mat3 uvTransform;\n	uniform sampler2D map;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif", normal_fragment_begin: "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	#ifdef USE_TANGENT\n		mat3 vTBN = mat3( tangent, bitangent, normal );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, normalScale, normalMap );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, in sampler2D normalMap ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		float scale = sign( st1.t * st0.s - st0.t * st1.s );\n		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy *= normalScale;\n		#ifdef DOUBLE_SIDED\n			vec3 NfromST = cross( S, T );\n			if( dot( NfromST, N ) > 0.0 ) {\n				S *= -1.0;\n				T *= -1.0;\n			}\n		#else\n			mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = clearcoatNormalScale * mapN.xy;\n		clearcoatNormal = normalize( vTBN * mapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatNormalScale, clearcoatNormalMap );\n	#endif\n#endif", clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 encodeHalfRGBA ( vec2 v ) {\n	vec4 encoded = vec4( 0.0 );\n	const vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n	encoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n	encoded.xy = encoded.xy - ( encoded.yy * offset );\n	encoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n	encoded.zw = encoded.zw - ( encoded.ww * offset );\n	return encoded;\n}\nvec2 decodeHalfRGBA( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return decodeHalfRGBA( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n	#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}", uv_pars_fragment: "#ifdef USE_UV\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = mapTexelToLinear( texColor );\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV;\n	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n	uniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSPARENCY\n		diffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <fog_fragment>\n}", shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}" }, Ke = { common: { diffuse: { value: new Nt(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new m2() }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new l3(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Nt(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new Nt(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, uvTransform: { value: new m2() } }, sprite: { diffuse: { value: new Nt(15658734) }, opacity: { value: 1 }, center: { value: new l3(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, uvTransform: { value: new m2() } } }, $e = { basic: { uniforms: ze([Ke.common, Ke.specularmap, Ke.envmap, Ke.aomap, Ke.lightmap, Ke.fog]), vertexShader: Qe.meshbasic_vert, fragmentShader: Qe.meshbasic_frag }, lambert: { uniforms: ze([Ke.common, Ke.specularmap, Ke.envmap, Ke.aomap, Ke.lightmap, Ke.emissivemap, Ke.fog, Ke.lights, { emissive: { value: new Nt(0) } }]), vertexShader: Qe.meshlambert_vert, fragmentShader: Qe.meshlambert_frag }, phong: { uniforms: ze([Ke.common, Ke.specularmap, Ke.envmap, Ke.aomap, Ke.lightmap, Ke.emissivemap, Ke.bumpmap, Ke.normalmap, Ke.displacementmap, Ke.gradientmap, Ke.fog, Ke.lights, { emissive: { value: new Nt(0) }, specular: { value: new Nt(1118481) }, shininess: { value: 30 } }]), vertexShader: Qe.meshphong_vert, fragmentShader: Qe.meshphong_frag }, standard: { uniforms: ze([Ke.common, Ke.envmap, Ke.aomap, Ke.lightmap, Ke.emissivemap, Ke.bumpmap, Ke.normalmap, Ke.displacementmap, Ke.roughnessmap, Ke.metalnessmap, Ke.fog, Ke.lights, { emissive: { value: new Nt(0) }, roughness: { value: 0.5 }, metalness: { value: 0.5 }, envMapIntensity: { value: 1 } }]), vertexShader: Qe.meshphysical_vert, fragmentShader: Qe.meshphysical_frag }, matcap: { uniforms: ze([Ke.common, Ke.bumpmap, Ke.normalmap, Ke.displacementmap, Ke.fog, { matcap: { value: null } }]), vertexShader: Qe.meshmatcap_vert, fragmentShader: Qe.meshmatcap_frag }, points: { uniforms: ze([Ke.points, Ke.fog]), vertexShader: Qe.points_vert, fragmentShader: Qe.points_frag }, dashed: { uniforms: ze([Ke.common, Ke.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Qe.linedashed_vert, fragmentShader: Qe.linedashed_frag }, depth: { uniforms: ze([Ke.common, Ke.displacementmap]), vertexShader: Qe.depth_vert, fragmentShader: Qe.depth_frag }, normal: { uniforms: ze([Ke.common, Ke.bumpmap, Ke.normalmap, Ke.displacementmap, { opacity: { value: 1 } }]), vertexShader: Qe.normal_vert, fragmentShader: Qe.normal_frag }, sprite: { uniforms: ze([Ke.sprite, Ke.fog]), vertexShader: Qe.sprite_vert, fragmentShader: Qe.sprite_frag }, background: { uniforms: { uvTransform: { value: new m2() }, t2D: { value: null } }, vertexShader: Qe.background_vert, fragmentShader: Qe.background_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Qe.cube_vert, fragmentShader: Qe.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Qe.equirect_vert, fragmentShader: Qe.equirect_frag }, distanceRGBA: { uniforms: ze([Ke.common, Ke.displacementmap, { referencePosition: { value: new d2() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Qe.distanceRGBA_vert, fragmentShader: Qe.distanceRGBA_frag }, shadow: { uniforms: ze([Ke.lights, Ke.fog, { color: { value: new Nt(0) }, opacity: { value: 1 } }]), vertexShader: Qe.shadow_vert, fragmentShader: Qe.shadow_frag } };
        function tr() {
          var t3 = null, e4 = false, r3 = null;
          function n2(i3, a3) {
            e4 !== false && (r3(i3, a3), t3.requestAnimationFrame(n2));
          }
          return { start: function() {
            e4 !== true && r3 !== null && (t3.requestAnimationFrame(n2), e4 = true);
          }, stop: function() {
            e4 = false;
          }, setAnimationLoop: function(t4) {
            r3 = t4;
          }, setContext: function(e5) {
            t3 = e5;
          } };
        }
        function er(t3) {
          var e4 = /* @__PURE__ */ new WeakMap();
          return { get: function(t4) {
            return t4.isInterleavedBufferAttribute && (t4 = t4.data), e4.get(t4);
          }, remove: function(r3) {
            r3.isInterleavedBufferAttribute && (r3 = r3.data);
            var n2 = e4.get(r3);
            n2 && (t3.deleteBuffer(n2.buffer), e4.delete(r3));
          }, update: function(r3, n2) {
            r3.isInterleavedBufferAttribute && (r3 = r3.data);
            var i3 = e4.get(r3);
            i3 === void 0 ? e4.set(r3, function(e5, r4) {
              var n3 = e5.array, i4 = e5.dynamic ? 35048 : 35044, a3 = t3.createBuffer();
              t3.bindBuffer(r4, a3), t3.bufferData(r4, n3, i4), e5.onUploadCallback();
              var o5 = 5126;
              return n3 instanceof Float32Array ? o5 = 5126 : n3 instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n3 instanceof Uint16Array ? o5 = 5123 : n3 instanceof Int16Array ? o5 = 5122 : n3 instanceof Uint32Array ? o5 = 5125 : n3 instanceof Int32Array ? o5 = 5124 : n3 instanceof Int8Array ? o5 = 5120 : n3 instanceof Uint8Array && (o5 = 5121), { buffer: a3, type: o5, bytesPerElement: n3.BYTES_PER_ELEMENT, version: e5.version };
            }(r3, n2)) : i3.version < r3.version && (function(e5, r4, n3) {
              var i4 = r4.array, a3 = r4.updateRange;
              t3.bindBuffer(n3, e5), r4.dynamic === false ? t3.bufferData(n3, i4, 35044) : a3.count === -1 ? t3.bufferSubData(n3, 0, i4) : a3.count === 0 ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t3.bufferSubData(n3, a3.offset * i4.BYTES_PER_ELEMENT, i4.subarray(a3.offset, a3.offset + a3.count)), a3.count = -1);
            }(i3.buffer, r3, n2), i3.version = r3.version);
          } };
        }
        function rr(t3, e4, r3, n2) {
          Oe.call(this), this.type = "PlaneGeometry", this.parameters = { width: t3, height: e4, widthSegments: r3, heightSegments: n2 }, this.fromBufferGeometry(new nr(t3, e4, r3, n2)), this.mergeVertices();
        }
        function nr(t3, e4, r3, n2) {
          se.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: t3, height: e4, widthSegments: r3, heightSegments: n2 };
          var i3, a3, o5 = (t3 = t3 || 1) / 2, s4 = (e4 = e4 || 1) / 2, c3 = Math.floor(r3) || 1, l4 = Math.floor(n2) || 1, h3 = c3 + 1, u3 = l4 + 1, p3 = t3 / c3, d3 = e4 / l4, f3 = [], m3 = [], g3 = [], v3 = [];
          for (a3 = 0; a3 < u3; a3++) {
            var y3 = a3 * d3 - s4;
            for (i3 = 0; i3 < h3; i3++) {
              var x3 = i3 * p3 - o5;
              m3.push(x3, -y3, 0), g3.push(0, 0, 1), v3.push(i3 / c3), v3.push(1 - a3 / l4);
            }
          }
          for (a3 = 0; a3 < l4; a3++)
            for (i3 = 0; i3 < c3; i3++) {
              var b3 = i3 + h3 * a3, w3 = i3 + h3 * (a3 + 1), _3 = i3 + 1 + h3 * (a3 + 1), M3 = i3 + 1 + h3 * a3;
              f3.push(b3, w3, M3), f3.push(w3, _3, M3);
            }
          this.setIndex(f3), this.addAttribute("position", new Zt(m3, 3)), this.addAttribute("normal", new Zt(g3, 3)), this.addAttribute("uv", new Zt(v3, 2));
        }
        function ir(t3, e4, r3, n2) {
          var i3, a3, o5 = new Nt(0), s4 = 0, c3 = null, l4 = 0;
          function h3(t4, r4) {
            e4.buffers.color.setClear(t4.r, t4.g, t4.b, r4, n2);
          }
          return { getClearColor: function() {
            return o5;
          }, setClearColor: function(t4, e5) {
            o5.set(t4), h3(o5, s4 = e5 !== void 0 ? e5 : 1);
          }, getClearAlpha: function() {
            return s4;
          }, setClearAlpha: function(t4) {
            h3(o5, s4 = t4);
          }, render: function(e5, n3, u3, p3) {
            var d3 = n3.background, f3 = t3.vr, m3 = f3.getSession && f3.getSession();
            if (m3 && m3.environmentBlendMode === "additive" && (d3 = null), d3 === null ? (h3(o5, s4), c3 = null, l4 = 0) : d3 && d3.isColor && (h3(d3, 1), p3 = true, c3 = null, l4 = 0), (t3.autoClear || p3) && t3.clear(t3.autoClearColor, t3.autoClearDepth, t3.autoClearStencil), d3 && (d3.isCubeTexture || d3.isWebGLRenderTargetCube)) {
              a3 === void 0 && ((a3 = new Te(new Ne(1, 1, 1), new Fe({ type: "BackgroundCubeMaterial", uniforms: Ie($e.cube.uniforms), vertexShader: $e.cube.vertexShader, fragmentShader: $e.cube.fragmentShader, side: 1, depthTest: false, depthWrite: false, fog: false }))).geometry.removeAttribute("normal"), a3.geometry.removeAttribute("uv"), a3.onBeforeRender = function(t4, e6, r4) {
                this.matrixWorld.copyPosition(r4.matrixWorld);
              }, Object.defineProperty(a3.material, "map", { get: function() {
                return this.uniforms.tCube.value;
              } }), r3.update(a3));
              var g3 = d3.isWebGLRenderTargetCube ? d3.texture : d3;
              a3.material.uniforms.tCube.value = g3, a3.material.uniforms.tFlip.value = d3.isWebGLRenderTargetCube ? 1 : -1, c3 === d3 && l4 === g3.version || (a3.material.needsUpdate = true, c3 = d3, l4 = g3.version), e5.unshift(a3, a3.geometry, a3.material, 0, 0, null);
            } else
              d3 && d3.isTexture && (i3 === void 0 && ((i3 = new Te(new nr(2, 2), new Fe({ type: "BackgroundMaterial", uniforms: Ie($e.background.uniforms), vertexShader: $e.background.vertexShader, fragmentShader: $e.background.fragmentShader, side: 0, depthTest: false, depthWrite: false, fog: false }))).geometry.removeAttribute("normal"), Object.defineProperty(i3.material, "map", { get: function() {
                return this.uniforms.t2D.value;
              } }), r3.update(i3)), i3.material.uniforms.t2D.value = d3, d3.matrixAutoUpdate === true && d3.updateMatrix(), i3.material.uniforms.uvTransform.value.copy(d3.matrix), c3 === d3 && l4 === d3.version || (i3.material.needsUpdate = true, c3 = d3, l4 = d3.version), e5.unshift(i3, i3.geometry, i3.material, 0, 0, null));
          } };
        }
        function ar(t3, e4, r3, n2) {
          var i3;
          this.setMode = function(t4) {
            i3 = t4;
          }, this.render = function(e5, n3) {
            t3.drawArrays(i3, e5, n3), r3.update(n3, i3);
          }, this.renderInstances = function(a3, o5, s4) {
            var c3, l4;
            if (n2.isWebGL2)
              c3 = t3, l4 = "drawArraysInstanced";
            else if (l4 = "drawArraysInstancedANGLE", (c3 = e4.get("ANGLE_instanced_arrays")) === null)
              return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            c3[l4](i3, o5, s4, a3.maxInstancedCount), r3.update(s4, i3, a3.maxInstancedCount);
          };
        }
        function or(t3, e4, r3) {
          var n2;
          function i3(e5) {
            if (e5 === "highp") {
              if (t3.getShaderPrecisionFormat(35633, 36338).precision > 0 && t3.getShaderPrecisionFormat(35632, 36338).precision > 0)
                return "highp";
              e5 = "mediump";
            }
            return e5 === "mediump" && t3.getShaderPrecisionFormat(35633, 36337).precision > 0 && t3.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
          }
          var a3 = typeof WebGL2RenderingContext != "undefined" && t3 instanceof WebGL2RenderingContext, o5 = r3.precision !== void 0 ? r3.precision : "highp", s4 = i3(o5);
          s4 !== o5 && (console.warn("THREE.WebGLRenderer:", o5, "not supported, using", s4, "instead."), o5 = s4);
          var c3 = r3.logarithmicDepthBuffer === true, l4 = t3.getParameter(34930), h3 = t3.getParameter(35660), u3 = t3.getParameter(3379), p3 = t3.getParameter(34076), d3 = t3.getParameter(34921), f3 = t3.getParameter(36347), m3 = t3.getParameter(36348), g3 = t3.getParameter(36349), v3 = h3 > 0, y3 = a3 || !!e4.get("OES_texture_float");
          return { isWebGL2: a3, getMaxAnisotropy: function() {
            if (n2 !== void 0)
              return n2;
            var r4 = e4.get("EXT_texture_filter_anisotropic");
            return n2 = r4 !== null ? t3.getParameter(r4.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
          }, getMaxPrecision: i3, precision: o5, logarithmicDepthBuffer: c3, maxTextures: l4, maxVertexTextures: h3, maxTextureSize: u3, maxCubemapSize: p3, maxAttributes: d3, maxVertexUniforms: f3, maxVaryings: m3, maxFragmentUniforms: g3, vertexTextures: v3, floatFragmentTextures: y3, floatVertexTextures: v3 && y3, maxSamples: a3 ? t3.getParameter(36183) : 0 };
        }
        function sr() {
          var t3 = this, e4 = null, r3 = 0, n2 = false, i3 = false, a3 = new Xe(), o5 = new m2(), s4 = { value: null, needsUpdate: false };
          function c3() {
            s4.value !== e4 && (s4.value = e4, s4.needsUpdate = r3 > 0), t3.numPlanes = r3, t3.numIntersection = 0;
          }
          function l4(e5, r4, n3, i4) {
            var c4 = e5 !== null ? e5.length : 0, l5 = null;
            if (c4 !== 0) {
              if (l5 = s4.value, i4 !== true || l5 === null) {
                var h3 = n3 + 4 * c4, u3 = r4.matrixWorldInverse;
                o5.getNormalMatrix(u3), (l5 === null || l5.length < h3) && (l5 = new Float32Array(h3));
                for (var p3 = 0, d3 = n3; p3 !== c4; ++p3, d3 += 4)
                  a3.copy(e5[p3]).applyMatrix4(u3, o5), a3.normal.toArray(l5, d3), l5[d3 + 3] = a3.constant;
              }
              s4.value = l5, s4.needsUpdate = true;
            }
            return t3.numPlanes = c4, l5;
          }
          this.uniform = s4, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t4, i4, a4) {
            var o6 = t4.length !== 0 || i4 || r3 !== 0 || n2;
            return n2 = i4, e4 = l4(t4, a4, 0), r3 = t4.length, o6;
          }, this.beginShadows = function() {
            i3 = true, l4(null);
          }, this.endShadows = function() {
            i3 = false, c3();
          }, this.setState = function(t4, a4, o6, h3, u3, p3) {
            if (!n2 || t4 === null || t4.length === 0 || i3 && !o6)
              i3 ? l4(null) : c3();
            else {
              var d3 = i3 ? 0 : r3, f3 = 4 * d3, m3 = u3.clippingState || null;
              s4.value = m3, m3 = l4(t4, h3, f3, p3);
              for (var g3 = 0; g3 !== f3; ++g3)
                m3[g3] = e4[g3];
              u3.clippingState = m3, this.numIntersection = a4 ? this.numPlanes : 0, this.numPlanes += d3;
            }
          };
        }
        function cr(t3) {
          var e4 = {};
          return { get: function(r3) {
            if (e4[r3] !== void 0)
              return e4[r3];
            var n2;
            switch (r3) {
              case "WEBGL_depth_texture":
                n2 = t3.getExtension("WEBGL_depth_texture") || t3.getExtension("MOZ_WEBGL_depth_texture") || t3.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
              case "EXT_texture_filter_anisotropic":
                n2 = t3.getExtension("EXT_texture_filter_anisotropic") || t3.getExtension("MOZ_EXT_texture_filter_anisotropic") || t3.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
              case "WEBGL_compressed_texture_s3tc":
                n2 = t3.getExtension("WEBGL_compressed_texture_s3tc") || t3.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t3.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
              case "WEBGL_compressed_texture_pvrtc":
                n2 = t3.getExtension("WEBGL_compressed_texture_pvrtc") || t3.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
              default:
                n2 = t3.getExtension(r3);
            }
            return n2 === null && console.warn("THREE.WebGLRenderer: " + r3 + " extension not supported."), e4[r3] = n2, n2;
          } };
        }
        function lr(t3, e4, r3) {
          var n2 = /* @__PURE__ */ new WeakMap(), i3 = /* @__PURE__ */ new WeakMap();
          function a3(t4) {
            var o6 = t4.target, s4 = n2.get(o6);
            for (var c3 in s4.index !== null && e4.remove(s4.index), s4.attributes)
              e4.remove(s4.attributes[c3]);
            o6.removeEventListener("dispose", a3), n2.delete(o6);
            var l4 = i3.get(s4);
            l4 && (e4.remove(l4), i3.delete(s4)), r3.memory.geometries--;
          }
          function o5(t4) {
            var r4 = [], n3 = t4.index, a4 = t4.attributes.position, o6 = 0;
            if (n3 !== null) {
              var s4 = n3.array;
              o6 = n3.version;
              for (var c3 = 0, l4 = s4.length; c3 < l4; c3 += 3) {
                var h3 = s4[c3 + 0], u3 = s4[c3 + 1], p3 = s4[c3 + 2];
                r4.push(h3, u3, u3, p3, p3, h3);
              }
            } else
              for (s4 = a4.array, o6 = a4.version, c3 = 0, l4 = s4.length / 3 - 1; c3 < l4; c3 += 3)
                h3 = c3 + 0, u3 = c3 + 1, p3 = c3 + 2, r4.push(h3, u3, u3, p3, p3, h3);
            var d3 = new ($t(r4) > 65535 ? Jt : Xt)(r4, 1);
            d3.version = o6, e4.update(d3, 34963);
            var f3 = i3.get(t4);
            f3 && e4.remove(f3), i3.set(t4, d3);
          }
          return { get: function(t4, e5) {
            var i4 = n2.get(e5);
            return i4 || (e5.addEventListener("dispose", a3), e5.isBufferGeometry ? i4 = e5 : e5.isGeometry && (e5._bufferGeometry === void 0 && (e5._bufferGeometry = new se().setFromObject(t4)), i4 = e5._bufferGeometry), n2.set(e5, i4), r3.memory.geometries++, i4);
          }, update: function(t4) {
            var r4 = t4.index, n3 = t4.attributes;
            for (var i4 in r4 !== null && e4.update(r4, 34963), n3)
              e4.update(n3[i4], 34962);
            var a4 = t4.morphAttributes;
            for (var i4 in a4)
              for (var o6 = a4[i4], s4 = 0, c3 = o6.length; s4 < c3; s4++)
                e4.update(o6[s4], 34962);
          }, getWireframeAttribute: function(t4) {
            var e5 = i3.get(t4);
            if (e5) {
              var r4 = t4.index;
              r4 !== null && e5.version < r4.version && o5(t4);
            } else
              o5(t4);
            return i3.get(t4);
          } };
        }
        function hr(t3, e4, r3, n2) {
          var i3, a3, o5;
          this.setMode = function(t4) {
            i3 = t4;
          }, this.setIndex = function(t4) {
            a3 = t4.type, o5 = t4.bytesPerElement;
          }, this.render = function(e5, n3) {
            t3.drawElements(i3, n3, a3, e5 * o5), r3.update(n3, i3);
          }, this.renderInstances = function(s4, c3, l4) {
            var h3, u3;
            if (n2.isWebGL2)
              h3 = t3, u3 = "drawElementsInstanced";
            else if (u3 = "drawElementsInstancedANGLE", (h3 = e4.get("ANGLE_instanced_arrays")) === null)
              return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            h3[u3](i3, l4, a3, c3 * o5, s4.maxInstancedCount), r3.update(l4, i3, s4.maxInstancedCount);
          };
        }
        function ur(t3) {
          var e4 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
          return { memory: { geometries: 0, textures: 0 }, render: e4, programs: null, autoReset: true, reset: function() {
            e4.frame++, e4.calls = 0, e4.triangles = 0, e4.points = 0, e4.lines = 0;
          }, update: function(t4, r3, n2) {
            switch (n2 = n2 || 1, e4.calls++, r3) {
              case 4:
                e4.triangles += n2 * (t4 / 3);
                break;
              case 5:
              case 6:
                e4.triangles += n2 * (t4 - 2);
                break;
              case 1:
                e4.lines += n2 * (t4 / 2);
                break;
              case 3:
                e4.lines += n2 * (t4 - 1);
                break;
              case 2:
                e4.lines += n2 * t4;
                break;
              case 0:
                e4.points += n2 * t4;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", r3);
            }
          } };
        }
        function pr(t3, e4) {
          return Math.abs(e4[1]) - Math.abs(t3[1]);
        }
        function dr(t3) {
          var e4 = {}, r3 = new Float32Array(8);
          return { update: function(n2, i3, a3, o5) {
            var s4 = n2.morphTargetInfluences, c3 = s4.length, l4 = e4[i3.id];
            if (l4 === void 0) {
              l4 = [];
              for (var h3 = 0; h3 < c3; h3++)
                l4[h3] = [h3, 0];
              e4[i3.id] = l4;
            }
            var u3 = a3.morphTargets && i3.morphAttributes.position, p3 = a3.morphNormals && i3.morphAttributes.normal;
            for (h3 = 0; h3 < c3; h3++)
              (d3 = l4[h3])[1] !== 0 && (u3 && i3.removeAttribute("morphTarget" + h3), p3 && i3.removeAttribute("morphNormal" + h3));
            for (h3 = 0; h3 < c3; h3++)
              (d3 = l4[h3])[0] = h3, d3[1] = s4[h3];
            for (l4.sort(pr), h3 = 0; h3 < 8; h3++) {
              var d3;
              if (d3 = l4[h3]) {
                var f3 = d3[0], m3 = d3[1];
                if (m3) {
                  u3 && i3.addAttribute("morphTarget" + h3, u3[f3]), p3 && i3.addAttribute("morphNormal" + h3, p3[f3]), r3[h3] = m3;
                  continue;
                }
              }
              r3[h3] = 0;
            }
            o5.getUniforms().setValue(t3, "morphTargetInfluences", r3);
          } };
        }
        function fr(t3, e4) {
          var r3 = {};
          return { update: function(n2) {
            var i3 = e4.render.frame, a3 = n2.geometry, o5 = t3.get(n2, a3);
            return r3[o5.id] !== i3 && (a3.isGeometry && o5.updateFromObject(n2), t3.update(o5), r3[o5.id] = i3), o5;
          }, dispose: function() {
            r3 = {};
          } };
        }
        function mr(t3, e4, r3, n2, i3, a3, o5, s4, c3, l4) {
          t3 = t3 !== void 0 ? t3 : [], e4 = e4 !== void 0 ? e4 : 301, o5 = o5 !== void 0 ? o5 : 1022, y2.call(this, t3, e4, r3, n2, i3, a3, o5, s4, c3, l4), this.flipY = false;
        }
        function gr(t3, e4, r3, n2) {
          y2.call(this, null), this.image = { data: t3, width: e4, height: r3, depth: n2 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false;
        }
        function vr(t3, e4, r3, n2) {
          y2.call(this, null), this.image = { data: t3, width: e4, height: r3, depth: n2 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false;
        }
        $e.physical = { uniforms: ze([$e.standard.uniforms, { transparency: { value: 0 }, clearcoat: { value: 0 }, clearcoatRoughness: { value: 0 }, sheen: { value: new Nt(0) }, clearcoatNormalScale: { value: new l3(1, 1) }, clearcoatNormalMap: { value: null } }]), vertexShader: Qe.meshphysical_vert, fragmentShader: Qe.meshphysical_frag }, rr.prototype = Object.create(Oe.prototype), rr.prototype.constructor = rr, nr.prototype = Object.create(se.prototype), nr.prototype.constructor = nr, mr.prototype = Object.create(y2.prototype), mr.prototype.constructor = mr, mr.prototype.isCubeTexture = true, Object.defineProperty(mr.prototype, "images", { get: function() {
          return this.image;
        }, set: function(t3) {
          this.image = t3;
        } }), gr.prototype = Object.create(y2.prototype), gr.prototype.constructor = gr, gr.prototype.isDataTexture2DArray = true, vr.prototype = Object.create(y2.prototype), vr.prototype.constructor = vr, vr.prototype.isDataTexture3D = true;
        var yr = new y2(), xr = new gr(), br = new vr(), wr = new mr(), _r = [], Mr = [], Sr = new Float32Array(16), Tr = new Float32Array(9), Er = new Float32Array(4);
        function Ar(t3, e4, r3) {
          var n2 = t3[0];
          if (n2 <= 0 || n2 > 0)
            return t3;
          var i3 = e4 * r3, a3 = _r[i3];
          if (a3 === void 0 && (a3 = new Float32Array(i3), _r[i3] = a3), e4 !== 0) {
            n2.toArray(a3, 0);
            for (var o5 = 1, s4 = 0; o5 !== e4; ++o5)
              s4 += r3, t3[o5].toArray(a3, s4);
          }
          return a3;
        }
        function Lr(t3, e4) {
          if (t3.length !== e4.length)
            return false;
          for (var r3 = 0, n2 = t3.length; r3 < n2; r3++)
            if (t3[r3] !== e4[r3])
              return false;
          return true;
        }
        function Rr(t3, e4) {
          for (var r3 = 0, n2 = e4.length; r3 < n2; r3++)
            t3[r3] = e4[r3];
        }
        function Pr(t3, e4) {
          var r3 = Mr[e4];
          r3 === void 0 && (r3 = new Int32Array(e4), Mr[e4] = r3);
          for (var n2 = 0; n2 !== e4; ++n2)
            r3[n2] = t3.allocateTextureUnit();
          return r3;
        }
        function Cr(t3, e4) {
          var r3 = this.cache;
          r3[0] !== e4 && (t3.uniform1f(this.addr, e4), r3[0] = e4);
        }
        function Or(t3, e4) {
          var r3 = this.cache;
          if (e4.x !== void 0)
            r3[0] === e4.x && r3[1] === e4.y || (t3.uniform2f(this.addr, e4.x, e4.y), r3[0] = e4.x, r3[1] = e4.y);
          else {
            if (Lr(r3, e4))
              return;
            t3.uniform2fv(this.addr, e4), Rr(r3, e4);
          }
        }
        function Dr(t3, e4) {
          var r3 = this.cache;
          if (e4.x !== void 0)
            r3[0] === e4.x && r3[1] === e4.y && r3[2] === e4.z || (t3.uniform3f(this.addr, e4.x, e4.y, e4.z), r3[0] = e4.x, r3[1] = e4.y, r3[2] = e4.z);
          else if (e4.r !== void 0)
            r3[0] === e4.r && r3[1] === e4.g && r3[2] === e4.b || (t3.uniform3f(this.addr, e4.r, e4.g, e4.b), r3[0] = e4.r, r3[1] = e4.g, r3[2] = e4.b);
          else {
            if (Lr(r3, e4))
              return;
            t3.uniform3fv(this.addr, e4), Rr(r3, e4);
          }
        }
        function Nr(t3, e4) {
          var r3 = this.cache;
          if (e4.x !== void 0)
            r3[0] === e4.x && r3[1] === e4.y && r3[2] === e4.z && r3[3] === e4.w || (t3.uniform4f(this.addr, e4.x, e4.y, e4.z, e4.w), r3[0] = e4.x, r3[1] = e4.y, r3[2] = e4.z, r3[3] = e4.w);
          else {
            if (Lr(r3, e4))
              return;
            t3.uniform4fv(this.addr, e4), Rr(r3, e4);
          }
        }
        function Ir(t3, e4) {
          var r3 = this.cache, n2 = e4.elements;
          if (n2 === void 0) {
            if (Lr(r3, e4))
              return;
            t3.uniformMatrix2fv(this.addr, false, e4), Rr(r3, e4);
          } else {
            if (Lr(r3, n2))
              return;
            Er.set(n2), t3.uniformMatrix2fv(this.addr, false, Er), Rr(r3, n2);
          }
        }
        function zr(t3, e4) {
          var r3 = this.cache, n2 = e4.elements;
          if (n2 === void 0) {
            if (Lr(r3, e4))
              return;
            t3.uniformMatrix3fv(this.addr, false, e4), Rr(r3, e4);
          } else {
            if (Lr(r3, n2))
              return;
            Tr.set(n2), t3.uniformMatrix3fv(this.addr, false, Tr), Rr(r3, n2);
          }
        }
        function Br(t3, e4) {
          var r3 = this.cache, n2 = e4.elements;
          if (n2 === void 0) {
            if (Lr(r3, e4))
              return;
            t3.uniformMatrix4fv(this.addr, false, e4), Rr(r3, e4);
          } else {
            if (Lr(r3, n2))
              return;
            Sr.set(n2), t3.uniformMatrix4fv(this.addr, false, Sr), Rr(r3, n2);
          }
        }
        function Fr(t3, e4, r3) {
          var n2 = this.cache, i3 = r3.allocateTextureUnit();
          n2[0] !== i3 && (t3.uniform1i(this.addr, i3), n2[0] = i3), r3.safeSetTexture2D(e4 || yr, i3);
        }
        function Gr(t3, e4, r3) {
          var n2 = this.cache, i3 = r3.allocateTextureUnit();
          n2[0] !== i3 && (t3.uniform1i(this.addr, i3), n2[0] = i3), r3.setTexture2DArray(e4 || xr, i3);
        }
        function Ur(t3, e4, r3) {
          var n2 = this.cache, i3 = r3.allocateTextureUnit();
          n2[0] !== i3 && (t3.uniform1i(this.addr, i3), n2[0] = i3), r3.setTexture3D(e4 || br, i3);
        }
        function Hr(t3, e4, r3) {
          var n2 = this.cache, i3 = r3.allocateTextureUnit();
          n2[0] !== i3 && (t3.uniform1i(this.addr, i3), n2[0] = i3), r3.safeSetTextureCube(e4 || wr, i3);
        }
        function Vr(t3, e4) {
          var r3 = this.cache;
          r3[0] !== e4 && (t3.uniform1i(this.addr, e4), r3[0] = e4);
        }
        function jr(t3, e4) {
          var r3 = this.cache;
          Lr(r3, e4) || (t3.uniform2iv(this.addr, e4), Rr(r3, e4));
        }
        function kr(t3, e4) {
          var r3 = this.cache;
          Lr(r3, e4) || (t3.uniform3iv(this.addr, e4), Rr(r3, e4));
        }
        function Wr(t3, e4) {
          var r3 = this.cache;
          Lr(r3, e4) || (t3.uniform4iv(this.addr, e4), Rr(r3, e4));
        }
        function qr(t3, e4) {
          t3.uniform1fv(this.addr, e4);
        }
        function Xr(t3, e4) {
          t3.uniform1iv(this.addr, e4);
        }
        function Yr(t3, e4) {
          t3.uniform2iv(this.addr, e4);
        }
        function Jr(t3, e4) {
          t3.uniform3iv(this.addr, e4);
        }
        function Zr(t3, e4) {
          t3.uniform4iv(this.addr, e4);
        }
        function Qr(t3, e4) {
          var r3 = Ar(e4, this.size, 2);
          t3.uniform2fv(this.addr, r3);
        }
        function Kr(t3, e4) {
          var r3 = Ar(e4, this.size, 3);
          t3.uniform3fv(this.addr, r3);
        }
        function $r(t3, e4) {
          var r3 = Ar(e4, this.size, 4);
          t3.uniform4fv(this.addr, r3);
        }
        function tn(t3, e4) {
          var r3 = Ar(e4, this.size, 4);
          t3.uniformMatrix2fv(this.addr, false, r3);
        }
        function en(t3, e4) {
          var r3 = Ar(e4, this.size, 9);
          t3.uniformMatrix3fv(this.addr, false, r3);
        }
        function rn(t3, e4) {
          var r3 = Ar(e4, this.size, 16);
          t3.uniformMatrix4fv(this.addr, false, r3);
        }
        function nn(t3, e4, r3) {
          var n2 = e4.length, i3 = Pr(r3, n2);
          t3.uniform1iv(this.addr, i3);
          for (var a3 = 0; a3 !== n2; ++a3)
            r3.safeSetTexture2D(e4[a3] || yr, i3[a3]);
        }
        function an(t3, e4, r3) {
          var n2 = e4.length, i3 = Pr(r3, n2);
          t3.uniform1iv(this.addr, i3);
          for (var a3 = 0; a3 !== n2; ++a3)
            r3.safeSetTextureCube(e4[a3] || wr, i3[a3]);
        }
        function on(t3, e4, r3) {
          this.id = t3, this.addr = r3, this.cache = [], this.setValue = function(t4) {
            switch (t4) {
              case 5126:
                return Cr;
              case 35664:
                return Or;
              case 35665:
                return Dr;
              case 35666:
                return Nr;
              case 35674:
                return Ir;
              case 35675:
                return zr;
              case 35676:
                return Br;
              case 35678:
              case 36198:
                return Fr;
              case 35679:
                return Ur;
              case 35680:
                return Hr;
              case 36289:
                return Gr;
              case 5124:
              case 35670:
                return Vr;
              case 35667:
              case 35671:
                return jr;
              case 35668:
              case 35672:
                return kr;
              case 35669:
              case 35673:
                return Wr;
            }
          }(e4.type);
        }
        function sn(t3, e4, r3) {
          this.id = t3, this.addr = r3, this.cache = [], this.size = e4.size, this.setValue = function(t4) {
            switch (t4) {
              case 5126:
                return qr;
              case 35664:
                return Qr;
              case 35665:
                return Kr;
              case 35666:
                return $r;
              case 35674:
                return tn;
              case 35675:
                return en;
              case 35676:
                return rn;
              case 35678:
                return nn;
              case 35680:
                return an;
              case 5124:
              case 35670:
                return Xr;
              case 35667:
              case 35671:
                return Yr;
              case 35668:
              case 35672:
                return Jr;
              case 35669:
              case 35673:
                return Zr;
            }
          }(e4.type);
        }
        function cn(t3) {
          this.id = t3, this.seq = [], this.map = {};
        }
        sn.prototype.updateCache = function(t3) {
          var e4 = this.cache;
          t3 instanceof Float32Array && e4.length !== t3.length && (this.cache = new Float32Array(t3.length)), Rr(e4, t3);
        }, cn.prototype.setValue = function(t3, e4, r3) {
          for (var n2 = this.seq, i3 = 0, a3 = n2.length; i3 !== a3; ++i3) {
            var o5 = n2[i3];
            o5.setValue(t3, e4[o5.id], r3);
          }
        };
        var ln = /([\w\d_]+)(\])?(\[|\.)?/g;
        function hn(t3, e4) {
          t3.seq.push(e4), t3.map[e4.id] = e4;
        }
        function un(t3, e4, r3) {
          var n2 = t3.name, i3 = n2.length;
          for (ln.lastIndex = 0; ; ) {
            var a3 = ln.exec(n2), o5 = ln.lastIndex, s4 = a3[1], c3 = a3[2] === "]", l4 = a3[3];
            if (c3 && (s4 |= 0), l4 === void 0 || l4 === "[" && o5 + 2 === i3) {
              hn(r3, l4 === void 0 ? new on(s4, t3, e4) : new sn(s4, t3, e4));
              break;
            }
            var h3 = r3.map[s4];
            h3 === void 0 && hn(r3, h3 = new cn(s4)), r3 = h3;
          }
        }
        function pn(t3, e4) {
          this.seq = [], this.map = {};
          for (var r3 = t3.getProgramParameter(e4, 35718), n2 = 0; n2 < r3; ++n2) {
            var i3 = t3.getActiveUniform(e4, n2);
            un(i3, t3.getUniformLocation(e4, i3.name), this);
          }
        }
        function dn(t3, e4, r3) {
          var n2 = t3.createShader(e4);
          return t3.shaderSource(n2, r3), t3.compileShader(n2), n2;
        }
        pn.prototype.setValue = function(t3, e4, r3, n2) {
          var i3 = this.map[e4];
          i3 !== void 0 && i3.setValue(t3, r3, n2);
        }, pn.prototype.setOptional = function(t3, e4, r3) {
          var n2 = e4[r3];
          n2 !== void 0 && this.setValue(t3, r3, n2);
        }, pn.upload = function(t3, e4, r3, n2) {
          for (var i3 = 0, a3 = e4.length; i3 !== a3; ++i3) {
            var o5 = e4[i3], s4 = r3[o5.id];
            s4.needsUpdate !== false && o5.setValue(t3, s4.value, n2);
          }
        }, pn.seqWithValue = function(t3, e4) {
          for (var r3 = [], n2 = 0, i3 = t3.length; n2 !== i3; ++n2) {
            var a3 = t3[n2];
            a3.id in e4 && r3.push(a3);
          }
          return r3;
        };
        var fn = 0;
        function mn(t3) {
          switch (t3) {
            case 3e3:
              return ["Linear", "( value )"];
            case 3001:
              return ["sRGB", "( value )"];
            case 3002:
              return ["RGBE", "( value )"];
            case 3004:
              return ["RGBM", "( value, 7.0 )"];
            case 3005:
              return ["RGBM", "( value, 16.0 )"];
            case 3006:
              return ["RGBD", "( value, 256.0 )"];
            case 3007:
              return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case 3003:
              return ["LogLuv", "( value )"];
            default:
              throw new Error("unsupported encoding: " + t3);
          }
        }
        function gn(t3, e4, r3) {
          var n2 = t3.getShaderParameter(e4, 35713), i3 = t3.getShaderInfoLog(e4).trim();
          return n2 && i3 === "" ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + r3 + "\n" + i3 + function(t4) {
            for (var e5 = t4.split("\n"), r4 = 0; r4 < e5.length; r4++)
              e5[r4] = r4 + 1 + ": " + e5[r4];
            return e5.join("\n");
          }(t3.getShaderSource(e4));
        }
        function vn(t3, e4) {
          var r3 = mn(e4);
          return "vec4 " + t3 + "( vec4 value ) { return " + r3[0] + "ToLinear" + r3[1] + "; }";
        }
        function yn(t3, e4) {
          var r3;
          switch (e4) {
            case 1:
              r3 = "Linear";
              break;
            case 2:
              r3 = "Reinhard";
              break;
            case 3:
              r3 = "Uncharted2";
              break;
            case 4:
              r3 = "OptimizedCineon";
              break;
            case 5:
              r3 = "ACESFilmic";
              break;
            default:
              throw new Error("unsupported toneMapping: " + e4);
          }
          return "vec3 " + t3 + "( vec3 color ) { return " + r3 + "ToneMapping( color ); }";
        }
        function xn(t3) {
          return t3 !== "";
        }
        function bn(t3, e4) {
          return t3.replace(/NUM_DIR_LIGHTS/g, e4.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e4.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e4.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e4.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e4.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e4.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e4.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e4.numPointLightShadows);
        }
        function wn(t3, e4) {
          return t3.replace(/NUM_CLIPPING_PLANES/g, e4.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e4.numClippingPlanes - e4.numClipIntersection);
        }
        function _n(t3) {
          return t3.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(t4, e4) {
            var r3 = Qe[e4];
            if (r3 === void 0)
              throw new Error("Can not resolve #include <" + e4 + ">");
            return _n(r3);
          });
        }
        function Mn(t3) {
          return t3.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t4, e4, r3, n2) {
            for (var i3 = "", a3 = parseInt(e4); a3 < parseInt(r3); a3++)
              i3 += n2.replace(/\[ i \]/g, "[ " + a3 + " ]").replace(/UNROLLED_LOOP_INDEX/g, a3);
            return i3;
          });
        }
        function Sn(t3, e4, r3, n2, i3, a3, o5) {
          var s4 = t3.getContext(), c3 = n2.defines, l4 = i3.vertexShader, h3 = i3.fragmentShader, u3 = "SHADOWMAP_TYPE_BASIC";
          a3.shadowMapType === 1 ? u3 = "SHADOWMAP_TYPE_PCF" : a3.shadowMapType === 2 ? u3 = "SHADOWMAP_TYPE_PCF_SOFT" : a3.shadowMapType === 3 && (u3 = "SHADOWMAP_TYPE_VSM");
          var p3 = "ENVMAP_TYPE_CUBE", d3 = "ENVMAP_MODE_REFLECTION", f3 = "ENVMAP_BLENDING_MULTIPLY";
          if (a3.envMap) {
            switch (n2.envMap.mapping) {
              case 301:
              case 302:
                p3 = "ENVMAP_TYPE_CUBE";
                break;
              case 306:
              case 307:
                p3 = "ENVMAP_TYPE_CUBE_UV";
                break;
              case 303:
              case 304:
                p3 = "ENVMAP_TYPE_EQUIREC";
                break;
              case 305:
                p3 = "ENVMAP_TYPE_SPHERE";
            }
            switch (n2.envMap.mapping) {
              case 302:
              case 304:
                d3 = "ENVMAP_MODE_REFRACTION";
            }
            switch (n2.combine) {
              case 0:
                f3 = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case 1:
                f3 = "ENVMAP_BLENDING_MIX";
                break;
              case 2:
                f3 = "ENVMAP_BLENDING_ADD";
            }
          }
          var m3, g3, v3, y3, x3, b3 = t3.gammaFactor > 0 ? t3.gammaFactor : 1, w3 = o5.isWebGL2 ? "" : function(t4, e5, r4) {
            return [(t4 = t4 || {}).derivatives || e5.envMapCubeUV || e5.bumpMap || e5.tangentSpaceNormalMap || e5.clearcoatNormalMap || e5.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t4.fragDepth || e5.logarithmicDepthBuffer) && r4.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t4.drawBuffers && r4.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t4.shaderTextureLOD || e5.envMap) && r4.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(xn).join("\n");
          }(n2.extensions, a3, e4), _3 = function(t4) {
            var e5 = [];
            for (var r4 in t4) {
              var n3 = t4[r4];
              n3 !== false && e5.push("#define " + r4 + " " + n3);
            }
            return e5.join("\n");
          }(c3), M3 = s4.createProgram();
          if (n2.isRawShaderMaterial ? ((m3 = [_3].filter(xn).join("\n")).length > 0 && (m3 += "\n"), (g3 = [w3, _3].filter(xn).join("\n")).length > 0 && (g3 += "\n")) : (m3 = ["precision " + a3.precision + " float;", "precision " + a3.precision + " int;", a3.precision === "highp" ? "#define HIGH_PRECISION" : "", "#define SHADER_NAME " + i3.name, _3, a3.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + b3, "#define MAX_BONES " + a3.maxBones, a3.useFog && a3.fog ? "#define USE_FOG" : "", a3.useFog && a3.fogExp2 ? "#define FOG_EXP2" : "", a3.map ? "#define USE_MAP" : "", a3.envMap ? "#define USE_ENVMAP" : "", a3.envMap ? "#define " + d3 : "", a3.lightMap ? "#define USE_LIGHTMAP" : "", a3.aoMap ? "#define USE_AOMAP" : "", a3.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a3.bumpMap ? "#define USE_BUMPMAP" : "", a3.normalMap ? "#define USE_NORMALMAP" : "", a3.normalMap && a3.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a3.normalMap && a3.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", a3.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", a3.displacementMap && a3.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a3.specularMap ? "#define USE_SPECULARMAP" : "", a3.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a3.metalnessMap ? "#define USE_METALNESSMAP" : "", a3.alphaMap ? "#define USE_ALPHAMAP" : "", a3.vertexTangents ? "#define USE_TANGENT" : "", a3.vertexColors ? "#define USE_COLOR" : "", a3.vertexUvs ? "#define USE_UV" : "", a3.flatShading ? "#define FLAT_SHADED" : "", a3.skinning ? "#define USE_SKINNING" : "", a3.useVertexTexture ? "#define BONE_TEXTURE" : "", a3.morphTargets ? "#define USE_MORPHTARGETS" : "", a3.morphNormals && a3.flatShading === false ? "#define USE_MORPHNORMALS" : "", a3.doubleSided ? "#define DOUBLE_SIDED" : "", a3.flipSided ? "#define FLIP_SIDED" : "", a3.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a3.shadowMapEnabled ? "#define " + u3 : "", a3.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a3.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a3.logarithmicDepthBuffer && (o5.isWebGL2 || e4.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(xn).join("\n"), g3 = [w3, "precision " + a3.precision + " float;", "precision " + a3.precision + " int;", a3.precision === "highp" ? "#define HIGH_PRECISION" : "", "#define SHADER_NAME " + i3.name, _3, a3.alphaTest ? "#define ALPHATEST " + a3.alphaTest + (a3.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + b3, a3.useFog && a3.fog ? "#define USE_FOG" : "", a3.useFog && a3.fogExp2 ? "#define FOG_EXP2" : "", a3.map ? "#define USE_MAP" : "", a3.matcap ? "#define USE_MATCAP" : "", a3.envMap ? "#define USE_ENVMAP" : "", a3.envMap ? "#define " + p3 : "", a3.envMap ? "#define " + d3 : "", a3.envMap ? "#define " + f3 : "", a3.lightMap ? "#define USE_LIGHTMAP" : "", a3.aoMap ? "#define USE_AOMAP" : "", a3.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a3.bumpMap ? "#define USE_BUMPMAP" : "", a3.normalMap ? "#define USE_NORMALMAP" : "", a3.normalMap && a3.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a3.normalMap && a3.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", a3.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", a3.specularMap ? "#define USE_SPECULARMAP" : "", a3.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a3.metalnessMap ? "#define USE_METALNESSMAP" : "", a3.alphaMap ? "#define USE_ALPHAMAP" : "", a3.sheen ? "#define USE_SHEEN" : "", a3.vertexTangents ? "#define USE_TANGENT" : "", a3.vertexColors ? "#define USE_COLOR" : "", a3.vertexUvs ? "#define USE_UV" : "", a3.gradientMap ? "#define USE_GRADIENTMAP" : "", a3.flatShading ? "#define FLAT_SHADED" : "", a3.doubleSided ? "#define DOUBLE_SIDED" : "", a3.flipSided ? "#define FLIP_SIDED" : "", a3.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a3.shadowMapEnabled ? "#define " + u3 : "", a3.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a3.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a3.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a3.logarithmicDepthBuffer && (o5.isWebGL2 || e4.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", (n2.extensions && n2.extensions.shaderTextureLOD || a3.envMap) && (o5.isWebGL2 || e4.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", a3.toneMapping !== 0 ? "#define TONE_MAPPING" : "", a3.toneMapping !== 0 ? Qe.tonemapping_pars_fragment : "", a3.toneMapping !== 0 ? yn("toneMapping", a3.toneMapping) : "", a3.dithering ? "#define DITHERING" : "", a3.outputEncoding || a3.mapEncoding || a3.matcapEncoding || a3.envMapEncoding || a3.emissiveMapEncoding ? Qe.encodings_pars_fragment : "", a3.mapEncoding ? vn("mapTexelToLinear", a3.mapEncoding) : "", a3.matcapEncoding ? vn("matcapTexelToLinear", a3.matcapEncoding) : "", a3.envMapEncoding ? vn("envMapTexelToLinear", a3.envMapEncoding) : "", a3.emissiveMapEncoding ? vn("emissiveMapTexelToLinear", a3.emissiveMapEncoding) : "", a3.outputEncoding ? (v3 = "linearToOutputTexel", y3 = a3.outputEncoding, x3 = mn(y3), "vec4 " + v3 + "( vec4 value ) { return LinearTo" + x3[0] + x3[1] + "; }") : "", a3.depthPacking ? "#define DEPTH_PACKING " + n2.depthPacking : "", "\n"].filter(xn).join("\n")), l4 = wn(l4 = bn(l4 = _n(l4), a3), a3), h3 = wn(h3 = bn(h3 = _n(h3), a3), a3), l4 = Mn(l4), h3 = Mn(h3), o5.isWebGL2 && !n2.isRawShaderMaterial) {
            var S3 = false, T3 = /^\s*#version\s+300\s+es\s*\n/;
            n2.isShaderMaterial && l4.match(T3) !== null && h3.match(T3) !== null && (S3 = true, l4 = l4.replace(T3, ""), h3 = h3.replace(T3, "")), m3 = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + m3, g3 = ["#version 300 es\n", "#define varying in", S3 ? "" : "out highp vec4 pc_fragColor;", S3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + g3;
          }
          var E4, A3, L3 = g3 + h3, R2 = dn(s4, 35633, m3 + l4), P3 = dn(s4, 35632, L3);
          if (s4.attachShader(M3, R2), s4.attachShader(M3, P3), n2.index0AttributeName !== void 0 ? s4.bindAttribLocation(M3, 0, n2.index0AttributeName) : a3.morphTargets === true && s4.bindAttribLocation(M3, 0, "position"), s4.linkProgram(M3), t3.debug.checkShaderErrors) {
            var C2 = s4.getProgramInfoLog(M3).trim(), O2 = s4.getShaderInfoLog(R2).trim(), D2 = s4.getShaderInfoLog(P3).trim(), N2 = true, I2 = true;
            if (s4.getProgramParameter(M3, 35714) === false) {
              N2 = false;
              var z2 = gn(s4, R2, "vertex"), B2 = gn(s4, P3, "fragment");
              console.error("THREE.WebGLProgram: shader error: ", s4.getError(), "35715", s4.getProgramParameter(M3, 35715), "gl.getProgramInfoLog", C2, z2, B2);
            } else
              C2 !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", C2) : O2 !== "" && D2 !== "" || (I2 = false);
            I2 && (this.diagnostics = { runnable: N2, material: n2, programLog: C2, vertexShader: { log: O2, prefix: m3 }, fragmentShader: { log: D2, prefix: g3 } });
          }
          return s4.deleteShader(R2), s4.deleteShader(P3), this.getUniforms = function() {
            return E4 === void 0 && (E4 = new pn(s4, M3)), E4;
          }, this.getAttributes = function() {
            return A3 === void 0 && (A3 = function(t4, e5) {
              for (var r4 = {}, n3 = t4.getProgramParameter(e5, 35721), i4 = 0; i4 < n3; i4++) {
                var a4 = t4.getActiveAttrib(e5, i4).name;
                r4[a4] = t4.getAttribLocation(e5, a4);
              }
              return r4;
            }(s4, M3)), A3;
          }, this.destroy = function() {
            s4.deleteProgram(M3), this.program = void 0;
          }, this.name = i3.name, this.id = fn++, this.code = r3, this.usedTimes = 1, this.program = M3, this.vertexShader = R2, this.fragmentShader = P3, this;
        }
        function Tn(t3, e4, r3) {
          var n2 = [], i3 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "phong", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, a3 = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];
          function o5(t4, e5) {
            var r4;
            return t4 ? t4.isTexture ? r4 = t4.encoding : t4.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), r4 = t4.texture.encoding) : r4 = 3e3, r4 === 3e3 && e5 && (r4 = 3007), r4;
          }
          this.getParameters = function(e5, n3, a4, s4, c3, l4, h3) {
            var u3 = i3[e5.type], p3 = h3.isSkinnedMesh ? function(t4) {
              var e6 = t4.skeleton.bones;
              if (r3.floatVertexTextures)
                return 1024;
              var n4 = r3.maxVertexUniforms, i4 = Math.floor((n4 - 20) / 4), a5 = Math.min(i4, e6.length);
              return a5 < e6.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e6.length + " bones. This GPU supports " + a5 + "."), 0) : a5;
            }(h3) : 0, d3 = r3.precision;
            e5.precision !== null && (d3 = r3.getMaxPrecision(e5.precision)) !== e5.precision && console.warn("THREE.WebGLProgram.getParameters:", e5.precision, "not supported, using", d3, "instead.");
            var f3 = t3.getRenderTarget();
            return { shaderID: u3, precision: d3, supportsVertexTextures: r3.vertexTextures, outputEncoding: o5(f3 ? f3.texture : null, t3.gammaOutput), map: !!e5.map, mapEncoding: o5(e5.map, t3.gammaInput), matcap: !!e5.matcap, matcapEncoding: o5(e5.matcap, t3.gammaInput), envMap: !!e5.envMap, envMapMode: e5.envMap && e5.envMap.mapping, envMapEncoding: o5(e5.envMap, t3.gammaInput), envMapCubeUV: !!e5.envMap && (e5.envMap.mapping === 306 || e5.envMap.mapping === 307), lightMap: !!e5.lightMap, aoMap: !!e5.aoMap, emissiveMap: !!e5.emissiveMap, emissiveMapEncoding: o5(e5.emissiveMap, t3.gammaInput), bumpMap: !!e5.bumpMap, normalMap: !!e5.normalMap, objectSpaceNormalMap: e5.normalMapType === 1, tangentSpaceNormalMap: e5.normalMapType === 0, clearcoatNormalMap: !!e5.clearcoatNormalMap, displacementMap: !!e5.displacementMap, roughnessMap: !!e5.roughnessMap, metalnessMap: !!e5.metalnessMap, specularMap: !!e5.specularMap, alphaMap: !!e5.alphaMap, gradientMap: !!e5.gradientMap, sheen: !!e5.sheen, combine: e5.combine, vertexTangents: e5.normalMap && e5.vertexTangents, vertexColors: e5.vertexColors, vertexUvs: !!(e5.map || e5.bumpMap || e5.normalMap || e5.specularMap || e5.alphaMap || e5.emissiveMap || e5.roughnessMap || e5.metalnessMap || e5.clearcoatNormalMap), fog: !!s4, useFog: e5.fog, fogExp2: s4 && s4.isFogExp2, flatShading: e5.flatShading, sizeAttenuation: e5.sizeAttenuation, logarithmicDepthBuffer: r3.logarithmicDepthBuffer, skinning: e5.skinning && p3 > 0, maxBones: p3, useVertexTexture: r3.floatVertexTextures, morphTargets: e5.morphTargets, morphNormals: e5.morphNormals, maxMorphTargets: t3.maxMorphTargets, maxMorphNormals: t3.maxMorphNormals, numDirLights: n3.directional.length, numPointLights: n3.point.length, numSpotLights: n3.spot.length, numRectAreaLights: n3.rectArea.length, numHemiLights: n3.hemi.length, numDirLightShadows: n3.directionalShadowMap.length, numPointLightShadows: n3.pointShadowMap.length, numSpotLightShadows: n3.spotShadowMap.length, numClippingPlanes: c3, numClipIntersection: l4, dithering: e5.dithering, shadowMapEnabled: t3.shadowMap.enabled && h3.receiveShadow && a4.length > 0, shadowMapType: t3.shadowMap.type, toneMapping: e5.toneMapped ? t3.toneMapping : 0, physicallyCorrectLights: t3.physicallyCorrectLights, premultipliedAlpha: e5.premultipliedAlpha, alphaTest: e5.alphaTest, doubleSided: e5.side === 2, flipSided: e5.side === 1, depthPacking: e5.depthPacking !== void 0 && e5.depthPacking };
          }, this.getProgramCode = function(e5, r4) {
            var n3 = [];
            if (r4.shaderID ? n3.push(r4.shaderID) : (n3.push(e5.fragmentShader), n3.push(e5.vertexShader)), e5.defines !== void 0)
              for (var i4 in e5.defines)
                n3.push(i4), n3.push(e5.defines[i4]);
            for (var o6 = 0; o6 < a3.length; o6++)
              n3.push(r4[a3[o6]]);
            return n3.push(e5.onBeforeCompile.toString()), n3.push(t3.gammaOutput), n3.push(t3.gammaFactor), n3.join();
          }, this.acquireProgram = function(i4, a4, o6, s4) {
            for (var c3, l4 = 0, h3 = n2.length; l4 < h3; l4++) {
              var u3 = n2[l4];
              if (u3.code === s4) {
                ++(c3 = u3).usedTimes;
                break;
              }
            }
            return c3 === void 0 && (c3 = new Sn(t3, e4, s4, i4, a4, o6, r3), n2.push(c3)), c3;
          }, this.releaseProgram = function(t4) {
            if (--t4.usedTimes == 0) {
              var e5 = n2.indexOf(t4);
              n2[e5] = n2[n2.length - 1], n2.pop(), t4.destroy();
            }
          }, this.programs = n2;
        }
        function En() {
          var t3 = /* @__PURE__ */ new WeakMap();
          return { get: function(e4) {
            var r3 = t3.get(e4);
            return r3 === void 0 && (r3 = {}, t3.set(e4, r3)), r3;
          }, remove: function(e4) {
            t3.delete(e4);
          }, update: function(e4, r3, n2) {
            t3.get(e4)[r3] = n2;
          }, dispose: function() {
            t3 = /* @__PURE__ */ new WeakMap();
          } };
        }
        function An(t3, e4) {
          return t3.groupOrder !== e4.groupOrder ? t3.groupOrder - e4.groupOrder : t3.renderOrder !== e4.renderOrder ? t3.renderOrder - e4.renderOrder : t3.program !== e4.program ? t3.program.id - e4.program.id : t3.material.id !== e4.material.id ? t3.material.id - e4.material.id : t3.z !== e4.z ? t3.z - e4.z : t3.id - e4.id;
        }
        function Ln(t3, e4) {
          return t3.groupOrder !== e4.groupOrder ? t3.groupOrder - e4.groupOrder : t3.renderOrder !== e4.renderOrder ? t3.renderOrder - e4.renderOrder : t3.z !== e4.z ? e4.z - t3.z : t3.id - e4.id;
        }
        function Rn() {
          var t3 = [], e4 = 0, r3 = [], n2 = [], i3 = { id: -1 };
          function a3(r4, n3, a4, o5, s4, c3) {
            var l4 = t3[e4];
            return l4 === void 0 ? (l4 = { id: r4.id, object: r4, geometry: n3, material: a4, program: a4.program || i3, groupOrder: o5, renderOrder: r4.renderOrder, z: s4, group: c3 }, t3[e4] = l4) : (l4.id = r4.id, l4.object = r4, l4.geometry = n3, l4.material = a4, l4.program = a4.program || i3, l4.groupOrder = o5, l4.renderOrder = r4.renderOrder, l4.z = s4, l4.group = c3), e4++, l4;
          }
          return { opaque: r3, transparent: n2, init: function() {
            e4 = 0, r3.length = 0, n2.length = 0;
          }, push: function(t4, e5, i4, o5, s4, c3) {
            var l4 = a3(t4, e5, i4, o5, s4, c3);
            (i4.transparent === true ? n2 : r3).push(l4);
          }, unshift: function(t4, e5, i4, o5, s4, c3) {
            var l4 = a3(t4, e5, i4, o5, s4, c3);
            (i4.transparent === true ? n2 : r3).unshift(l4);
          }, sort: function() {
            r3.length > 1 && r3.sort(An), n2.length > 1 && n2.sort(Ln);
          } };
        }
        function Pn() {
          var t3 = /* @__PURE__ */ new WeakMap();
          function e4(r3) {
            var n2 = r3.target;
            n2.removeEventListener("dispose", e4), t3.delete(n2);
          }
          return { get: function(r3, n2) {
            var i3, a3 = t3.get(r3);
            return a3 === void 0 ? (i3 = new Rn(), t3.set(r3, /* @__PURE__ */ new WeakMap()), t3.get(r3).set(n2, i3), r3.addEventListener("dispose", e4)) : (i3 = a3.get(n2)) === void 0 && (i3 = new Rn(), a3.set(n2, i3)), i3;
          }, dispose: function() {
            t3 = /* @__PURE__ */ new WeakMap();
          } };
        }
        function Cn() {
          var t3 = {};
          return { get: function(e4) {
            if (t3[e4.id] !== void 0)
              return t3[e4.id];
            var r3;
            switch (e4.type) {
              case "DirectionalLight":
                r3 = { direction: new d2(), color: new Nt(), shadow: false, shadowBias: 0, shadowRadius: 1, shadowMapSize: new l3() };
                break;
              case "SpotLight":
                r3 = { position: new d2(), direction: new d2(), color: new Nt(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: false, shadowBias: 0, shadowRadius: 1, shadowMapSize: new l3() };
                break;
              case "PointLight":
                r3 = { position: new d2(), color: new Nt(), distance: 0, decay: 0, shadow: false, shadowBias: 0, shadowRadius: 1, shadowMapSize: new l3(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
                break;
              case "HemisphereLight":
                r3 = { direction: new d2(), skyColor: new Nt(), groundColor: new Nt() };
                break;
              case "RectAreaLight":
                r3 = { color: new Nt(), position: new d2(), halfWidth: new d2(), halfHeight: new d2() };
            }
            return t3[e4.id] = r3, r3;
          } };
        }
        var On = 0;
        function Dn(t3, e4) {
          return (e4.castShadow ? 1 : 0) - (t3.castShadow ? 1 : 0);
        }
        function Nn() {
          for (var t3 = new Cn(), e4 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, r3 = 0; r3 < 9; r3++)
            e4.probe.push(new d2());
          var n2 = new d2(), i3 = new P2(), a3 = new P2();
          return { setup: function(r4, o5, s4) {
            for (var c3 = 0, l4 = 0, h3 = 0, u3 = 0; u3 < 9; u3++)
              e4.probe[u3].set(0, 0, 0);
            var p3 = 0, d3 = 0, f3 = 0, m3 = 0, g3 = 0, v3 = 0, y3 = 0, x3 = 0, b3 = s4.matrixWorldInverse;
            r4.sort(Dn), u3 = 0;
            for (var w3 = r4.length; u3 < w3; u3++) {
              var _3 = r4[u3], M3 = _3.color, S3 = _3.intensity, T3 = _3.distance, E4 = _3.shadow && _3.shadow.map ? _3.shadow.map.texture : null;
              if (_3.isAmbientLight)
                c3 += M3.r * S3, l4 += M3.g * S3, h3 += M3.b * S3;
              else if (_3.isLightProbe)
                for (var A3 = 0; A3 < 9; A3++)
                  e4.probe[A3].addScaledVector(_3.sh.coefficients[A3], S3);
              else if (_3.isDirectionalLight) {
                if ((R2 = t3.get(_3)).color.copy(_3.color).multiplyScalar(_3.intensity), R2.direction.setFromMatrixPosition(_3.matrixWorld), n2.setFromMatrixPosition(_3.target.matrixWorld), R2.direction.sub(n2), R2.direction.transformDirection(b3), R2.shadow = _3.castShadow, _3.castShadow) {
                  var L3 = _3.shadow;
                  R2.shadowBias = L3.bias, R2.shadowRadius = L3.radius, R2.shadowMapSize = L3.mapSize, e4.directionalShadowMap[p3] = E4, e4.directionalShadowMatrix[p3] = _3.shadow.matrix, v3++;
                }
                e4.directional[p3] = R2, p3++;
              } else if (_3.isSpotLight)
                (R2 = t3.get(_3)).position.setFromMatrixPosition(_3.matrixWorld), R2.position.applyMatrix4(b3), R2.color.copy(M3).multiplyScalar(S3), R2.distance = T3, R2.direction.setFromMatrixPosition(_3.matrixWorld), n2.setFromMatrixPosition(_3.target.matrixWorld), R2.direction.sub(n2), R2.direction.transformDirection(b3), R2.coneCos = Math.cos(_3.angle), R2.penumbraCos = Math.cos(_3.angle * (1 - _3.penumbra)), R2.decay = _3.decay, R2.shadow = _3.castShadow, _3.castShadow && (L3 = _3.shadow, R2.shadowBias = L3.bias, R2.shadowRadius = L3.radius, R2.shadowMapSize = L3.mapSize, e4.spotShadowMap[f3] = E4, e4.spotShadowMatrix[f3] = _3.shadow.matrix, x3++), e4.spot[f3] = R2, f3++;
              else if (_3.isRectAreaLight)
                (R2 = t3.get(_3)).color.copy(M3).multiplyScalar(S3), R2.position.setFromMatrixPosition(_3.matrixWorld), R2.position.applyMatrix4(b3), a3.identity(), i3.copy(_3.matrixWorld), i3.premultiply(b3), a3.extractRotation(i3), R2.halfWidth.set(0.5 * _3.width, 0, 0), R2.halfHeight.set(0, 0.5 * _3.height, 0), R2.halfWidth.applyMatrix4(a3), R2.halfHeight.applyMatrix4(a3), e4.rectArea[m3] = R2, m3++;
              else if (_3.isPointLight)
                (R2 = t3.get(_3)).position.setFromMatrixPosition(_3.matrixWorld), R2.position.applyMatrix4(b3), R2.color.copy(_3.color).multiplyScalar(_3.intensity), R2.distance = _3.distance, R2.decay = _3.decay, R2.shadow = _3.castShadow, _3.castShadow && (L3 = _3.shadow, R2.shadowBias = L3.bias, R2.shadowRadius = L3.radius, R2.shadowMapSize = L3.mapSize, R2.shadowCameraNear = L3.camera.near, R2.shadowCameraFar = L3.camera.far, e4.pointShadowMap[d3] = E4, e4.pointShadowMatrix[d3] = _3.shadow.matrix, y3++), e4.point[d3] = R2, d3++;
              else if (_3.isHemisphereLight) {
                var R2;
                (R2 = t3.get(_3)).direction.setFromMatrixPosition(_3.matrixWorld), R2.direction.transformDirection(b3), R2.direction.normalize(), R2.skyColor.copy(_3.color).multiplyScalar(S3), R2.groundColor.copy(_3.groundColor).multiplyScalar(S3), e4.hemi[g3] = R2, g3++;
              }
            }
            e4.ambient[0] = c3, e4.ambient[1] = l4, e4.ambient[2] = h3;
            var P3 = e4.hash;
            P3.directionalLength === p3 && P3.pointLength === d3 && P3.spotLength === f3 && P3.rectAreaLength === m3 && P3.hemiLength === g3 && P3.numDirectionalShadows === v3 && P3.numPointShadows === y3 && P3.numSpotShadows === x3 || (e4.directional.length = p3, e4.spot.length = f3, e4.rectArea.length = m3, e4.point.length = d3, e4.hemi.length = g3, e4.directionalShadowMap.length = v3, e4.pointShadowMap.length = y3, e4.spotShadowMap.length = x3, e4.directionalShadowMatrix.length = v3, e4.pointShadowMatrix.length = y3, e4.spotShadowMatrix.length = x3, P3.directionalLength = p3, P3.pointLength = d3, P3.spotLength = f3, P3.rectAreaLength = m3, P3.hemiLength = g3, P3.numDirectionalShadows = v3, P3.numPointShadows = y3, P3.numSpotShadows = x3, e4.version = On++);
          }, state: e4 };
        }
        function In() {
          var t3 = new Nn(), e4 = [], r3 = [];
          return { init: function() {
            e4.length = 0, r3.length = 0;
          }, state: { lightsArray: e4, shadowsArray: r3, lights: t3 }, setupLights: function(n2) {
            t3.setup(e4, r3, n2);
          }, pushLight: function(t4) {
            e4.push(t4);
          }, pushShadow: function(t4) {
            r3.push(t4);
          } };
        }
        function zn() {
          var t3 = /* @__PURE__ */ new WeakMap();
          function e4(r3) {
            var n2 = r3.target;
            n2.removeEventListener("dispose", e4), t3.delete(n2);
          }
          return { get: function(r3, n2) {
            var i3;
            return t3.has(r3) === false ? (i3 = new In(), t3.set(r3, /* @__PURE__ */ new WeakMap()), t3.get(r3).set(n2, i3), r3.addEventListener("dispose", e4)) : t3.get(r3).has(n2) === false ? (i3 = new In(), t3.get(r3).set(n2, i3)) : i3 = t3.get(r3).get(n2), i3;
          }, dispose: function() {
            t3 = /* @__PURE__ */ new WeakMap();
          } };
        }
        function Bn(t3) {
          Ut.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = false, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.setValues(t3);
        }
        function Fn(t3) {
          Ut.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new d2(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = false, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.lights = false, this.setValues(t3);
        }
        function Gn(t3, e4, r3) {
          var n2 = new Ze(), i3 = new l3(), a3 = new l3(), o5 = new x2(), s4 = new Array(4), c3 = new Array(4), h3 = {}, u3 = { 0: 1, 1: 0, 2: 2 }, p3 = new Fe({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new l3() }, radius: { value: 4 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n  \n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = decodeHalfRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = pow( squared_mean - mean * mean, 0.5 );\n  gl_FragColor = encodeHalfRGBA( vec2( mean, std_dev ) );\n}" }), d3 = p3.clone();
          d3.defines.HORIZONAL_PASS = 1;
          var f3 = new se();
          f3.addAttribute("position", new Vt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
          for (var m3 = new Te(f3, p3), g3 = 0; g3 !== 4; ++g3) {
            var v3 = (1 & g3) != 0, y3 = (2 & g3) != 0, w3 = new Bn({ depthPacking: 3201, morphTargets: v3, skinning: y3 });
            s4[g3] = w3;
            var _3 = new Fn({ morphTargets: v3, skinning: y3 });
            c3[g3] = _3;
          }
          var M3 = this;
          function S3(r4, n3) {
            var i4 = e4.update(m3);
            p3.uniforms.shadow_pass.value = r4.map.texture, p3.uniforms.resolution.value = r4.mapSize, p3.uniforms.radius.value = r4.radius, t3.setRenderTarget(r4.mapPass), t3.clear(), t3.renderBufferDirect(n3, null, i4, p3, m3, null), d3.uniforms.shadow_pass.value = r4.mapPass.texture, d3.uniforms.resolution.value = r4.mapSize, d3.uniforms.radius.value = r4.radius, t3.setRenderTarget(r4.map), t3.clear(), t3.renderBufferDirect(n3, null, i4, d3, m3, null);
          }
          function T3(e5, r4, n3, i4, a4, o6) {
            var l4 = e5.geometry, p4 = null, d4 = s4, f4 = e5.customDepthMaterial;
            if (n3.isPointLight && (d4 = c3, f4 = e5.customDistanceMaterial), f4)
              p4 = f4;
            else {
              var m4 = false;
              r4.morphTargets && (l4 && l4.isBufferGeometry ? m4 = l4.morphAttributes && l4.morphAttributes.position && l4.morphAttributes.position.length > 0 : l4 && l4.isGeometry && (m4 = l4.morphTargets && l4.morphTargets.length > 0)), e5.isSkinnedMesh && r4.skinning === false && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e5);
              var g4 = 0;
              m4 && (g4 |= 1), e5.isSkinnedMesh && r4.skinning && (g4 |= 2), p4 = d4[g4];
            }
            if (t3.localClippingEnabled && r4.clipShadows === true && r4.clippingPlanes.length !== 0) {
              var v4 = p4.uuid, y4 = r4.uuid, x3 = h3[v4];
              x3 === void 0 && (x3 = {}, h3[v4] = x3);
              var b3 = x3[y4];
              b3 === void 0 && (b3 = p4.clone(), x3[y4] = b3), p4 = b3;
            }
            return p4.visible = r4.visible, p4.wireframe = r4.wireframe, p4.side = o6 === 3 ? r4.shadowSide != null ? r4.shadowSide : r4.side : r4.shadowSide != null ? r4.shadowSide : u3[r4.side], p4.clipShadows = r4.clipShadows, p4.clippingPlanes = r4.clippingPlanes, p4.clipIntersection = r4.clipIntersection, p4.wireframeLinewidth = r4.wireframeLinewidth, p4.linewidth = r4.linewidth, n3.isPointLight && p4.isMeshDistanceMaterial && (p4.referencePosition.setFromMatrixPosition(n3.matrixWorld), p4.nearDistance = i4, p4.farDistance = a4), p4;
          }
          function E4(r4, i4, a4, o6, s5) {
            if (r4.visible !== false) {
              if (r4.layers.test(i4.layers) && (r4.isMesh || r4.isLine || r4.isPoints) && (r4.castShadow || r4.receiveShadow && s5 === 3) && (!r4.frustumCulled || n2.intersectsObject(r4))) {
                r4.modelViewMatrix.multiplyMatrices(a4.matrixWorldInverse, r4.matrixWorld);
                var c4 = e4.update(r4), l4 = r4.material;
                if (Array.isArray(l4))
                  for (var h4 = c4.groups, u4 = 0, p4 = h4.length; u4 < p4; u4++) {
                    var d4 = h4[u4], f4 = l4[d4.materialIndex];
                    if (f4 && f4.visible) {
                      var m4 = T3(r4, f4, o6, a4.near, a4.far, s5);
                      t3.renderBufferDirect(a4, null, c4, m4, r4, d4);
                    }
                  }
                else
                  l4.visible && (m4 = T3(r4, l4, o6, a4.near, a4.far, s5), t3.renderBufferDirect(a4, null, c4, m4, r4, null));
              }
              for (var g4 = r4.children, v4 = 0, y4 = g4.length; v4 < y4; v4++)
                E4(g4[v4], i4, a4, o6, s5);
            }
          }
          this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 1, this.render = function(e5, s5, c4) {
            if (M3.enabled !== false && (M3.autoUpdate !== false || M3.needsUpdate !== false) && e5.length !== 0) {
              var l4 = t3.getRenderTarget(), h4 = t3.getActiveCubeFace(), u4 = t3.getActiveMipmapLevel(), p4 = t3.state;
              p4.setBlending(0), p4.buffers.color.setClear(1, 1, 1, 1), p4.buffers.depth.setTest(true), p4.setScissorTest(false);
              for (var d4 = 0, f4 = e5.length; d4 < f4; d4++) {
                var m4 = e5[d4], g4 = m4.shadow;
                if (g4 !== void 0) {
                  i3.copy(g4.mapSize);
                  var v4 = g4.getFrameExtents();
                  if (i3.multiply(v4), a3.copy(g4.mapSize), (i3.x > r3 || i3.y > r3) && (console.warn("THREE.WebGLShadowMap:", m4, "has shadow exceeding max texture size, reducing"), i3.x > r3 && (a3.x = Math.floor(r3 / v4.x), i3.x = a3.x * v4.x, g4.mapSize.x = a3.x), i3.y > r3 && (a3.y = Math.floor(r3 / v4.y), i3.y = a3.y * v4.y, g4.mapSize.y = a3.y)), g4.map === null && !g4.isPointLightShadow && this.type === 3) {
                    var y4 = { minFilter: 1006, magFilter: 1006, format: 1023 };
                    g4.map = new b2(i3.x, i3.y, y4), g4.map.texture.name = m4.name + ".shadowMap", g4.mapPass = new b2(i3.x, i3.y, y4), g4.camera.updateProjectionMatrix();
                  }
                  g4.map === null && (y4 = { minFilter: 1003, magFilter: 1003, format: 1023 }, g4.map = new b2(i3.x, i3.y, y4), g4.map.texture.name = m4.name + ".shadowMap", g4.camera.updateProjectionMatrix()), t3.setRenderTarget(g4.map), t3.clear();
                  for (var x3 = g4.getViewportCount(), w4 = 0; w4 < x3; w4++) {
                    var _4 = g4.getViewport(w4);
                    o5.set(a3.x * _4.x, a3.y * _4.y, a3.x * _4.z, a3.y * _4.w), p4.viewport(o5), g4.updateMatrices(m4, c4, w4), n2 = g4.getFrustum(), E4(s5, c4, g4.camera, m4, this.type);
                  }
                  g4.isPointLightShadow || this.type !== 3 || S3(g4, c4);
                } else
                  console.warn("THREE.WebGLShadowMap:", m4, "has no shadow.");
              }
              M3.needsUpdate = false, t3.setRenderTarget(l4, h4, u4);
            }
          };
        }
        function Un(t3, e4, r3, n2) {
          var i3 = new function() {
            var e5 = false, r4 = new x2(), n3 = null, i4 = new x2(0, 0, 0, 0);
            return { setMask: function(r5) {
              n3 === r5 || e5 || (t3.colorMask(r5, r5, r5, r5), n3 = r5);
            }, setLocked: function(t4) {
              e5 = t4;
            }, setClear: function(e6, n4, a4, o6, s5) {
              s5 === true && (e6 *= o6, n4 *= o6, a4 *= o6), r4.set(e6, n4, a4, o6), i4.equals(r4) === false && (t3.clearColor(e6, n4, a4, o6), i4.copy(r4));
            }, reset: function() {
              e5 = false, n3 = null, i4.set(-1, 0, 0, 0);
            } };
          }(), a3 = new function() {
            var e5 = false, r4 = null, n3 = null, i4 = null;
            return { setTest: function(t4) {
              t4 ? U2(2929) : H2(2929);
            }, setMask: function(n4) {
              r4 === n4 || e5 || (t3.depthMask(n4), r4 = n4);
            }, setFunc: function(e6) {
              if (n3 !== e6) {
                if (e6)
                  switch (e6) {
                    case 0:
                      t3.depthFunc(512);
                      break;
                    case 1:
                      t3.depthFunc(519);
                      break;
                    case 2:
                      t3.depthFunc(513);
                      break;
                    case 3:
                      t3.depthFunc(515);
                      break;
                    case 4:
                      t3.depthFunc(514);
                      break;
                    case 5:
                      t3.depthFunc(518);
                      break;
                    case 6:
                      t3.depthFunc(516);
                      break;
                    case 7:
                      t3.depthFunc(517);
                      break;
                    default:
                      t3.depthFunc(515);
                  }
                else
                  t3.depthFunc(515);
                n3 = e6;
              }
            }, setLocked: function(t4) {
              e5 = t4;
            }, setClear: function(e6) {
              i4 !== e6 && (t3.clearDepth(e6), i4 = e6);
            }, reset: function() {
              e5 = false, r4 = null, n3 = null, i4 = null;
            } };
          }(), o5 = new function() {
            var e5 = false, r4 = null, n3 = null, i4 = null, a4 = null, o6 = null, s5 = null, c4 = null, l5 = null;
            return { setTest: function(t4) {
              e5 || (t4 ? U2(2960) : H2(2960));
            }, setMask: function(n4) {
              r4 === n4 || e5 || (t3.stencilMask(n4), r4 = n4);
            }, setFunc: function(e6, r5, o7) {
              n3 === e6 && i4 === r5 && a4 === o7 || (t3.stencilFunc(e6, r5, o7), n3 = e6, i4 = r5, a4 = o7);
            }, setOp: function(e6, r5, n4) {
              o6 === e6 && s5 === r5 && c4 === n4 || (t3.stencilOp(e6, r5, n4), o6 = e6, s5 = r5, c4 = n4);
            }, setLocked: function(t4) {
              e5 = t4;
            }, setClear: function(e6) {
              l5 !== e6 && (t3.clearStencil(e6), l5 = e6);
            }, reset: function() {
              e5 = false, r4 = null, n3 = null, i4 = null, a4 = null, o6 = null, s5 = null, c4 = null, l5 = null;
            } };
          }(), s4 = t3.getParameter(34921), c3 = new Uint8Array(s4), l4 = new Uint8Array(s4), h3 = new Uint8Array(s4), u3 = {}, p3 = null, d3 = null, f3 = null, m3 = null, g3 = null, v3 = null, y3 = null, b3 = null, w3 = null, _3 = null, M3 = false, S3 = null, T3 = null, E4 = null, A3 = null, L3 = null, R2 = t3.getParameter(35661), P3 = false, C2 = 0, O2 = t3.getParameter(7938);
          O2.indexOf("WebGL") !== -1 ? (C2 = parseFloat(/^WebGL\ ([0-9])/.exec(O2)[1]), P3 = C2 >= 1) : O2.indexOf("OpenGL ES") !== -1 && (C2 = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(O2)[1]), P3 = C2 >= 2);
          var D2 = null, N2 = {}, I2 = new x2(), z2 = new x2();
          function B2(e5, r4, n3) {
            var i4 = new Uint8Array(4), a4 = t3.createTexture();
            t3.bindTexture(e5, a4), t3.texParameteri(e5, 10241, 9728), t3.texParameteri(e5, 10240, 9728);
            for (var o6 = 0; o6 < n3; o6++)
              t3.texImage2D(r4 + o6, 0, 6408, 1, 1, 0, 6408, 5121, i4);
            return a4;
          }
          var F2 = {};
          function G2(r4, i4) {
            c3[r4] = 1, l4[r4] === 0 && (t3.enableVertexAttribArray(r4), l4[r4] = 1), h3[r4] !== i4 && ((n2.isWebGL2 ? t3 : e4.get("ANGLE_instanced_arrays"))[n2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](r4, i4), h3[r4] = i4);
          }
          function U2(e5) {
            u3[e5] !== true && (t3.enable(e5), u3[e5] = true);
          }
          function H2(e5) {
            u3[e5] !== false && (t3.disable(e5), u3[e5] = false);
          }
          function V2(e5, n3, i4, a4, o6, s5, c4, l5) {
            if (e5 !== 0) {
              if (f3 || (U2(3042), f3 = true), e5 === 5)
                o6 = o6 || n3, s5 = s5 || i4, c4 = c4 || a4, n3 === g3 && o6 === b3 || (t3.blendEquationSeparate(r3.convert(n3), r3.convert(o6)), g3 = n3, b3 = o6), i4 === v3 && a4 === y3 && s5 === w3 && c4 === _3 || (t3.blendFuncSeparate(r3.convert(i4), r3.convert(a4), r3.convert(s5), r3.convert(c4)), v3 = i4, y3 = a4, w3 = s5, _3 = c4), m3 = e5, M3 = null;
              else if (e5 !== m3 || l5 !== M3) {
                if (g3 === 100 && b3 === 100 || (t3.blendEquation(32774), g3 = 100, b3 = 100), l5)
                  switch (e5) {
                    case 1:
                      t3.blendFuncSeparate(1, 771, 1, 771);
                      break;
                    case 2:
                      t3.blendFunc(1, 1);
                      break;
                    case 3:
                      t3.blendFuncSeparate(0, 0, 769, 771);
                      break;
                    case 4:
                      t3.blendFuncSeparate(0, 768, 0, 770);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e5);
                  }
                else
                  switch (e5) {
                    case 1:
                      t3.blendFuncSeparate(770, 771, 1, 771);
                      break;
                    case 2:
                      t3.blendFunc(770, 1);
                      break;
                    case 3:
                      t3.blendFunc(0, 769);
                      break;
                    case 4:
                      t3.blendFunc(0, 768);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e5);
                  }
                v3 = null, y3 = null, w3 = null, _3 = null, m3 = e5, M3 = l5;
              }
            } else
              f3 && (H2(3042), f3 = false);
          }
          function j2(e5) {
            S3 !== e5 && (e5 ? t3.frontFace(2304) : t3.frontFace(2305), S3 = e5);
          }
          function k2(e5) {
            e5 !== 0 ? (U2(2884), e5 !== T3 && (e5 === 1 ? t3.cullFace(1029) : e5 === 2 ? t3.cullFace(1028) : t3.cullFace(1032))) : H2(2884), T3 = e5;
          }
          function W2(e5, r4, n3) {
            e5 ? (U2(32823), A3 === r4 && L3 === n3 || (t3.polygonOffset(r4, n3), A3 = r4, L3 = n3)) : H2(32823);
          }
          function q2(e5) {
            e5 === void 0 && (e5 = 33984 + R2 - 1), D2 !== e5 && (t3.activeTexture(e5), D2 = e5);
          }
          return F2[3553] = B2(3553, 3553, 1), F2[34067] = B2(34067, 34069, 6), i3.setClear(0, 0, 0, 1), a3.setClear(1), o5.setClear(0), U2(2929), a3.setFunc(3), j2(false), k2(1), U2(2884), V2(0), { buffers: { color: i3, depth: a3, stencil: o5 }, initAttributes: function() {
            for (var t4 = 0, e5 = c3.length; t4 < e5; t4++)
              c3[t4] = 0;
          }, enableAttribute: function(t4) {
            G2(t4, 0);
          }, enableAttributeAndDivisor: G2, disableUnusedAttributes: function() {
            for (var e5 = 0, r4 = l4.length; e5 !== r4; ++e5)
              l4[e5] !== c3[e5] && (t3.disableVertexAttribArray(e5), l4[e5] = 0);
          }, enable: U2, disable: H2, getCompressedTextureFormats: function() {
            if (p3 === null && (p3 = [], e4.get("WEBGL_compressed_texture_pvrtc") || e4.get("WEBGL_compressed_texture_s3tc") || e4.get("WEBGL_compressed_texture_etc1") || e4.get("WEBGL_compressed_texture_astc")))
              for (var r4 = t3.getParameter(34467), n3 = 0; n3 < r4.length; n3++)
                p3.push(r4[n3]);
            return p3;
          }, useProgram: function(e5) {
            return d3 !== e5 && (t3.useProgram(e5), d3 = e5, true);
          }, setBlending: V2, setMaterial: function(t4, e5) {
            t4.side === 2 ? H2(2884) : U2(2884);
            var r4 = t4.side === 1;
            e5 && (r4 = !r4), j2(r4), t4.blending === 1 && t4.transparent === false ? V2(0) : V2(t4.blending, t4.blendEquation, t4.blendSrc, t4.blendDst, t4.blendEquationAlpha, t4.blendSrcAlpha, t4.blendDstAlpha, t4.premultipliedAlpha), a3.setFunc(t4.depthFunc), a3.setTest(t4.depthTest), a3.setMask(t4.depthWrite), i3.setMask(t4.colorWrite);
            var n3 = t4.stencilWrite;
            o5.setTest(n3), n3 && (o5.setFunc(t4.stencilFunc, t4.stencilRef, t4.stencilMask), o5.setOp(t4.stencilFail, t4.stencilZFail, t4.stencilZPass)), W2(t4.polygonOffset, t4.polygonOffsetFactor, t4.polygonOffsetUnits);
          }, setFlipSided: j2, setCullFace: k2, setLineWidth: function(e5) {
            e5 !== E4 && (P3 && t3.lineWidth(e5), E4 = e5);
          }, setPolygonOffset: W2, setScissorTest: function(t4) {
            t4 ? U2(3089) : H2(3089);
          }, activeTexture: q2, bindTexture: function(e5, r4) {
            D2 === null && q2();
            var n3 = N2[D2];
            n3 === void 0 && (n3 = { type: void 0, texture: void 0 }, N2[D2] = n3), n3.type === e5 && n3.texture === r4 || (t3.bindTexture(e5, r4 || F2[e5]), n3.type = e5, n3.texture = r4);
          }, compressedTexImage2D: function() {
            try {
              t3.compressedTexImage2D.apply(t3, arguments);
            } catch (t4) {
              console.error("THREE.WebGLState:", t4);
            }
          }, texImage2D: function() {
            try {
              t3.texImage2D.apply(t3, arguments);
            } catch (t4) {
              console.error("THREE.WebGLState:", t4);
            }
          }, texImage3D: function() {
            try {
              t3.texImage3D.apply(t3, arguments);
            } catch (t4) {
              console.error("THREE.WebGLState:", t4);
            }
          }, scissor: function(e5) {
            I2.equals(e5) === false && (t3.scissor(e5.x, e5.y, e5.z, e5.w), I2.copy(e5));
          }, viewport: function(e5) {
            z2.equals(e5) === false && (t3.viewport(e5.x, e5.y, e5.z, e5.w), z2.copy(e5));
          }, reset: function() {
            for (var e5 = 0; e5 < l4.length; e5++)
              l4[e5] === 1 && (t3.disableVertexAttribArray(e5), l4[e5] = 0);
            u3 = {}, p3 = null, D2 = null, N2 = {}, d3 = null, m3 = null, S3 = null, T3 = null, i3.reset(), a3.reset(), o5.reset();
          } };
        }
        function Hn(t3, e4, r3, n2, a3, o5, c3) {
          var l4, h3 = /* @__PURE__ */ new WeakMap(), u3 = typeof OffscreenCanvas != "undefined";
          function p3(t4, e5) {
            return u3 ? new OffscreenCanvas(t4, e5) : i2.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
          }
          function d3(t4, e5, r4, n3) {
            var i3 = 1;
            if ((t4.width > n3 || t4.height > n3) && (i3 = n3 / Math.max(t4.width, t4.height)), i3 < 1 || e5 === true) {
              if (typeof HTMLImageElement != "undefined" && t4 instanceof HTMLImageElement || typeof ImageBitmap != "undefined" && t4 instanceof ImageBitmap) {
                var a4 = e5 ? s3.floorPowerOfTwo : Math.floor, o6 = a4(i3 * t4.width), c4 = a4(i3 * t4.height);
                l4 === void 0 && (l4 = p3(o6, c4));
                var h4 = r4 ? p3(o6, c4) : l4;
                return h4.width = o6, h4.height = c4, h4.getContext("2d").drawImage(t4, 0, 0, o6, c4), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t4.width + "x" + t4.height + ") to (" + o6 + "x" + c4 + ")."), h4;
              }
              return "data" in t4 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t4.width + "x" + t4.height + ")."), t4;
            }
            return t4;
          }
          function f3(t4) {
            return s3.isPowerOfTwo(t4.width) && s3.isPowerOfTwo(t4.height);
          }
          function m3(t4, e5) {
            return t4.generateMipmaps && e5 && t4.minFilter !== 1003 && t4.minFilter !== 1006;
          }
          function g3(e5, r4, i3, a4) {
            t3.generateMipmap(e5), n2.get(r4).__maxMipLevel = Math.log(Math.max(i3, a4)) * Math.LOG2E;
          }
          function v3(t4, r4) {
            if (!a3.isWebGL2)
              return t4;
            var n3 = t4;
            return t4 === 6403 && (r4 === 5126 && (n3 = 33326), r4 === 5131 && (n3 = 33325), r4 === 5121 && (n3 = 33321)), t4 === 6407 && (r4 === 5126 && (n3 = 34837), r4 === 5131 && (n3 = 34843), r4 === 5121 && (n3 = 32849)), t4 === 6408 && (r4 === 5126 && (n3 = 34836), r4 === 5131 && (n3 = 34842), r4 === 5121 && (n3 = 32856)), n3 === 33325 || n3 === 33326 || n3 === 34842 || n3 === 34836 ? e4.get("EXT_color_buffer_float") : n3 !== 34843 && n3 !== 34837 || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), n3;
          }
          function y3(t4) {
            return t4 === 1003 || t4 === 1004 || t4 === 1005 ? 9728 : 9729;
          }
          function x3(e5) {
            var r4 = e5.target;
            r4.removeEventListener("dispose", x3), function(e6) {
              var r5 = n2.get(e6);
              r5.__webglInit !== void 0 && (t3.deleteTexture(r5.__webglTexture), n2.remove(e6));
            }(r4), r4.isVideoTexture && h3.delete(r4), c3.memory.textures--;
          }
          function b3(e5) {
            var r4 = e5.target;
            r4.removeEventListener("dispose", b3), function(e6) {
              var r5 = n2.get(e6), i3 = n2.get(e6.texture);
              if (e6) {
                if (i3.__webglTexture !== void 0 && t3.deleteTexture(i3.__webglTexture), e6.depthTexture && e6.depthTexture.dispose(), e6.isWebGLRenderTargetCube)
                  for (var a4 = 0; a4 < 6; a4++)
                    t3.deleteFramebuffer(r5.__webglFramebuffer[a4]), r5.__webglDepthbuffer && t3.deleteRenderbuffer(r5.__webglDepthbuffer[a4]);
                else
                  t3.deleteFramebuffer(r5.__webglFramebuffer), r5.__webglDepthbuffer && t3.deleteRenderbuffer(r5.__webglDepthbuffer);
                n2.remove(e6.texture), n2.remove(e6);
              }
            }(r4), c3.memory.textures--;
          }
          var w3 = 0;
          function _3(t4, e5) {
            var i3 = n2.get(t4);
            if (t4.isVideoTexture && function(t5) {
              var e6 = c3.render.frame;
              h3.get(t5) !== e6 && (h3.set(t5, e6), t5.update());
            }(t4), t4.version > 0 && i3.__version !== t4.version) {
              var a4 = t4.image;
              if (a4 === void 0)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
              else {
                if (a4.complete !== false)
                  return void A3(i3, t4, e5);
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
              }
            }
            r3.activeTexture(33984 + e5), r3.bindTexture(3553, i3.__webglTexture);
          }
          function M3(e5, i3) {
            if (e5.image.length === 6) {
              var s4 = n2.get(e5);
              if (e5.version > 0 && s4.__version !== e5.version) {
                E4(s4, e5), r3.activeTexture(33984 + i3), r3.bindTexture(34067, s4.__webglTexture), t3.pixelStorei(37440, e5.flipY);
                for (var c4 = e5 && e5.isCompressedTexture, l5 = e5.image[0] && e5.image[0].isDataTexture, h4 = [], u4 = 0; u4 < 6; u4++)
                  h4[u4] = c4 || l5 ? l5 ? e5.image[u4].image : e5.image[u4] : d3(e5.image[u4], false, true, a3.maxCubemapSize);
                var p4, y4 = h4[0], x4 = f3(y4) || a3.isWebGL2, b4 = o5.convert(e5.format), w4 = o5.convert(e5.type), _4 = v3(b4, w4);
                if (T3(34067, e5, x4), c4) {
                  for (u4 = 0; u4 < 6; u4++) {
                    p4 = h4[u4].mipmaps;
                    for (var M4 = 0; M4 < p4.length; M4++) {
                      var S4 = p4[M4];
                      e5.format !== 1023 && e5.format !== 1022 ? r3.getCompressedTextureFormats().indexOf(b4) > -1 ? r3.compressedTexImage2D(34069 + u4, M4, _4, S4.width, S4.height, 0, S4.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : r3.texImage2D(34069 + u4, M4, _4, S4.width, S4.height, 0, b4, w4, S4.data);
                    }
                  }
                  s4.__maxMipLevel = p4.length - 1;
                } else {
                  for (p4 = e5.mipmaps, u4 = 0; u4 < 6; u4++)
                    if (l5)
                      for (r3.texImage2D(34069 + u4, 0, _4, h4[u4].width, h4[u4].height, 0, b4, w4, h4[u4].data), M4 = 0; M4 < p4.length; M4++) {
                        var A4 = (S4 = p4[M4]).image[u4].image;
                        r3.texImage2D(34069 + u4, M4 + 1, _4, A4.width, A4.height, 0, b4, w4, A4.data);
                      }
                    else
                      for (r3.texImage2D(34069 + u4, 0, _4, b4, w4, h4[u4]), M4 = 0; M4 < p4.length; M4++)
                        S4 = p4[M4], r3.texImage2D(34069 + u4, M4 + 1, _4, b4, w4, S4.image[u4]);
                  s4.__maxMipLevel = p4.length;
                }
                m3(e5, x4) && g3(34067, e5, y4.width, y4.height), s4.__version = e5.version, e5.onUpdate && e5.onUpdate(e5);
              } else
                r3.activeTexture(33984 + i3), r3.bindTexture(34067, s4.__webglTexture);
            }
          }
          function S3(t4, e5) {
            r3.activeTexture(33984 + e5), r3.bindTexture(34067, n2.get(t4).__webglTexture);
          }
          function T3(r4, i3, s4) {
            var c4;
            if (s4 ? (t3.texParameteri(r4, 10242, o5.convert(i3.wrapS)), t3.texParameteri(r4, 10243, o5.convert(i3.wrapT)), r4 !== 32879 && r4 !== 35866 || t3.texParameteri(r4, 32882, o5.convert(i3.wrapR)), t3.texParameteri(r4, 10240, o5.convert(i3.magFilter)), t3.texParameteri(r4, 10241, o5.convert(i3.minFilter))) : (t3.texParameteri(r4, 10242, 33071), t3.texParameteri(r4, 10243, 33071), r4 !== 32879 && r4 !== 35866 || t3.texParameteri(r4, 32882, 33071), i3.wrapS === 1001 && i3.wrapT === 1001 || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t3.texParameteri(r4, 10240, y3(i3.magFilter)), t3.texParameteri(r4, 10241, y3(i3.minFilter)), i3.minFilter !== 1003 && i3.minFilter !== 1006 && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), c4 = e4.get("EXT_texture_filter_anisotropic")) {
              if (i3.type === 1015 && e4.get("OES_texture_float_linear") === null)
                return;
              if (i3.type === 1016 && (a3.isWebGL2 || e4.get("OES_texture_half_float_linear")) === null)
                return;
              (i3.anisotropy > 1 || n2.get(i3).__currentAnisotropy) && (t3.texParameterf(r4, c4.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i3.anisotropy, a3.getMaxAnisotropy())), n2.get(i3).__currentAnisotropy = i3.anisotropy);
            }
          }
          function E4(e5, r4) {
            e5.__webglInit === void 0 && (e5.__webglInit = true, r4.addEventListener("dispose", x3), e5.__webglTexture = t3.createTexture(), c3.memory.textures++);
          }
          function A3(e5, n3, i3) {
            var s4 = 3553;
            n3.isDataTexture2DArray && (s4 = 35866), n3.isDataTexture3D && (s4 = 32879), E4(e5, n3), r3.activeTexture(33984 + i3), r3.bindTexture(s4, e5.__webglTexture), t3.pixelStorei(37440, n3.flipY), t3.pixelStorei(37441, n3.premultiplyAlpha), t3.pixelStorei(3317, n3.unpackAlignment);
            var c4 = function(t4) {
              return !a3.isWebGL2 && (t4.wrapS !== 1001 || t4.wrapT !== 1001 || t4.minFilter !== 1003 && t4.minFilter !== 1006);
            }(n3) && f3(n3.image) === false, l5 = d3(n3.image, c4, false, a3.maxTextureSize), h4 = f3(l5) || a3.isWebGL2, u4 = o5.convert(n3.format), p4 = o5.convert(n3.type), y4 = v3(u4, p4);
            T3(s4, n3, h4);
            var x4, b4 = n3.mipmaps;
            if (n3.isDepthTexture) {
              if (y4 = 6402, n3.type === 1015) {
                if (!a3.isWebGL2)
                  throw new Error("Float Depth Texture only supported in WebGL2.0");
                y4 = 36012;
              } else
                a3.isWebGL2 && (y4 = 33189);
              n3.format === 1026 && y4 === 6402 && n3.type !== 1012 && n3.type !== 1014 && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n3.type = 1012, p4 = o5.convert(n3.type)), n3.format === 1027 && (y4 = 34041, n3.type !== 1020 && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n3.type = 1020, p4 = o5.convert(n3.type))), r3.texImage2D(3553, 0, y4, l5.width, l5.height, 0, u4, p4, null);
            } else if (n3.isDataTexture)
              if (b4.length > 0 && h4) {
                for (var w4 = 0, _4 = b4.length; w4 < _4; w4++)
                  x4 = b4[w4], r3.texImage2D(3553, w4, y4, x4.width, x4.height, 0, u4, p4, x4.data);
                n3.generateMipmaps = false, e5.__maxMipLevel = b4.length - 1;
              } else
                r3.texImage2D(3553, 0, y4, l5.width, l5.height, 0, u4, p4, l5.data), e5.__maxMipLevel = 0;
            else if (n3.isCompressedTexture) {
              for (w4 = 0, _4 = b4.length; w4 < _4; w4++)
                x4 = b4[w4], n3.format !== 1023 && n3.format !== 1022 ? r3.getCompressedTextureFormats().indexOf(u4) > -1 ? r3.compressedTexImage2D(3553, w4, y4, x4.width, x4.height, 0, x4.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : r3.texImage2D(3553, w4, y4, x4.width, x4.height, 0, u4, p4, x4.data);
              e5.__maxMipLevel = b4.length - 1;
            } else if (n3.isDataTexture2DArray)
              r3.texImage3D(35866, 0, y4, l5.width, l5.height, l5.depth, 0, u4, p4, l5.data), e5.__maxMipLevel = 0;
            else if (n3.isDataTexture3D)
              r3.texImage3D(32879, 0, y4, l5.width, l5.height, l5.depth, 0, u4, p4, l5.data), e5.__maxMipLevel = 0;
            else if (b4.length > 0 && h4) {
              for (w4 = 0, _4 = b4.length; w4 < _4; w4++)
                x4 = b4[w4], r3.texImage2D(3553, w4, y4, u4, p4, x4);
              n3.generateMipmaps = false, e5.__maxMipLevel = b4.length - 1;
            } else
              r3.texImage2D(3553, 0, y4, u4, p4, l5), e5.__maxMipLevel = 0;
            m3(n3, h4) && g3(3553, n3, l5.width, l5.height), e5.__version = n3.version, n3.onUpdate && n3.onUpdate(n3);
          }
          function L3(e5, i3, a4, s4) {
            var c4 = o5.convert(i3.texture.format), l5 = o5.convert(i3.texture.type), h4 = v3(c4, l5);
            r3.texImage2D(s4, 0, h4, i3.width, i3.height, 0, c4, l5, null), t3.bindFramebuffer(36160, e5), t3.framebufferTexture2D(36160, a4, s4, n2.get(i3.texture).__webglTexture, 0), t3.bindFramebuffer(36160, null);
          }
          function R2(e5, r4, n3) {
            if (t3.bindRenderbuffer(36161, e5), r4.depthBuffer && !r4.stencilBuffer) {
              if (n3) {
                var i3 = C2(r4);
                t3.renderbufferStorageMultisample(36161, i3, 33189, r4.width, r4.height);
              } else
                t3.renderbufferStorage(36161, 33189, r4.width, r4.height);
              t3.framebufferRenderbuffer(36160, 36096, 36161, e5);
            } else if (r4.depthBuffer && r4.stencilBuffer)
              n3 ? (i3 = C2(r4), t3.renderbufferStorageMultisample(36161, i3, 35056, r4.width, r4.height)) : t3.renderbufferStorage(36161, 34041, r4.width, r4.height), t3.framebufferRenderbuffer(36160, 33306, 36161, e5);
            else {
              var a4 = v3(o5.convert(r4.texture.format), o5.convert(r4.texture.type));
              n3 ? (i3 = C2(r4), t3.renderbufferStorageMultisample(36161, i3, a4, r4.width, r4.height)) : t3.renderbufferStorage(36161, a4, r4.width, r4.height);
            }
            t3.bindRenderbuffer(36161, null);
          }
          function P3(e5) {
            var r4 = n2.get(e5), i3 = e5.isWebGLRenderTargetCube === true;
            if (e5.depthTexture) {
              if (i3)
                throw new Error("target.depthTexture not supported in Cube render targets");
              !function(e6, r5) {
                if (r5 && r5.isWebGLRenderTargetCube)
                  throw new Error("Depth Texture with cube render targets is not supported");
                if (t3.bindFramebuffer(36160, e6), !r5.depthTexture || !r5.depthTexture.isDepthTexture)
                  throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                n2.get(r5.depthTexture).__webglTexture && r5.depthTexture.image.width === r5.width && r5.depthTexture.image.height === r5.height || (r5.depthTexture.image.width = r5.width, r5.depthTexture.image.height = r5.height, r5.depthTexture.needsUpdate = true), _3(r5.depthTexture, 0);
                var i4 = n2.get(r5.depthTexture).__webglTexture;
                if (r5.depthTexture.format === 1026)
                  t3.framebufferTexture2D(36160, 36096, 3553, i4, 0);
                else {
                  if (r5.depthTexture.format !== 1027)
                    throw new Error("Unknown depthTexture format");
                  t3.framebufferTexture2D(36160, 33306, 3553, i4, 0);
                }
              }(r4.__webglFramebuffer, e5);
            } else if (i3) {
              r4.__webglDepthbuffer = [];
              for (var a4 = 0; a4 < 6; a4++)
                t3.bindFramebuffer(36160, r4.__webglFramebuffer[a4]), r4.__webglDepthbuffer[a4] = t3.createRenderbuffer(), R2(r4.__webglDepthbuffer[a4], e5);
            } else
              t3.bindFramebuffer(36160, r4.__webglFramebuffer), r4.__webglDepthbuffer = t3.createRenderbuffer(), R2(r4.__webglDepthbuffer, e5);
            t3.bindFramebuffer(36160, null);
          }
          function C2(t4) {
            return a3.isWebGL2 && t4.isWebGLMultisampleRenderTarget ? Math.min(a3.maxSamples, t4.samples) : 0;
          }
          var O2 = false, D2 = false;
          this.allocateTextureUnit = function() {
            var t4 = w3;
            return t4 >= a3.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + t4 + " texture units while this GPU supports only " + a3.maxTextures), w3 += 1, t4;
          }, this.resetTextureUnits = function() {
            w3 = 0;
          }, this.setTexture2D = _3, this.setTexture2DArray = function(t4, e5) {
            var i3 = n2.get(t4);
            t4.version > 0 && i3.__version !== t4.version ? A3(i3, t4, e5) : (r3.activeTexture(33984 + e5), r3.bindTexture(35866, i3.__webglTexture));
          }, this.setTexture3D = function(t4, e5) {
            var i3 = n2.get(t4);
            t4.version > 0 && i3.__version !== t4.version ? A3(i3, t4, e5) : (r3.activeTexture(33984 + e5), r3.bindTexture(32879, i3.__webglTexture));
          }, this.setTextureCube = M3, this.setTextureCubeDynamic = S3, this.setupRenderTarget = function(e5) {
            var i3 = n2.get(e5), s4 = n2.get(e5.texture);
            e5.addEventListener("dispose", b3), s4.__webglTexture = t3.createTexture(), c3.memory.textures++;
            var l5 = e5.isWebGLRenderTargetCube === true, h4 = e5.isWebGLMultisampleRenderTarget === true, u4 = f3(e5) || a3.isWebGL2;
            if (l5) {
              i3.__webglFramebuffer = [];
              for (var p4 = 0; p4 < 6; p4++)
                i3.__webglFramebuffer[p4] = t3.createFramebuffer();
            } else if (i3.__webglFramebuffer = t3.createFramebuffer(), h4)
              if (a3.isWebGL2) {
                i3.__webglMultisampledFramebuffer = t3.createFramebuffer(), i3.__webglColorRenderbuffer = t3.createRenderbuffer(), t3.bindRenderbuffer(36161, i3.__webglColorRenderbuffer);
                var d4 = v3(o5.convert(e5.texture.format), o5.convert(e5.texture.type)), y4 = C2(e5);
                t3.renderbufferStorageMultisample(36161, y4, d4, e5.width, e5.height), t3.bindFramebuffer(36160, i3.__webglMultisampledFramebuffer), t3.framebufferRenderbuffer(36160, 36064, 36161, i3.__webglColorRenderbuffer), t3.bindRenderbuffer(36161, null), e5.depthBuffer && (i3.__webglDepthRenderbuffer = t3.createRenderbuffer(), R2(i3.__webglDepthRenderbuffer, e5, true)), t3.bindFramebuffer(36160, null);
              } else
                console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (l5) {
              for (r3.bindTexture(34067, s4.__webglTexture), T3(34067, e5.texture, u4), p4 = 0; p4 < 6; p4++)
                L3(i3.__webglFramebuffer[p4], e5, 36064, 34069 + p4);
              m3(e5.texture, u4) && g3(34067, e5.texture, e5.width, e5.height), r3.bindTexture(34067, null);
            } else
              r3.bindTexture(3553, s4.__webglTexture), T3(3553, e5.texture, u4), L3(i3.__webglFramebuffer, e5, 36064, 3553), m3(e5.texture, u4) && g3(3553, e5.texture, e5.width, e5.height), r3.bindTexture(3553, null);
            e5.depthBuffer && P3(e5);
          }, this.updateRenderTargetMipmap = function(t4) {
            var e5 = t4.texture;
            if (m3(e5, f3(t4) || a3.isWebGL2)) {
              var i3 = t4.isWebGLRenderTargetCube ? 34067 : 3553, o6 = n2.get(e5).__webglTexture;
              r3.bindTexture(i3, o6), g3(i3, e5, t4.width, t4.height), r3.bindTexture(i3, null);
            }
          }, this.updateMultisampleRenderTarget = function(e5) {
            if (e5.isWebGLMultisampleRenderTarget)
              if (a3.isWebGL2) {
                var r4 = n2.get(e5);
                t3.bindFramebuffer(36008, r4.__webglMultisampledFramebuffer), t3.bindFramebuffer(36009, r4.__webglFramebuffer);
                var i3 = e5.width, o6 = e5.height, s4 = 16384;
                e5.depthBuffer && (s4 |= 256), e5.stencilBuffer && (s4 |= 1024), t3.blitFramebuffer(0, 0, i3, o6, 0, 0, i3, o6, s4, 9728);
              } else
                console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          }, this.safeSetTexture2D = function(t4, e5) {
            t4 && t4.isWebGLRenderTarget && (O2 === false && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), O2 = true), t4 = t4.texture), _3(t4, e5);
          }, this.safeSetTextureCube = function(t4, e5) {
            t4 && t4.isWebGLRenderTargetCube && (D2 === false && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), D2 = true), t4 = t4.texture), t4 && t4.isCubeTexture || Array.isArray(t4.image) && t4.image.length === 6 ? M3(t4, e5) : S3(t4, e5);
          };
        }
        function Vn(t3, e4, r3) {
          return { convert: function(t4) {
            var n2;
            if (t4 === 1e3)
              return 10497;
            if (t4 === 1001)
              return 33071;
            if (t4 === 1002)
              return 33648;
            if (t4 === 1003)
              return 9728;
            if (t4 === 1004)
              return 9984;
            if (t4 === 1005)
              return 9986;
            if (t4 === 1006)
              return 9729;
            if (t4 === 1007)
              return 9985;
            if (t4 === 1008)
              return 9987;
            if (t4 === 1009)
              return 5121;
            if (t4 === 1017)
              return 32819;
            if (t4 === 1018)
              return 32820;
            if (t4 === 1019)
              return 33635;
            if (t4 === 1010)
              return 5120;
            if (t4 === 1011)
              return 5122;
            if (t4 === 1012)
              return 5123;
            if (t4 === 1013)
              return 5124;
            if (t4 === 1014)
              return 5125;
            if (t4 === 1015)
              return 5126;
            if (t4 === 1016) {
              if (r3.isWebGL2)
                return 5131;
              if ((n2 = e4.get("OES_texture_half_float")) !== null)
                return n2.HALF_FLOAT_OES;
            }
            if (t4 === 1021)
              return 6406;
            if (t4 === 1022)
              return 6407;
            if (t4 === 1023)
              return 6408;
            if (t4 === 1024)
              return 6409;
            if (t4 === 1025)
              return 6410;
            if (t4 === 1026)
              return 6402;
            if (t4 === 1027)
              return 34041;
            if (t4 === 1028)
              return 6403;
            if (t4 === 100)
              return 32774;
            if (t4 === 101)
              return 32778;
            if (t4 === 102)
              return 32779;
            if (t4 === 200)
              return 0;
            if (t4 === 201)
              return 1;
            if (t4 === 202)
              return 768;
            if (t4 === 203)
              return 769;
            if (t4 === 204)
              return 770;
            if (t4 === 205)
              return 771;
            if (t4 === 206)
              return 772;
            if (t4 === 207)
              return 773;
            if (t4 === 208)
              return 774;
            if (t4 === 209)
              return 775;
            if (t4 === 210)
              return 776;
            if ((t4 === 33776 || t4 === 33777 || t4 === 33778 || t4 === 33779) && (n2 = e4.get("WEBGL_compressed_texture_s3tc")) !== null) {
              if (t4 === 33776)
                return n2.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (t4 === 33777)
                return n2.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (t4 === 33778)
                return n2.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (t4 === 33779)
                return n2.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
            if ((t4 === 35840 || t4 === 35841 || t4 === 35842 || t4 === 35843) && (n2 = e4.get("WEBGL_compressed_texture_pvrtc")) !== null) {
              if (t4 === 35840)
                return n2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (t4 === 35841)
                return n2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (t4 === 35842)
                return n2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (t4 === 35843)
                return n2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (t4 === 36196 && (n2 = e4.get("WEBGL_compressed_texture_etc1")) !== null)
              return n2.COMPRESSED_RGB_ETC1_WEBGL;
            if ((t4 === 37808 || t4 === 37809 || t4 === 37810 || t4 === 37811 || t4 === 37812 || t4 === 37813 || t4 === 37814 || t4 === 37815 || t4 === 37816 || t4 === 37817 || t4 === 37818 || t4 === 37819 || t4 === 37820 || t4 === 37821) && (n2 = e4.get("WEBGL_compressed_texture_astc")) !== null)
              return t4;
            if (t4 === 103 || t4 === 104) {
              if (r3.isWebGL2) {
                if (t4 === 103)
                  return 32775;
                if (t4 === 104)
                  return 32776;
              }
              if ((n2 = e4.get("EXT_blend_minmax")) !== null) {
                if (t4 === 103)
                  return n2.MIN_EXT;
                if (t4 === 104)
                  return n2.MAX_EXT;
              }
            }
            if (t4 === 1020) {
              if (r3.isWebGL2)
                return 34042;
              if ((n2 = e4.get("WEBGL_depth_texture")) !== null)
                return n2.UNSIGNED_INT_24_8_WEBGL;
            }
            return 0;
          } };
        }
        function jn() {
          Y.call(this), this.type = "Group";
        }
        function kn(t3) {
          Ue.call(this), this.cameras = t3 || [];
        }
        Bn.prototype = Object.create(Ut.prototype), Bn.prototype.constructor = Bn, Bn.prototype.isMeshDepthMaterial = true, Bn.prototype.copy = function(t3) {
          return Ut.prototype.copy.call(this, t3), this.depthPacking = t3.depthPacking, this.skinning = t3.skinning, this.morphTargets = t3.morphTargets, this.map = t3.map, this.alphaMap = t3.alphaMap, this.displacementMap = t3.displacementMap, this.displacementScale = t3.displacementScale, this.displacementBias = t3.displacementBias, this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this;
        }, Fn.prototype = Object.create(Ut.prototype), Fn.prototype.constructor = Fn, Fn.prototype.isMeshDistanceMaterial = true, Fn.prototype.copy = function(t3) {
          return Ut.prototype.copy.call(this, t3), this.referencePosition.copy(t3.referencePosition), this.nearDistance = t3.nearDistance, this.farDistance = t3.farDistance, this.skinning = t3.skinning, this.morphTargets = t3.morphTargets, this.map = t3.map, this.alphaMap = t3.alphaMap, this.displacementMap = t3.displacementMap, this.displacementScale = t3.displacementScale, this.displacementBias = t3.displacementBias, this;
        }, jn.prototype = Object.assign(Object.create(Y.prototype), { constructor: jn, isGroup: true }), kn.prototype = Object.assign(Object.create(Ue.prototype), { constructor: kn, isArrayCamera: true });
        var Wn, qn = new d2(), Xn = new d2();
        function Yn(t3, e4, r3) {
          qn.setFromMatrixPosition(e4.matrixWorld), Xn.setFromMatrixPosition(r3.matrixWorld);
          var n2 = qn.distanceTo(Xn), i3 = e4.projectionMatrix.elements, a3 = r3.projectionMatrix.elements, o5 = i3[14] / (i3[10] - 1), s4 = i3[14] / (i3[10] + 1), c3 = (i3[9] + 1) / i3[5], l4 = (i3[9] - 1) / i3[5], h3 = (i3[8] - 1) / i3[0], u3 = (a3[8] + 1) / a3[0], p3 = o5 * h3, d3 = o5 * u3, f3 = n2 / (-h3 + u3), m3 = f3 * -h3;
          e4.matrixWorld.decompose(t3.position, t3.quaternion, t3.scale), t3.translateX(m3), t3.translateZ(f3), t3.matrixWorld.compose(t3.position, t3.quaternion, t3.scale), t3.matrixWorldInverse.getInverse(t3.matrixWorld);
          var g3 = o5 + f3, v3 = s4 + f3, y3 = p3 - m3, x3 = d3 + (n2 - m3), b3 = c3 * s4 / v3 * g3, w3 = l4 * s4 / v3 * g3;
          t3.projectionMatrix.makePerspective(y3, x3, b3, w3, g3, v3);
        }
        function Jn(t3) {
          var e4, r3, n2 = this, i3 = null, o5 = null, s4 = null, c3 = [], u3 = new P2(), p3 = new P2(), f3 = 1, m3 = "local-floor";
          a2 !== void 0 && "VRFrameData" in a2 && (o5 = new a2.VRFrameData(), a2.addEventListener("vrdisplaypresentchange", E4, false));
          var g3 = new P2(), v3 = new h2(), y3 = new d2(), b3 = new Ue();
          b3.viewport = new x2(), b3.layers.enable(1);
          var w3 = new Ue();
          w3.viewport = new x2(), w3.layers.enable(2);
          var _3 = new kn([b3, w3]);
          function M3() {
            return i3 !== null && i3.isPresenting === true;
          }
          _3.layers.enable(1), _3.layers.enable(2);
          var S3, T3 = new l3();
          function E4() {
            if (M3()) {
              var a3 = i3.getEyeParameters("left");
              e4 = 2 * a3.renderWidth * f3, r3 = a3.renderHeight * f3, S3 = t3.getPixelRatio(), t3.getSize(T3), t3.setDrawingBufferSize(e4, r3, 1), b3.viewport.set(0, 0, e4 / 2, r3), w3.viewport.set(e4 / 2, 0, e4 / 2, r3), C2.start(), n2.dispatchEvent({ type: "sessionstart" });
            } else
              n2.enabled && t3.setDrawingBufferSize(T3.width, T3.height, S3), C2.stop(), n2.dispatchEvent({ type: "sessionend" });
          }
          var A3 = [];
          function L3(t4) {
            for (var e5 = navigator.getGamepads && navigator.getGamepads(), r4 = 0, n3 = 0, i4 = e5.length; r4 < i4; r4++) {
              var a3 = e5[r4];
              if (a3 && (a3.id === "Daydream Controller" || a3.id === "Gear VR Controller" || a3.id === "Oculus Go Controller" || a3.id === "OpenVR Gamepad" || a3.id.startsWith("Oculus Touch") || a3.id.startsWith("HTC Vive Focus") || a3.id.startsWith("Spatial Controller"))) {
                if (n3 === t4)
                  return a3;
                n3++;
              }
            }
          }
          function R2(t4, n3) {
            n3 !== null && n3.length === 4 && t4.set(n3[0] * e4, n3[1] * r3, n3[2] * e4, n3[3] * r3);
          }
          this.enabled = false, this.getController = function(t4) {
            var e5 = c3[t4];
            return e5 === void 0 && ((e5 = new jn()).matrixAutoUpdate = false, e5.visible = false, c3[t4] = e5), e5;
          }, this.getDevice = function() {
            return i3;
          }, this.setDevice = function(t4) {
            t4 !== void 0 && (i3 = t4), C2.setContext(t4);
          }, this.setFramebufferScaleFactor = function(t4) {
            f3 = t4;
          }, this.setReferenceSpaceType = function(t4) {
            m3 = t4;
          }, this.setPoseTarget = function(t4) {
            t4 !== void 0 && (s4 = t4);
          }, this.getCamera = function(t4) {
            var e5 = m3 === "local-floor" ? 1.6 : 0;
            if (M3() === false)
              return t4.position.set(0, e5, 0), t4.rotation.set(0, 0, 0), t4;
            if (i3.depthNear = t4.near, i3.depthFar = t4.far, i3.getFrameData(o5), m3 === "local-floor") {
              var r4 = i3.stageParameters;
              r4 ? u3.fromArray(r4.sittingToStandingTransform) : u3.makeTranslation(0, e5, 0);
            }
            var n3 = o5.pose, a3 = s4 !== null ? s4 : t4;
            a3.matrix.copy(u3), a3.matrix.decompose(a3.position, a3.quaternion, a3.scale), n3.orientation !== null && (v3.fromArray(n3.orientation), a3.quaternion.multiply(v3)), n3.position !== null && (v3.setFromRotationMatrix(u3), y3.fromArray(n3.position), y3.applyQuaternion(v3), a3.position.add(y3)), a3.updateMatrixWorld(), b3.near = t4.near, w3.near = t4.near, b3.far = t4.far, w3.far = t4.far, b3.matrixWorldInverse.fromArray(o5.leftViewMatrix), w3.matrixWorldInverse.fromArray(o5.rightViewMatrix), p3.getInverse(u3), m3 === "local-floor" && (b3.matrixWorldInverse.multiply(p3), w3.matrixWorldInverse.multiply(p3));
            var l4 = a3.parent;
            l4 !== null && (g3.getInverse(l4.matrixWorld), b3.matrixWorldInverse.multiply(g3), w3.matrixWorldInverse.multiply(g3)), b3.matrixWorld.getInverse(b3.matrixWorldInverse), w3.matrixWorld.getInverse(w3.matrixWorldInverse), b3.projectionMatrix.fromArray(o5.leftProjectionMatrix), w3.projectionMatrix.fromArray(o5.rightProjectionMatrix), Yn(_3, b3, w3);
            var h3 = i3.getLayers();
            if (h3.length) {
              var d3 = h3[0];
              R2(b3.viewport, d3.leftBounds), R2(w3.viewport, d3.rightBounds);
            }
            return function() {
              for (var t5 = 0; t5 < c3.length; t5++) {
                var e6 = c3[t5], r5 = L3(t5);
                if (r5 !== void 0 && r5.pose !== void 0) {
                  if (r5.pose === null)
                    return;
                  var n4 = r5.pose;
                  n4.hasPosition === false && e6.position.set(0.2, -0.6, -0.05), n4.position !== null && e6.position.fromArray(n4.position), n4.orientation !== null && e6.quaternion.fromArray(n4.orientation), e6.matrix.compose(e6.position, e6.quaternion, e6.scale), e6.matrix.premultiply(u3), e6.matrix.decompose(e6.position, e6.quaternion, e6.scale), e6.matrixWorldNeedsUpdate = true, e6.visible = true;
                  var i4 = r5.id === "Daydream Controller" ? 0 : 1;
                  A3[t5] === void 0 && (A3[t5] = false), A3[t5] !== r5.buttons[i4].pressed && (A3[t5] = r5.buttons[i4].pressed, A3[t5] === true ? e6.dispatchEvent({ type: "selectstart" }) : (e6.dispatchEvent({ type: "selectend" }), e6.dispatchEvent({ type: "select" })));
                } else
                  e6.visible = false;
              }
            }(), _3;
          }, this.getStandingMatrix = function() {
            return u3;
          }, this.isPresenting = M3;
          var C2 = new tr();
          this.setAnimationLoop = function(t4) {
            C2.setAnimationLoop(t4), M3() && C2.start();
          }, this.submitFrame = function() {
            M3() && i3.submitFrame();
          }, this.dispose = function() {
            a2 !== void 0 && a2.removeEventListener("vrdisplaypresentchange", E4);
          }, this.setFrameOfReferenceType = function() {
            console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.");
          };
        }
        function Zn(t3, e4) {
          var r3 = this, n2 = null, i3 = null, a3 = "local-floor", o5 = null, s4 = [], c3 = [];
          function l4() {
            return n2 !== null && i3 !== null;
          }
          var h3 = new Ue();
          h3.layers.enable(1), h3.viewport = new x2();
          var u3 = new Ue();
          u3.layers.enable(2), u3.viewport = new x2();
          var p3 = new kn([h3, u3]);
          function d3(t4) {
            for (var e5 = 0; e5 < s4.length; e5++)
              c3[e5] === t4.inputSource && s4[e5].dispatchEvent({ type: t4.type });
          }
          function f3() {
            t3.setFramebuffer(null), t3.setRenderTarget(t3.getRenderTarget()), y3.stop(), r3.dispatchEvent({ type: "sessionend" });
          }
          function m3(t4) {
            i3 = t4, y3.setContext(n2), y3.start(), r3.dispatchEvent({ type: "sessionstart" });
          }
          function g3(t4, e5) {
            e5 === null ? t4.matrixWorld.copy(t4.matrix) : t4.matrixWorld.multiplyMatrices(e5.matrixWorld, t4.matrix), t4.matrixWorldInverse.getInverse(t4.matrixWorld);
          }
          p3.layers.enable(1), p3.layers.enable(2), this.enabled = false, this.getController = function(t4) {
            var e5 = s4[t4];
            return e5 === void 0 && ((e5 = new jn()).matrixAutoUpdate = false, e5.visible = false, s4[t4] = e5), e5;
          }, this.setFramebufferScaleFactor = function(t4) {
          }, this.setReferenceSpaceType = function(t4) {
            a3 = t4;
          }, this.getSession = function() {
            return n2;
          }, this.setSession = function(t4) {
            (n2 = t4) !== null && (n2.addEventListener("select", d3), n2.addEventListener("selectstart", d3), n2.addEventListener("selectend", d3), n2.addEventListener("end", f3), n2.updateRenderState({ baseLayer: new XRWebGLLayer(n2, e4) }), n2.requestReferenceSpace(a3).then(m3), c3 = n2.inputSources, n2.addEventListener("inputsourceschange", function() {
              c3 = n2.inputSources, console.log(c3);
              for (var t5 = 0; t5 < s4.length; t5++)
                s4[t5].userData.inputSource = c3[t5];
            }));
          }, this.getCamera = function(t4) {
            if (l4()) {
              var e5 = t4.parent, r4 = p3.cameras;
              g3(p3, e5);
              for (var n3 = 0; n3 < r4.length; n3++)
                g3(r4[n3], e5);
              t4.matrixWorld.copy(p3.matrixWorld);
              for (var i4 = t4.children, a4 = (n3 = 0, i4.length); n3 < a4; n3++)
                i4[n3].updateMatrixWorld(true);
              return Yn(p3, h3, u3), p3;
            }
            return t4;
          }, this.isPresenting = l4;
          var v3 = null, y3 = new tr();
          y3.setAnimationLoop(function(e5, r4) {
            if ((o5 = r4.getViewerPose(i3)) !== null) {
              var a4 = o5.views, l5 = n2.renderState.baseLayer;
              t3.setFramebuffer(l5.framebuffer);
              for (var h4 = 0; h4 < a4.length; h4++) {
                var u4 = a4[h4], d4 = l5.getViewport(u4), f4 = u4.transform.inverse.matrix, m4 = p3.cameras[h4];
                m4.matrix.fromArray(f4).getInverse(m4.matrix), m4.projectionMatrix.fromArray(u4.projectionMatrix), m4.viewport.set(d4.x, d4.y, d4.width, d4.height), h4 === 0 && p3.matrix.copy(m4.matrix);
              }
            }
            for (h4 = 0; h4 < s4.length; h4++) {
              var g4 = s4[h4], y4 = c3[h4];
              if (y4) {
                var x3 = r4.getPose(y4.targetRaySpace, i3);
                if (x3 !== null) {
                  g4.matrix.fromArray(x3.transform.matrix), g4.matrix.decompose(g4.position, g4.rotation, g4.scale), g4.visible = true;
                  continue;
                }
              }
              g4.visible = false;
            }
            v3 && v3(e5);
          }), this.setAnimationLoop = function(t4) {
            v3 = t4;
          }, this.dispose = function() {
          }, this.getStandingMatrix = function() {
            return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new P2();
          }, this.getDevice = function() {
            console.warn("THREE.WebXRManager: getDevice() has been deprecated.");
          }, this.setDevice = function() {
            console.warn("THREE.WebXRManager: setDevice() has been deprecated.");
          }, this.setFrameOfReferenceType = function() {
            console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.");
          }, this.submitFrame = function() {
          };
        }
        function Qn(t3) {
          var e4 = (t3 = t3 || {}).canvas !== void 0 ? t3.canvas : i2.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), r3 = t3.context !== void 0 ? t3.context : null, n2 = t3.alpha !== void 0 && t3.alpha, o5 = t3.depth === void 0 || t3.depth, c3 = t3.stencil === void 0 || t3.stencil, h3 = t3.antialias !== void 0 && t3.antialias, u3 = t3.premultipliedAlpha === void 0 || t3.premultipliedAlpha, p3 = t3.preserveDrawingBuffer !== void 0 && t3.preserveDrawingBuffer, f3 = t3.powerPreference !== void 0 ? t3.powerPreference : "default", m3 = t3.failIfMajorPerformanceCaveat !== void 0 && t3.failIfMajorPerformanceCaveat, g3 = null, v3 = null;
          this.domElement = e4, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.gammaInput = false, this.gammaOutput = false, this.physicallyCorrectLights = false, this.toneMapping = 1, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
          var y3, b3, w3, _3, M3, S3, T3, E4, A3, L3, R2, C2, O2, D2, N2, I2, z2, B2, F2 = this, G2 = false, U2 = null, H2 = 0, V2 = 0, j2 = null, k2 = null, W2 = -1, q2 = { geometry: null, program: null, wireframe: false }, X2 = null, Y2 = null, J2 = new x2(), Z2 = new x2(), Q2 = null, K2 = e4.width, $2 = e4.height, tt2 = 1, et2 = new x2(0, 0, K2, $2), rt2 = new x2(0, 0, K2, $2), nt2 = false, it2 = new Ze(), at2 = new sr(), ot2 = false, st2 = false, ct2 = new P2(), lt2 = new d2();
          function ht2() {
            return j2 === null ? tt2 : 1;
          }
          try {
            var ut2 = { alpha: n2, depth: o5, stencil: c3, antialias: h3, premultipliedAlpha: u3, preserveDrawingBuffer: p3, powerPreference: f3, failIfMajorPerformanceCaveat: m3, xrCompatible: true };
            if (e4.addEventListener("webglcontextlost", mt2, false), e4.addEventListener("webglcontextrestored", gt2, false), (y3 = r3 || e4.getContext("webgl", ut2) || e4.getContext("experimental-webgl", ut2)) === null)
              throw e4.getContext("webgl") !== null ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            y3.getShaderPrecisionFormat === void 0 && (y3.getShaderPrecisionFormat = function() {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
          } catch (t4) {
            throw console.error("THREE.WebGLRenderer: " + t4.message), t4;
          }
          function pt2() {
            b3 = new cr(y3), (w3 = new or(y3, b3, t3)).isWebGL2 || (b3.get("WEBGL_depth_texture"), b3.get("OES_texture_float"), b3.get("OES_texture_half_float"), b3.get("OES_texture_half_float_linear"), b3.get("OES_standard_derivatives"), b3.get("OES_element_index_uint"), b3.get("ANGLE_instanced_arrays")), b3.get("OES_texture_float_linear"), B2 = new Vn(y3, b3, w3), (_3 = new Un(y3, b3, B2, w3)).scissor(Z2.copy(rt2).multiplyScalar(tt2).floor()), _3.viewport(J2.copy(et2).multiplyScalar(tt2).floor()), M3 = new ur(y3), S3 = new En(), T3 = new Hn(y3, b3, _3, S3, w3, B2, M3), E4 = new er(y3), A3 = new lr(y3, E4, M3), L3 = new fr(A3, M3), N2 = new dr(y3), R2 = new Tn(F2, b3, w3), C2 = new Pn(), O2 = new zn(), D2 = new ir(F2, _3, L3, u3), I2 = new ar(y3, b3, M3, w3), z2 = new hr(y3, b3, M3, w3), M3.programs = R2.programs, F2.capabilities = w3, F2.extensions = b3, F2.properties = S3, F2.renderLists = C2, F2.state = _3, F2.info = M3;
          }
          pt2();
          var dt2 = typeof navigator != "undefined" && "xr" in navigator && "supportsSession" in navigator.xr ? new Zn(F2, y3) : new Jn(F2);
          this.vr = dt2;
          var ft2 = new Gn(F2, L3, w3.maxTextureSize);
          function mt2(t4) {
            t4.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), G2 = true;
          }
          function gt2() {
            console.log("THREE.WebGLRenderer: Context Restored."), G2 = false, pt2();
          }
          function vt2(t4) {
            var e5 = t4.target;
            e5.removeEventListener("dispose", vt2), function(t5) {
              yt2(t5), S3.remove(t5);
            }(e5);
          }
          function yt2(t4) {
            var e5 = S3.get(t4).program;
            t4.program = void 0, e5 !== void 0 && R2.releaseProgram(e5);
          }
          this.shadowMap = ft2, this.getContext = function() {
            return y3;
          }, this.getContextAttributes = function() {
            return y3.getContextAttributes();
          }, this.forceContextLoss = function() {
            var t4 = b3.get("WEBGL_lose_context");
            t4 && t4.loseContext();
          }, this.forceContextRestore = function() {
            var t4 = b3.get("WEBGL_lose_context");
            t4 && t4.restoreContext();
          }, this.getPixelRatio = function() {
            return tt2;
          }, this.setPixelRatio = function(t4) {
            t4 !== void 0 && (tt2 = t4, this.setSize(K2, $2, false));
          }, this.getSize = function(t4) {
            return t4 === void 0 && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t4 = new l3()), t4.set(K2, $2);
          }, this.setSize = function(t4, r4, n3) {
            dt2.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (K2 = t4, $2 = r4, e4.width = Math.floor(t4 * tt2), e4.height = Math.floor(r4 * tt2), n3 !== false && (e4.style.width = t4 + "px", e4.style.height = r4 + "px"), this.setViewport(0, 0, t4, r4));
          }, this.getDrawingBufferSize = function(t4) {
            return t4 === void 0 && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t4 = new l3()), t4.set(K2 * tt2, $2 * tt2).floor();
          }, this.setDrawingBufferSize = function(t4, r4, n3) {
            K2 = t4, $2 = r4, tt2 = n3, e4.width = Math.floor(t4 * n3), e4.height = Math.floor(r4 * n3), this.setViewport(0, 0, t4, r4);
          }, this.getCurrentViewport = function(t4) {
            return t4 === void 0 && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t4 = new x2()), t4.copy(J2);
          }, this.getViewport = function(t4) {
            return t4.copy(et2);
          }, this.setViewport = function(t4, e5, r4, n3) {
            t4.isVector4 ? et2.set(t4.x, t4.y, t4.z, t4.w) : et2.set(t4, e5, r4, n3), _3.viewport(J2.copy(et2).multiplyScalar(tt2).floor());
          }, this.getScissor = function(t4) {
            return t4.copy(rt2);
          }, this.setScissor = function(t4, e5, r4, n3) {
            t4.isVector4 ? rt2.set(t4.x, t4.y, t4.z, t4.w) : rt2.set(t4, e5, r4, n3), _3.scissor(Z2.copy(rt2).multiplyScalar(tt2).floor());
          }, this.getScissorTest = function() {
            return nt2;
          }, this.setScissorTest = function(t4) {
            _3.setScissorTest(nt2 = t4);
          }, this.getClearColor = function() {
            return D2.getClearColor();
          }, this.setClearColor = function() {
            D2.setClearColor.apply(D2, arguments);
          }, this.getClearAlpha = function() {
            return D2.getClearAlpha();
          }, this.setClearAlpha = function() {
            D2.setClearAlpha.apply(D2, arguments);
          }, this.clear = function(t4, e5, r4) {
            var n3 = 0;
            (t4 === void 0 || t4) && (n3 |= 16384), (e5 === void 0 || e5) && (n3 |= 256), (r4 === void 0 || r4) && (n3 |= 1024), y3.clear(n3);
          }, this.clearColor = function() {
            this.clear(true, false, false);
          }, this.clearDepth = function() {
            this.clear(false, true, false);
          }, this.clearStencil = function() {
            this.clear(false, false, true);
          }, this.dispose = function() {
            e4.removeEventListener("webglcontextlost", mt2, false), e4.removeEventListener("webglcontextrestored", gt2, false), C2.dispose(), O2.dispose(), S3.dispose(), L3.dispose(), dt2.dispose(), bt2.stop();
          }, this.renderBufferImmediate = function(t4, e5) {
            _3.initAttributes();
            var r4 = S3.get(t4);
            t4.hasPositions && !r4.position && (r4.position = y3.createBuffer()), t4.hasNormals && !r4.normal && (r4.normal = y3.createBuffer()), t4.hasUvs && !r4.uv && (r4.uv = y3.createBuffer()), t4.hasColors && !r4.color && (r4.color = y3.createBuffer());
            var n3 = e5.getAttributes();
            t4.hasPositions && (y3.bindBuffer(34962, r4.position), y3.bufferData(34962, t4.positionArray, 35048), _3.enableAttribute(n3.position), y3.vertexAttribPointer(n3.position, 3, 5126, false, 0, 0)), t4.hasNormals && (y3.bindBuffer(34962, r4.normal), y3.bufferData(34962, t4.normalArray, 35048), _3.enableAttribute(n3.normal), y3.vertexAttribPointer(n3.normal, 3, 5126, false, 0, 0)), t4.hasUvs && (y3.bindBuffer(34962, r4.uv), y3.bufferData(34962, t4.uvArray, 35048), _3.enableAttribute(n3.uv), y3.vertexAttribPointer(n3.uv, 2, 5126, false, 0, 0)), t4.hasColors && (y3.bindBuffer(34962, r4.color), y3.bufferData(34962, t4.colorArray, 35048), _3.enableAttribute(n3.color), y3.vertexAttribPointer(n3.color, 3, 5126, false, 0, 0)), _3.disableUnusedAttributes(), y3.drawArrays(4, 0, t4.count), t4.count = 0;
          }, this.renderBufferDirect = function(t4, e5, r4, n3, i3, a3) {
            var o6 = i3.isMesh && i3.matrixWorld.determinant() < 0;
            _3.setMaterial(n3, o6);
            var s4 = Tt2(t4, e5, n3, i3), c4 = false;
            q2.geometry === r4.id && q2.program === s4.id && q2.wireframe === (n3.wireframe === true) || (q2.geometry = r4.id, q2.program = s4.id, q2.wireframe = n3.wireframe === true, c4 = true), i3.morphTargetInfluences && (N2.update(i3, r4, n3, s4), c4 = true);
            var l4, h4 = r4.index, u4 = r4.attributes.position, p4 = 1;
            n3.wireframe === true && (h4 = A3.getWireframeAttribute(r4), p4 = 2);
            var d3 = I2;
            h4 !== null && (l4 = E4.get(h4), (d3 = z2).setIndex(l4)), c4 && (function(t5, e6, r5) {
              if (r5 && r5.isInstancedBufferGeometry && !w3.isWebGL2 && b3.get("ANGLE_instanced_arrays") === null)
                console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              else {
                _3.initAttributes();
                var n4 = r5.attributes, i4 = e6.getAttributes(), a4 = t5.defaultAttributeValues;
                for (var o7 in i4) {
                  var s5 = i4[o7];
                  if (s5 >= 0) {
                    var c5 = n4[o7];
                    if (c5 !== void 0) {
                      var l5 = c5.normalized, h5 = c5.itemSize, u5 = E4.get(c5);
                      if (u5 === void 0)
                        continue;
                      var p5 = u5.buffer, d4 = u5.type, f5 = u5.bytesPerElement;
                      if (c5.isInterleavedBufferAttribute) {
                        var m5 = c5.data, g5 = m5.stride, v5 = c5.offset;
                        m5 && m5.isInstancedInterleavedBuffer ? (_3.enableAttributeAndDivisor(s5, m5.meshPerAttribute), r5.maxInstancedCount === void 0 && (r5.maxInstancedCount = m5.meshPerAttribute * m5.count)) : _3.enableAttribute(s5), y3.bindBuffer(34962, p5), y3.vertexAttribPointer(s5, h5, d4, l5, g5 * f5, v5 * f5);
                      } else
                        c5.isInstancedBufferAttribute ? (_3.enableAttributeAndDivisor(s5, c5.meshPerAttribute), r5.maxInstancedCount === void 0 && (r5.maxInstancedCount = c5.meshPerAttribute * c5.count)) : _3.enableAttribute(s5), y3.bindBuffer(34962, p5), y3.vertexAttribPointer(s5, h5, d4, l5, 0, 0);
                    } else if (a4 !== void 0) {
                      var x4 = a4[o7];
                      if (x4 !== void 0)
                        switch (x4.length) {
                          case 2:
                            y3.vertexAttrib2fv(s5, x4);
                            break;
                          case 3:
                            y3.vertexAttrib3fv(s5, x4);
                            break;
                          case 4:
                            y3.vertexAttrib4fv(s5, x4);
                            break;
                          default:
                            y3.vertexAttrib1fv(s5, x4);
                        }
                    }
                  }
                }
                _3.disableUnusedAttributes();
              }
            }(n3, s4, r4), h4 !== null && y3.bindBuffer(34963, l4.buffer));
            var f4 = 1 / 0;
            h4 !== null ? f4 = h4.count : u4 !== void 0 && (f4 = u4.count);
            var m4 = r4.drawRange.start * p4, g4 = r4.drawRange.count * p4, v4 = a3 !== null ? a3.start * p4 : 0, x3 = a3 !== null ? a3.count * p4 : 1 / 0, M4 = Math.max(m4, v4), S4 = Math.min(f4, m4 + g4, v4 + x3) - 1, T4 = Math.max(0, S4 - M4 + 1);
            if (T4 !== 0) {
              if (i3.isMesh)
                if (n3.wireframe === true)
                  _3.setLineWidth(n3.wireframeLinewidth * ht2()), d3.setMode(1);
                else
                  switch (i3.drawMode) {
                    case 0:
                      d3.setMode(4);
                      break;
                    case 1:
                      d3.setMode(5);
                      break;
                    case 2:
                      d3.setMode(6);
                  }
              else if (i3.isLine) {
                var L4 = n3.linewidth;
                L4 === void 0 && (L4 = 1), _3.setLineWidth(L4 * ht2()), i3.isLineSegments ? d3.setMode(1) : i3.isLineLoop ? d3.setMode(2) : d3.setMode(3);
              } else
                i3.isPoints ? d3.setMode(0) : i3.isSprite && d3.setMode(4);
              r4 && r4.isInstancedBufferGeometry ? r4.maxInstancedCount > 0 && d3.renderInstances(r4, M4, T4) : d3.render(M4, T4);
            }
          }, this.compile = function(t4, e5) {
            (v3 = O2.get(t4, e5)).init(), t4.traverse(function(t5) {
              t5.isLight && (v3.pushLight(t5), t5.castShadow && v3.pushShadow(t5));
            }), v3.setupLights(e5), t4.traverse(function(e6) {
              if (e6.material)
                if (Array.isArray(e6.material))
                  for (var r4 = 0; r4 < e6.material.length; r4++)
                    St2(e6.material[r4], t4.fog, e6);
                else
                  St2(e6.material, t4.fog, e6);
            });
          };
          var xt2 = null, bt2 = new tr();
          function wt2(t4, e5, r4, n3) {
            if (t4.visible !== false) {
              if (t4.layers.test(e5.layers)) {
                if (t4.isGroup)
                  r4 = t4.renderOrder;
                else if (t4.isLOD)
                  t4.autoUpdate === true && t4.update(e5);
                else if (t4.isLight)
                  v3.pushLight(t4), t4.castShadow && v3.pushShadow(t4);
                else if (t4.isSprite) {
                  if (!t4.frustumCulled || it2.intersectsSprite(t4)) {
                    n3 && lt2.setFromMatrixPosition(t4.matrixWorld).applyMatrix4(ct2);
                    var i3 = L3.update(t4);
                    (a3 = t4.material).visible && g3.push(t4, i3, a3, r4, lt2.z, null);
                  }
                } else if (t4.isImmediateRenderObject)
                  n3 && lt2.setFromMatrixPosition(t4.matrixWorld).applyMatrix4(ct2), g3.push(t4, null, t4.material, r4, lt2.z, null);
                else if ((t4.isMesh || t4.isLine || t4.isPoints) && (t4.isSkinnedMesh && t4.skeleton.update(), !t4.frustumCulled || it2.intersectsObject(t4))) {
                  n3 && lt2.setFromMatrixPosition(t4.matrixWorld).applyMatrix4(ct2), i3 = L3.update(t4);
                  var a3 = t4.material;
                  if (Array.isArray(a3))
                    for (var o6 = i3.groups, s4 = 0, c4 = o6.length; s4 < c4; s4++) {
                      var l4 = o6[s4], h4 = a3[l4.materialIndex];
                      h4 && h4.visible && g3.push(t4, i3, h4, r4, lt2.z, l4);
                    }
                  else
                    a3.visible && g3.push(t4, i3, a3, r4, lt2.z, null);
                }
              }
              var u4 = t4.children;
              for (s4 = 0, c4 = u4.length; s4 < c4; s4++)
                wt2(u4[s4], e5, r4, n3);
            }
          }
          function _t2(t4, e5, r4, n3) {
            for (var i3 = 0, a3 = t4.length; i3 < a3; i3++) {
              var o6 = t4[i3], s4 = o6.object, c4 = o6.geometry, l4 = n3 === void 0 ? o6.material : n3, h4 = o6.group;
              if (r4.isArrayCamera) {
                Y2 = r4;
                for (var u4 = r4.cameras, p4 = 0, d3 = u4.length; p4 < d3; p4++) {
                  var f4 = u4[p4];
                  s4.layers.test(f4.layers) && (_3.viewport(J2.copy(f4.viewport)), v3.setupLights(f4), Mt2(s4, e5, f4, c4, l4, h4));
                }
              } else
                Y2 = null, Mt2(s4, e5, r4, c4, l4, h4);
            }
          }
          function Mt2(t4, e5, r4, n3, i3, a3) {
            if (t4.onBeforeRender(F2, e5, r4, n3, i3, a3), v3 = O2.get(e5, Y2 || r4), t4.modelViewMatrix.multiplyMatrices(r4.matrixWorldInverse, t4.matrixWorld), t4.normalMatrix.getNormalMatrix(t4.modelViewMatrix), t4.isImmediateRenderObject) {
              _3.setMaterial(i3);
              var o6 = Tt2(r4, e5.fog, i3, t4);
              q2.geometry = null, q2.program = null, q2.wireframe = false, function(t5, e6) {
                t5.render(function(t6) {
                  F2.renderBufferImmediate(t6, e6);
                });
              }(t4, o6);
            } else
              F2.renderBufferDirect(r4, e5.fog, n3, i3, t4, a3);
            t4.onAfterRender(F2, e5, r4, n3, i3, a3), v3 = O2.get(e5, Y2 || r4);
          }
          function St2(t4, e5, r4) {
            var n3 = S3.get(t4), i3 = v3.state.lights, a3 = v3.state.shadowsArray, o6 = i3.state.version, s4 = R2.getParameters(t4, i3.state, a3, e5, at2.numPlanes, at2.numIntersection, r4), c4 = R2.getProgramCode(t4, s4), l4 = n3.program, h4 = true;
            if (l4 === void 0)
              t4.addEventListener("dispose", vt2);
            else if (l4.code !== c4)
              yt2(t4);
            else if (n3.lightsStateVersion !== o6)
              n3.lightsStateVersion = o6, h4 = false;
            else {
              if (s4.shaderID !== void 0)
                return;
              h4 = false;
            }
            if (h4) {
              if (s4.shaderID) {
                var u4 = $e[s4.shaderID];
                n3.shader = { name: t4.type, uniforms: Ie(u4.uniforms), vertexShader: u4.vertexShader, fragmentShader: u4.fragmentShader };
              } else
                n3.shader = { name: t4.type, uniforms: t4.uniforms, vertexShader: t4.vertexShader, fragmentShader: t4.fragmentShader };
              t4.onBeforeCompile(n3.shader, F2), c4 = R2.getProgramCode(t4, s4), l4 = R2.acquireProgram(t4, n3.shader, s4, c4), n3.program = l4, t4.program = l4;
            }
            var p4 = l4.getAttributes();
            if (t4.morphTargets) {
              t4.numSupportedMorphTargets = 0;
              for (var d3 = 0; d3 < F2.maxMorphTargets; d3++)
                p4["morphTarget" + d3] >= 0 && t4.numSupportedMorphTargets++;
            }
            if (t4.morphNormals)
              for (t4.numSupportedMorphNormals = 0, d3 = 0; d3 < F2.maxMorphNormals; d3++)
                p4["morphNormal" + d3] >= 0 && t4.numSupportedMorphNormals++;
            var f4 = n3.shader.uniforms;
            (t4.isShaderMaterial || t4.isRawShaderMaterial) && t4.clipping !== true || (n3.numClippingPlanes = at2.numPlanes, n3.numIntersection = at2.numIntersection, f4.clippingPlanes = at2.uniform), n3.fog = e5, n3.lightsStateVersion = o6, t4.lights && (f4.ambientLightColor.value = i3.state.ambient, f4.lightProbe.value = i3.state.probe, f4.directionalLights.value = i3.state.directional, f4.spotLights.value = i3.state.spot, f4.rectAreaLights.value = i3.state.rectArea, f4.pointLights.value = i3.state.point, f4.hemisphereLights.value = i3.state.hemi, f4.directionalShadowMap.value = i3.state.directionalShadowMap, f4.directionalShadowMatrix.value = i3.state.directionalShadowMatrix, f4.spotShadowMap.value = i3.state.spotShadowMap, f4.spotShadowMatrix.value = i3.state.spotShadowMatrix, f4.pointShadowMap.value = i3.state.pointShadowMap, f4.pointShadowMatrix.value = i3.state.pointShadowMatrix);
            var m4 = n3.program.getUniforms(), g4 = pn.seqWithValue(m4.seq, f4);
            n3.uniformsList = g4;
          }
          function Tt2(t4, e5, r4, n3) {
            T3.resetTextureUnits();
            var i3 = S3.get(r4), a3 = v3.state.lights;
            if (ot2 && (st2 || t4 !== X2)) {
              var o6 = t4 === X2 && r4.id === W2;
              at2.setState(r4.clippingPlanes, r4.clipIntersection, r4.clipShadows, t4, i3, o6);
            }
            r4.needsUpdate === false && (i3.program === void 0 || r4.fog && i3.fog !== e5 || r4.lights && i3.lightsStateVersion !== a3.state.version ? r4.needsUpdate = true : i3.numClippingPlanes === void 0 || i3.numClippingPlanes === at2.numPlanes && i3.numIntersection === at2.numIntersection || (r4.needsUpdate = true)), r4.needsUpdate && (St2(r4, e5, n3), r4.needsUpdate = false);
            var c4, l4, h4 = false, u4 = false, p4 = false, d3 = i3.program, f4 = d3.getUniforms(), m4 = i3.shader.uniforms;
            if (_3.useProgram(d3.program) && (h4 = true, u4 = true, p4 = true), r4.id !== W2 && (W2 = r4.id, u4 = true), h4 || X2 !== t4) {
              if (f4.setValue(y3, "projectionMatrix", t4.projectionMatrix), w3.logarithmicDepthBuffer && f4.setValue(y3, "logDepthBufFC", 2 / (Math.log(t4.far + 1) / Math.LN2)), X2 !== t4 && (X2 = t4, u4 = true, p4 = true), r4.isShaderMaterial || r4.isMeshPhongMaterial || r4.isMeshStandardMaterial || r4.envMap) {
                var g4 = f4.map.cameraPosition;
                g4 !== void 0 && g4.setValue(y3, lt2.setFromMatrixPosition(t4.matrixWorld));
              }
              (r4.isMeshPhongMaterial || r4.isMeshLambertMaterial || r4.isMeshBasicMaterial || r4.isMeshStandardMaterial || r4.isShaderMaterial || r4.skinning) && f4.setValue(y3, "viewMatrix", t4.matrixWorldInverse);
            }
            if (r4.skinning) {
              f4.setOptional(y3, n3, "bindMatrix"), f4.setOptional(y3, n3, "bindMatrixInverse");
              var x3 = n3.skeleton;
              if (x3) {
                var b4 = x3.bones;
                if (w3.floatVertexTextures) {
                  if (x3.boneTexture === void 0) {
                    var M4 = Math.sqrt(4 * b4.length);
                    M4 = s3.ceilPowerOfTwo(M4), M4 = Math.max(M4, 4);
                    var E5 = new Float32Array(M4 * M4 * 4);
                    E5.set(x3.boneMatrices);
                    var A4 = new je(E5, M4, M4, 1023, 1015);
                    A4.needsUpdate = true, x3.boneMatrices = E5, x3.boneTexture = A4, x3.boneTextureSize = M4;
                  }
                  f4.setValue(y3, "boneTexture", x3.boneTexture, T3), f4.setValue(y3, "boneTextureSize", x3.boneTextureSize);
                } else
                  f4.setOptional(y3, x3, "boneMatrices");
              }
            }
            return u4 && (f4.setValue(y3, "toneMappingExposure", F2.toneMappingExposure), f4.setValue(y3, "toneMappingWhitePoint", F2.toneMappingWhitePoint), r4.lights && (l4 = p4, (c4 = m4).ambientLightColor.needsUpdate = l4, c4.lightProbe.needsUpdate = l4, c4.directionalLights.needsUpdate = l4, c4.pointLights.needsUpdate = l4, c4.spotLights.needsUpdate = l4, c4.rectAreaLights.needsUpdate = l4, c4.hemisphereLights.needsUpdate = l4), e5 && r4.fog && function(t5, e6) {
              t5.fogColor.value.copy(e6.color), e6.isFog ? (t5.fogNear.value = e6.near, t5.fogFar.value = e6.far) : e6.isFogExp2 && (t5.fogDensity.value = e6.density);
            }(m4, e5), r4.isMeshBasicMaterial ? Et2(m4, r4) : r4.isMeshLambertMaterial ? (Et2(m4, r4), function(t5, e6) {
              e6.emissiveMap && (t5.emissiveMap.value = e6.emissiveMap);
            }(m4, r4)) : r4.isMeshPhongMaterial ? (Et2(m4, r4), r4.isMeshToonMaterial ? function(t5, e6) {
              At2(t5, e6), e6.gradientMap && (t5.gradientMap.value = e6.gradientMap);
            }(m4, r4) : At2(m4, r4)) : r4.isMeshStandardMaterial ? (Et2(m4, r4), r4.isMeshPhysicalMaterial ? function(t5, e6) {
              Lt2(t5, e6), t5.reflectivity.value = e6.reflectivity, t5.clearcoat.value = e6.clearcoat, t5.clearcoatRoughness.value = e6.clearcoatRoughness, e6.sheen && t5.sheen.value.copy(e6.sheen), e6.clearcoatNormalMap && (t5.clearcoatNormalScale.value.copy(e6.clearcoatNormalScale), t5.clearcoatNormalMap.value = e6.clearcoatNormalMap, e6.side === 1 && t5.clearcoatNormalScale.value.negate()), t5.transparency.value = e6.transparency;
            }(m4, r4) : Lt2(m4, r4)) : r4.isMeshMatcapMaterial ? (Et2(m4, r4), function(t5, e6) {
              e6.matcap && (t5.matcap.value = e6.matcap), e6.bumpMap && (t5.bumpMap.value = e6.bumpMap, t5.bumpScale.value = e6.bumpScale, e6.side === 1 && (t5.bumpScale.value *= -1)), e6.normalMap && (t5.normalMap.value = e6.normalMap, t5.normalScale.value.copy(e6.normalScale), e6.side === 1 && t5.normalScale.value.negate()), e6.displacementMap && (t5.displacementMap.value = e6.displacementMap, t5.displacementScale.value = e6.displacementScale, t5.displacementBias.value = e6.displacementBias);
            }(m4, r4)) : r4.isMeshDepthMaterial ? (Et2(m4, r4), function(t5, e6) {
              e6.displacementMap && (t5.displacementMap.value = e6.displacementMap, t5.displacementScale.value = e6.displacementScale, t5.displacementBias.value = e6.displacementBias);
            }(m4, r4)) : r4.isMeshDistanceMaterial ? (Et2(m4, r4), function(t5, e6) {
              e6.displacementMap && (t5.displacementMap.value = e6.displacementMap, t5.displacementScale.value = e6.displacementScale, t5.displacementBias.value = e6.displacementBias), t5.referencePosition.value.copy(e6.referencePosition), t5.nearDistance.value = e6.nearDistance, t5.farDistance.value = e6.farDistance;
            }(m4, r4)) : r4.isMeshNormalMaterial ? (Et2(m4, r4), function(t5, e6) {
              e6.bumpMap && (t5.bumpMap.value = e6.bumpMap, t5.bumpScale.value = e6.bumpScale, e6.side === 1 && (t5.bumpScale.value *= -1)), e6.normalMap && (t5.normalMap.value = e6.normalMap, t5.normalScale.value.copy(e6.normalScale), e6.side === 1 && t5.normalScale.value.negate()), e6.displacementMap && (t5.displacementMap.value = e6.displacementMap, t5.displacementScale.value = e6.displacementScale, t5.displacementBias.value = e6.displacementBias);
            }(m4, r4)) : r4.isLineBasicMaterial ? (function(t5, e6) {
              t5.diffuse.value.copy(e6.color), t5.opacity.value = e6.opacity;
            }(m4, r4), r4.isLineDashedMaterial && function(t5, e6) {
              t5.dashSize.value = e6.dashSize, t5.totalSize.value = e6.dashSize + e6.gapSize, t5.scale.value = e6.scale;
            }(m4, r4)) : r4.isPointsMaterial ? function(t5, e6) {
              t5.diffuse.value.copy(e6.color), t5.opacity.value = e6.opacity, t5.size.value = e6.size * tt2, t5.scale.value = 0.5 * $2, t5.map.value = e6.map, e6.map !== null && (e6.map.matrixAutoUpdate === true && e6.map.updateMatrix(), t5.uvTransform.value.copy(e6.map.matrix));
            }(m4, r4) : r4.isSpriteMaterial ? function(t5, e6) {
              t5.diffuse.value.copy(e6.color), t5.opacity.value = e6.opacity, t5.rotation.value = e6.rotation, t5.map.value = e6.map, e6.map !== null && (e6.map.matrixAutoUpdate === true && e6.map.updateMatrix(), t5.uvTransform.value.copy(e6.map.matrix));
            }(m4, r4) : r4.isShadowMaterial && (m4.color.value.copy(r4.color), m4.opacity.value = r4.opacity), m4.ltc_1 !== void 0 && (m4.ltc_1.value = Ke.LTC_1), m4.ltc_2 !== void 0 && (m4.ltc_2.value = Ke.LTC_2), pn.upload(y3, i3.uniformsList, m4, T3)), r4.isShaderMaterial && r4.uniformsNeedUpdate === true && (pn.upload(y3, i3.uniformsList, m4, T3), r4.uniformsNeedUpdate = false), r4.isSpriteMaterial && f4.setValue(y3, "center", n3.center), f4.setValue(y3, "modelViewMatrix", n3.modelViewMatrix), f4.setValue(y3, "normalMatrix", n3.normalMatrix), f4.setValue(y3, "modelMatrix", n3.matrixWorld), d3;
          }
          function Et2(t4, e5) {
            var r4;
            t4.opacity.value = e5.opacity, e5.color && t4.diffuse.value.copy(e5.color), e5.emissive && t4.emissive.value.copy(e5.emissive).multiplyScalar(e5.emissiveIntensity), e5.map && (t4.map.value = e5.map), e5.alphaMap && (t4.alphaMap.value = e5.alphaMap), e5.specularMap && (t4.specularMap.value = e5.specularMap), e5.envMap && (t4.envMap.value = e5.envMap, t4.flipEnvMap.value = e5.envMap.isCubeTexture ? -1 : 1, t4.reflectivity.value = e5.reflectivity, t4.refractionRatio.value = e5.refractionRatio, t4.maxMipLevel.value = S3.get(e5.envMap).__maxMipLevel), e5.lightMap && (t4.lightMap.value = e5.lightMap, t4.lightMapIntensity.value = e5.lightMapIntensity), e5.aoMap && (t4.aoMap.value = e5.aoMap, t4.aoMapIntensity.value = e5.aoMapIntensity), e5.map ? r4 = e5.map : e5.specularMap ? r4 = e5.specularMap : e5.displacementMap ? r4 = e5.displacementMap : e5.normalMap ? r4 = e5.normalMap : e5.bumpMap ? r4 = e5.bumpMap : e5.roughnessMap ? r4 = e5.roughnessMap : e5.metalnessMap ? r4 = e5.metalnessMap : e5.alphaMap ? r4 = e5.alphaMap : e5.emissiveMap && (r4 = e5.emissiveMap), r4 !== void 0 && (r4.isWebGLRenderTarget && (r4 = r4.texture), r4.matrixAutoUpdate === true && r4.updateMatrix(), t4.uvTransform.value.copy(r4.matrix));
          }
          function At2(t4, e5) {
            t4.specular.value.copy(e5.specular), t4.shininess.value = Math.max(e5.shininess, 1e-4), e5.emissiveMap && (t4.emissiveMap.value = e5.emissiveMap), e5.bumpMap && (t4.bumpMap.value = e5.bumpMap, t4.bumpScale.value = e5.bumpScale, e5.side === 1 && (t4.bumpScale.value *= -1)), e5.normalMap && (t4.normalMap.value = e5.normalMap, t4.normalScale.value.copy(e5.normalScale), e5.side === 1 && t4.normalScale.value.negate()), e5.displacementMap && (t4.displacementMap.value = e5.displacementMap, t4.displacementScale.value = e5.displacementScale, t4.displacementBias.value = e5.displacementBias);
          }
          function Lt2(t4, e5) {
            t4.roughness.value = e5.roughness, t4.metalness.value = e5.metalness, e5.roughnessMap && (t4.roughnessMap.value = e5.roughnessMap), e5.metalnessMap && (t4.metalnessMap.value = e5.metalnessMap), e5.emissiveMap && (t4.emissiveMap.value = e5.emissiveMap), e5.bumpMap && (t4.bumpMap.value = e5.bumpMap, t4.bumpScale.value = e5.bumpScale, e5.side === 1 && (t4.bumpScale.value *= -1)), e5.normalMap && (t4.normalMap.value = e5.normalMap, t4.normalScale.value.copy(e5.normalScale), e5.side === 1 && t4.normalScale.value.negate()), e5.displacementMap && (t4.displacementMap.value = e5.displacementMap, t4.displacementScale.value = e5.displacementScale, t4.displacementBias.value = e5.displacementBias), e5.envMap && (t4.envMapIntensity.value = e5.envMapIntensity);
          }
          bt2.setAnimationLoop(function(t4) {
            dt2.isPresenting() || xt2 && xt2(t4);
          }), a2 !== void 0 && bt2.setContext(a2), this.setAnimationLoop = function(t4) {
            xt2 = t4, dt2.setAnimationLoop(t4), bt2.start();
          }, this.render = function(t4, e5) {
            var r4, n3;
            if (arguments[2] !== void 0 && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), r4 = arguments[2]), arguments[3] !== void 0 && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), n3 = arguments[3]), e5 && e5.isCamera) {
              if (!G2) {
                q2.geometry = null, q2.program = null, q2.wireframe = false, W2 = -1, X2 = null, t4.autoUpdate === true && t4.updateMatrixWorld(), e5.parent === null && e5.updateMatrixWorld(), dt2.enabled && (e5 = dt2.getCamera(e5)), (v3 = O2.get(t4, e5)).init(), t4.onBeforeRender(F2, t4, e5, r4 || j2), ct2.multiplyMatrices(e5.projectionMatrix, e5.matrixWorldInverse), it2.setFromMatrix(ct2), st2 = this.localClippingEnabled, ot2 = at2.init(this.clippingPlanes, st2, e5), (g3 = C2.get(t4, e5)).init(), wt2(t4, e5, 0, F2.sortObjects), F2.sortObjects === true && g3.sort(), ot2 && at2.beginShadows();
                var i3 = v3.state.shadowsArray;
                ft2.render(i3, t4, e5), v3.setupLights(e5), ot2 && at2.endShadows(), this.info.autoReset && this.info.reset(), r4 !== void 0 && this.setRenderTarget(r4), D2.render(g3, t4, e5, n3);
                var a3 = g3.opaque, o6 = g3.transparent;
                if (t4.overrideMaterial) {
                  var s4 = t4.overrideMaterial;
                  a3.length && _t2(a3, t4, e5, s4), o6.length && _t2(o6, t4, e5, s4);
                } else
                  a3.length && _t2(a3, t4, e5), o6.length && _t2(o6, t4, e5);
                t4.onAfterRender(F2, t4, e5), j2 !== null && (T3.updateRenderTargetMipmap(j2), T3.updateMultisampleRenderTarget(j2)), _3.buffers.depth.setTest(true), _3.buffers.depth.setMask(true), _3.buffers.color.setMask(true), _3.setPolygonOffset(false), dt2.enabled && dt2.submitFrame(), g3 = null, v3 = null;
              }
            } else
              console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
          }, this.setFramebuffer = function(t4) {
            U2 !== t4 && y3.bindFramebuffer(36160, t4), U2 = t4;
          }, this.getActiveCubeFace = function() {
            return H2;
          }, this.getActiveMipmapLevel = function() {
            return V2;
          }, this.getRenderTarget = function() {
            return j2;
          }, this.setRenderTarget = function(t4, e5, r4) {
            j2 = t4, H2 = e5, V2 = r4, t4 && S3.get(t4).__webglFramebuffer === void 0 && T3.setupRenderTarget(t4);
            var n3 = U2, i3 = false;
            if (t4) {
              var a3 = S3.get(t4).__webglFramebuffer;
              t4.isWebGLRenderTargetCube ? (n3 = a3[e5 || 0], i3 = true) : n3 = t4.isWebGLMultisampleRenderTarget ? S3.get(t4).__webglMultisampledFramebuffer : a3, J2.copy(t4.viewport), Z2.copy(t4.scissor), Q2 = t4.scissorTest;
            } else
              J2.copy(et2).multiplyScalar(tt2).floor(), Z2.copy(rt2).multiplyScalar(tt2).floor(), Q2 = nt2;
            if (k2 !== n3 && (y3.bindFramebuffer(36160, n3), k2 = n3), _3.viewport(J2), _3.scissor(Z2), _3.setScissorTest(Q2), i3) {
              var o6 = S3.get(t4.texture);
              y3.framebufferTexture2D(36160, 36064, 34069 + (e5 || 0), o6.__webglTexture, r4 || 0);
            }
          }, this.readRenderTargetPixels = function(t4, e5, r4, n3, i3, a3, o6) {
            if (t4 && t4.isWebGLRenderTarget) {
              var s4 = S3.get(t4).__webglFramebuffer;
              if (t4.isWebGLRenderTargetCube && o6 !== void 0 && (s4 = s4[o6]), s4) {
                var c4 = false;
                s4 !== k2 && (y3.bindFramebuffer(36160, s4), c4 = true);
                try {
                  var l4 = t4.texture, h4 = l4.format, u4 = l4.type;
                  if (h4 !== 1023 && B2.convert(h4) !== y3.getParameter(35739))
                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                  if (!(u4 === 1009 || B2.convert(u4) === y3.getParameter(35738) || u4 === 1015 && (w3.isWebGL2 || b3.get("OES_texture_float") || b3.get("WEBGL_color_buffer_float")) || u4 === 1016 && (w3.isWebGL2 ? b3.get("EXT_color_buffer_float") : b3.get("EXT_color_buffer_half_float"))))
                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                  y3.checkFramebufferStatus(36160) === 36053 ? e5 >= 0 && e5 <= t4.width - n3 && r4 >= 0 && r4 <= t4.height - i3 && y3.readPixels(e5, r4, n3, i3, B2.convert(h4), B2.convert(u4), a3) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
                } finally {
                  c4 && y3.bindFramebuffer(36160, k2);
                }
              }
            } else
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          }, this.copyFramebufferToTexture = function(t4, e5, r4) {
            var n3 = e5.image.width, i3 = e5.image.height, a3 = B2.convert(e5.format);
            T3.setTexture2D(e5, 0), y3.copyTexImage2D(3553, r4 || 0, a3, t4.x, t4.y, n3, i3, 0);
          }, this.copyTextureToTexture = function(t4, e5, r4, n3) {
            var i3 = e5.image.width, a3 = e5.image.height, o6 = B2.convert(r4.format), s4 = B2.convert(r4.type);
            T3.setTexture2D(r4, 0), e5.isDataTexture ? y3.texSubImage2D(3553, n3 || 0, t4.x, t4.y, i3, a3, o6, s4, e5.image.data) : y3.texSubImage2D(3553, n3 || 0, t4.x, t4.y, o6, s4, e5.image);
          }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
        function Kn(t3, e4) {
          this.name = "", this.color = new Nt(t3), this.density = e4 !== void 0 ? e4 : 25e-5;
        }
        function $n(t3, e4, r3) {
          this.name = "", this.color = new Nt(t3), this.near = e4 !== void 0 ? e4 : 1, this.far = r3 !== void 0 ? r3 : 1e3;
        }
        function ti(t3, e4) {
          this.array = t3, this.stride = e4, this.count = t3 !== void 0 ? t3.length / e4 : 0, this.dynamic = false, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
        }
        function ei(t3, e4, r3, n2) {
          this.data = t3, this.itemSize = e4, this.offset = r3, this.normalized = n2 === true;
        }
        function ri(t3) {
          Ut.call(this), this.type = "SpriteMaterial", this.color = new Nt(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = true, this.lights = false, this.transparent = true, this.setValues(t3);
        }
        Object.assign(Jn.prototype, e3.prototype), Object.assign(Zn.prototype, e3.prototype), Object.assign(Kn.prototype, { isFogExp2: true, clone: function() {
          return new Kn(this.color, this.density);
        }, toJSON: function() {
          return { type: "FogExp2", color: this.color.getHex(), density: this.density };
        } }), Object.assign($n.prototype, { isFog: true, clone: function() {
          return new $n(this.color, this.near, this.far);
        }, toJSON: function() {
          return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
        } }), Object.defineProperty(ti.prototype, "needsUpdate", { set: function(t3) {
          t3 === true && this.version++;
        } }), Object.assign(ti.prototype, { isInterleavedBuffer: true, onUploadCallback: function() {
        }, setArray: function(t3) {
          if (Array.isArray(t3))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          return this.count = t3 !== void 0 ? t3.length / this.stride : 0, this.array = t3, this;
        }, setDynamic: function(t3) {
          return this.dynamic = t3, this;
        }, copy: function(t3) {
          return this.array = new t3.array.constructor(t3.array), this.count = t3.count, this.stride = t3.stride, this.dynamic = t3.dynamic, this;
        }, copyAt: function(t3, e4, r3) {
          t3 *= this.stride, r3 *= e4.stride;
          for (var n2 = 0, i3 = this.stride; n2 < i3; n2++)
            this.array[t3 + n2] = e4.array[r3 + n2];
          return this;
        }, set: function(t3, e4) {
          return e4 === void 0 && (e4 = 0), this.array.set(t3, e4), this;
        }, clone: function() {
          return new this.constructor().copy(this);
        }, onUpload: function(t3) {
          return this.onUploadCallback = t3, this;
        } }), Object.defineProperties(ei.prototype, { count: { get: function() {
          return this.data.count;
        } }, array: { get: function() {
          return this.data.array;
        } } }), Object.assign(ei.prototype, { isInterleavedBufferAttribute: true, setX: function(t3, e4) {
          return this.data.array[t3 * this.data.stride + this.offset] = e4, this;
        }, setY: function(t3, e4) {
          return this.data.array[t3 * this.data.stride + this.offset + 1] = e4, this;
        }, setZ: function(t3, e4) {
          return this.data.array[t3 * this.data.stride + this.offset + 2] = e4, this;
        }, setW: function(t3, e4) {
          return this.data.array[t3 * this.data.stride + this.offset + 3] = e4, this;
        }, getX: function(t3) {
          return this.data.array[t3 * this.data.stride + this.offset];
        }, getY: function(t3) {
          return this.data.array[t3 * this.data.stride + this.offset + 1];
        }, getZ: function(t3) {
          return this.data.array[t3 * this.data.stride + this.offset + 2];
        }, getW: function(t3) {
          return this.data.array[t3 * this.data.stride + this.offset + 3];
        }, setXY: function(t3, e4, r3) {
          return t3 = t3 * this.data.stride + this.offset, this.data.array[t3 + 0] = e4, this.data.array[t3 + 1] = r3, this;
        }, setXYZ: function(t3, e4, r3, n2) {
          return t3 = t3 * this.data.stride + this.offset, this.data.array[t3 + 0] = e4, this.data.array[t3 + 1] = r3, this.data.array[t3 + 2] = n2, this;
        }, setXYZW: function(t3, e4, r3, n2, i3) {
          return t3 = t3 * this.data.stride + this.offset, this.data.array[t3 + 0] = e4, this.data.array[t3 + 1] = r3, this.data.array[t3 + 2] = n2, this.data.array[t3 + 3] = i3, this;
        } }), ri.prototype = Object.create(Ut.prototype), ri.prototype.constructor = ri, ri.prototype.isSpriteMaterial = true, ri.prototype.copy = function(t3) {
          return Ut.prototype.copy.call(this, t3), this.color.copy(t3.color), this.map = t3.map, this.rotation = t3.rotation, this.sizeAttenuation = t3.sizeAttenuation, this;
        };
        var ni = new d2(), ii = new d2(), ai = new d2(), oi = new l3(), si = new l3(), ci = new P2(), li = new d2(), hi = new d2(), ui = new d2(), pi = new l3(), di = new l3(), fi = new l3();
        function mi(t3) {
          if (Y.call(this), this.type = "Sprite", Wn === void 0) {
            Wn = new se();
            var e4 = new ti(new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), 5);
            Wn.setIndex([0, 1, 2, 0, 2, 3]), Wn.addAttribute("position", new ei(e4, 3, 0, false)), Wn.addAttribute("uv", new ei(e4, 2, 3, false));
          }
          this.geometry = Wn, this.material = t3 !== void 0 ? t3 : new ri(), this.center = new l3(0.5, 0.5);
        }
        function gi(t3, e4, r3, n2, i3, a3) {
          oi.subVectors(t3, r3).addScalar(0.5).multiply(n2), i3 !== void 0 ? (si.x = a3 * oi.x - i3 * oi.y, si.y = i3 * oi.x + a3 * oi.y) : si.copy(oi), t3.copy(e4), t3.x += si.x, t3.y += si.y, t3.applyMatrix4(ci);
        }
        mi.prototype = Object.assign(Object.create(Y.prototype), { constructor: mi, isSprite: true, raycast: function(t3, e4) {
          t3.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), ii.setFromMatrixScale(this.matrixWorld), ci.copy(t3.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t3.camera.matrixWorldInverse, this.matrixWorld), ai.setFromMatrixPosition(this.modelViewMatrix), t3.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && ii.multiplyScalar(-ai.z);
          var r3, n2, i3 = this.material.rotation;
          i3 !== 0 && (n2 = Math.cos(i3), r3 = Math.sin(i3));
          var a3 = this.center;
          gi(li.set(-0.5, -0.5, 0), ai, a3, ii, r3, n2), gi(hi.set(0.5, -0.5, 0), ai, a3, ii, r3, n2), gi(ui.set(0.5, 0.5, 0), ai, a3, ii, r3, n2), pi.set(0, 0), di.set(1, 0), fi.set(1, 1);
          var o5 = t3.ray.intersectTriangle(li, hi, ui, false, ni);
          if (o5 !== null || (gi(hi.set(-0.5, 0.5, 0), ai, a3, ii, r3, n2), di.set(0, 1), (o5 = t3.ray.intersectTriangle(li, ui, hi, false, ni)) !== null)) {
            var s4 = t3.ray.origin.distanceTo(ni);
            s4 < t3.near || s4 > t3.far || e4.push({ distance: s4, point: ni.clone(), uv: Pt.getUV(ni, li, hi, ui, pi, di, fi, new l3()), face: null, object: this });
          }
        }, clone: function() {
          return new this.constructor(this.material).copy(this);
        }, copy: function(t3) {
          return Y.prototype.copy.call(this, t3), t3.center !== void 0 && this.center.copy(t3.center), this;
        } });
        var vi = new d2(), yi = new d2();
        function xi() {
          Y.call(this), this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: true, value: [] } }), this.autoUpdate = true;
        }
        function bi(t3, e4) {
          t3 && t3.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Te.call(this, t3, e4), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new P2(), this.bindMatrixInverse = new P2();
        }
        xi.prototype = Object.assign(Object.create(Y.prototype), { constructor: xi, isLOD: true, copy: function(t3) {
          Y.prototype.copy.call(this, t3, false);
          for (var e4 = t3.levels, r3 = 0, n2 = e4.length; r3 < n2; r3++) {
            var i3 = e4[r3];
            this.addLevel(i3.object.clone(), i3.distance);
          }
          return this;
        }, addLevel: function(t3, e4) {
          e4 === void 0 && (e4 = 0), e4 = Math.abs(e4);
          for (var r3 = this.levels, n2 = 0; n2 < r3.length && !(e4 < r3[n2].distance); n2++)
            ;
          return r3.splice(n2, 0, { distance: e4, object: t3 }), this.add(t3), this;
        }, getObjectForDistance: function(t3) {
          for (var e4 = this.levels, r3 = 1, n2 = e4.length; r3 < n2 && !(t3 < e4[r3].distance); r3++)
            ;
          return e4[r3 - 1].object;
        }, raycast: function(t3, e4) {
          vi.setFromMatrixPosition(this.matrixWorld);
          var r3 = t3.ray.origin.distanceTo(vi);
          this.getObjectForDistance(r3).raycast(t3, e4);
        }, update: function(t3) {
          var e4 = this.levels;
          if (e4.length > 1) {
            vi.setFromMatrixPosition(t3.matrixWorld), yi.setFromMatrixPosition(this.matrixWorld);
            var r3 = vi.distanceTo(yi);
            e4[0].object.visible = true;
            for (var n2 = 1, i3 = e4.length; n2 < i3 && r3 >= e4[n2].distance; n2++)
              e4[n2 - 1].object.visible = false, e4[n2].object.visible = true;
            for (; n2 < i3; n2++)
              e4[n2].object.visible = false;
          }
        }, toJSON: function(t3) {
          var e4 = Y.prototype.toJSON.call(this, t3);
          e4.object.levels = [];
          for (var r3 = this.levels, n2 = 0, i3 = r3.length; n2 < i3; n2++) {
            var a3 = r3[n2];
            e4.object.levels.push({ object: a3.object.uuid, distance: a3.distance });
          }
          return e4;
        } }), bi.prototype = Object.assign(Object.create(Te.prototype), { constructor: bi, isSkinnedMesh: true, bind: function(t3, e4) {
          this.skeleton = t3, e4 === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e4 = this.matrixWorld), this.bindMatrix.copy(e4), this.bindMatrixInverse.getInverse(e4);
        }, pose: function() {
          this.skeleton.pose();
        }, normalizeSkinWeights: function() {
          for (var t3 = new x2(), e4 = this.geometry.attributes.skinWeight, r3 = 0, n2 = e4.count; r3 < n2; r3++) {
            t3.x = e4.getX(r3), t3.y = e4.getY(r3), t3.z = e4.getZ(r3), t3.w = e4.getW(r3);
            var i3 = 1 / t3.manhattanLength();
            i3 !== 1 / 0 ? t3.multiplyScalar(i3) : t3.set(1, 0, 0, 0), e4.setXYZW(r3, t3.x, t3.y, t3.z, t3.w);
          }
        }, updateMatrixWorld: function(t3) {
          Te.prototype.updateMatrixWorld.call(this, t3), this.bindMode === "attached" ? this.bindMatrixInverse.getInverse(this.matrixWorld) : this.bindMode === "detached" ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }, clone: function() {
          return new this.constructor(this.geometry, this.material).copy(this);
        } });
        var wi = new P2(), _i = new P2();
        function Mi(t3, e4) {
          if (t3 = t3 || [], this.bones = t3.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), e4 === void 0)
            this.calculateInverses();
          else if (this.bones.length === e4.length)
            this.boneInverses = e4.slice(0);
          else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
            for (var r3 = 0, n2 = this.bones.length; r3 < n2; r3++)
              this.boneInverses.push(new P2());
          }
        }
        function Si() {
          Y.call(this), this.type = "Bone";
        }
        function Ti(t3) {
          Ut.call(this), this.type = "LineBasicMaterial", this.color = new Nt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = false, this.setValues(t3);
        }
        Object.assign(Mi.prototype, { calculateInverses: function() {
          this.boneInverses = [];
          for (var t3 = 0, e4 = this.bones.length; t3 < e4; t3++) {
            var r3 = new P2();
            this.bones[t3] && r3.getInverse(this.bones[t3].matrixWorld), this.boneInverses.push(r3);
          }
        }, pose: function() {
          var t3, e4, r3;
          for (e4 = 0, r3 = this.bones.length; e4 < r3; e4++)
            (t3 = this.bones[e4]) && t3.matrixWorld.getInverse(this.boneInverses[e4]);
          for (e4 = 0, r3 = this.bones.length; e4 < r3; e4++)
            (t3 = this.bones[e4]) && (t3.parent && t3.parent.isBone ? (t3.matrix.getInverse(t3.parent.matrixWorld), t3.matrix.multiply(t3.matrixWorld)) : t3.matrix.copy(t3.matrixWorld), t3.matrix.decompose(t3.position, t3.quaternion, t3.scale));
        }, update: function() {
          for (var t3 = this.bones, e4 = this.boneInverses, r3 = this.boneMatrices, n2 = this.boneTexture, i3 = 0, a3 = t3.length; i3 < a3; i3++) {
            var o5 = t3[i3] ? t3[i3].matrixWorld : _i;
            wi.multiplyMatrices(o5, e4[i3]), wi.toArray(r3, 16 * i3);
          }
          n2 !== void 0 && (n2.needsUpdate = true);
        }, clone: function() {
          return new Mi(this.bones, this.boneInverses);
        }, getBoneByName: function(t3) {
          for (var e4 = 0, r3 = this.bones.length; e4 < r3; e4++) {
            var n2 = this.bones[e4];
            if (n2.name === t3)
              return n2;
          }
        } }), Si.prototype = Object.assign(Object.create(Y.prototype), { constructor: Si, isBone: true }), Ti.prototype = Object.create(Ut.prototype), Ti.prototype.constructor = Ti, Ti.prototype.isLineBasicMaterial = true, Ti.prototype.copy = function(t3) {
          return Ut.prototype.copy.call(this, t3), this.color.copy(t3.color), this.linewidth = t3.linewidth, this.linecap = t3.linecap, this.linejoin = t3.linejoin, this;
        };
        var Ei = new d2(), Ai = new d2(), Li = new P2(), Ri = new xt(), Pi = new ut();
        function Ci(t3, e4, r3) {
          r3 === 1 && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Y.call(this), this.type = "Line", this.geometry = t3 !== void 0 ? t3 : new se(), this.material = e4 !== void 0 ? e4 : new Ti({ color: 16777215 * Math.random() });
        }
        Ci.prototype = Object.assign(Object.create(Y.prototype), { constructor: Ci, isLine: true, computeLineDistances: function() {
          var t3 = this.geometry;
          if (t3.isBufferGeometry)
            if (t3.index === null) {
              for (var e4 = t3.attributes.position, r3 = [0], n2 = 1, i3 = e4.count; n2 < i3; n2++)
                Ei.fromBufferAttribute(e4, n2 - 1), Ai.fromBufferAttribute(e4, n2), r3[n2] = r3[n2 - 1], r3[n2] += Ei.distanceTo(Ai);
              t3.addAttribute("lineDistance", new Zt(r3, 1));
            } else
              console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          else if (t3.isGeometry) {
            var a3 = t3.vertices;
            for ((r3 = t3.lineDistances)[0] = 0, n2 = 1, i3 = a3.length; n2 < i3; n2++)
              r3[n2] = r3[n2 - 1], r3[n2] += a3[n2 - 1].distanceTo(a3[n2]);
          }
          return this;
        }, raycast: function(t3, e4) {
          var r3 = t3.linePrecision, n2 = this.geometry, i3 = this.matrixWorld;
          if (n2.boundingSphere === null && n2.computeBoundingSphere(), Pi.copy(n2.boundingSphere), Pi.applyMatrix4(i3), Pi.radius += r3, t3.ray.intersectsSphere(Pi) !== false) {
            Li.getInverse(i3), Ri.copy(t3.ray).applyMatrix4(Li);
            var a3 = r3 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o5 = a3 * a3, s4 = new d2(), c3 = new d2(), l4 = new d2(), h3 = new d2(), u3 = this && this.isLineSegments ? 2 : 1;
            if (n2.isBufferGeometry) {
              var p3 = n2.index, f3 = n2.attributes.position.array;
              if (p3 !== null)
                for (var m3 = p3.array, g3 = 0, v3 = m3.length - 1; g3 < v3; g3 += u3) {
                  var y3 = m3[g3], x3 = m3[g3 + 1];
                  s4.fromArray(f3, 3 * y3), c3.fromArray(f3, 3 * x3), Ri.distanceSqToSegment(s4, c3, h3, l4) > o5 || (h3.applyMatrix4(this.matrixWorld), (_3 = t3.ray.origin.distanceTo(h3)) < t3.near || _3 > t3.far || e4.push({ distance: _3, point: l4.clone().applyMatrix4(this.matrixWorld), index: g3, face: null, faceIndex: null, object: this }));
                }
              else
                for (g3 = 0, v3 = f3.length / 3 - 1; g3 < v3; g3 += u3)
                  s4.fromArray(f3, 3 * g3), c3.fromArray(f3, 3 * g3 + 3), Ri.distanceSqToSegment(s4, c3, h3, l4) > o5 || (h3.applyMatrix4(this.matrixWorld), (_3 = t3.ray.origin.distanceTo(h3)) < t3.near || _3 > t3.far || e4.push({ distance: _3, point: l4.clone().applyMatrix4(this.matrixWorld), index: g3, face: null, faceIndex: null, object: this }));
            } else if (n2.isGeometry) {
              var b3 = n2.vertices, w3 = b3.length;
              for (g3 = 0; g3 < w3 - 1; g3 += u3) {
                var _3;
                Ri.distanceSqToSegment(b3[g3], b3[g3 + 1], h3, l4) > o5 || (h3.applyMatrix4(this.matrixWorld), (_3 = t3.ray.origin.distanceTo(h3)) < t3.near || _3 > t3.far || e4.push({ distance: _3, point: l4.clone().applyMatrix4(this.matrixWorld), index: g3, face: null, faceIndex: null, object: this }));
              }
            }
          }
        }, clone: function() {
          return new this.constructor(this.geometry, this.material).copy(this);
        } });
        var Oi = new d2(), Di = new d2();
        function Ni(t3, e4) {
          Ci.call(this, t3, e4), this.type = "LineSegments";
        }
        function Ii(t3, e4) {
          Ci.call(this, t3, e4), this.type = "LineLoop";
        }
        function zi(t3) {
          Ut.call(this), this.type = "PointsMaterial", this.color = new Nt(16777215), this.map = null, this.size = 1, this.sizeAttenuation = true, this.morphTargets = false, this.lights = false, this.setValues(t3);
        }
        Ni.prototype = Object.assign(Object.create(Ci.prototype), { constructor: Ni, isLineSegments: true, computeLineDistances: function() {
          var t3 = this.geometry;
          if (t3.isBufferGeometry)
            if (t3.index === null) {
              for (var e4 = t3.attributes.position, r3 = [], n2 = 0, i3 = e4.count; n2 < i3; n2 += 2)
                Oi.fromBufferAttribute(e4, n2), Di.fromBufferAttribute(e4, n2 + 1), r3[n2] = n2 === 0 ? 0 : r3[n2 - 1], r3[n2 + 1] = r3[n2] + Oi.distanceTo(Di);
              t3.addAttribute("lineDistance", new Zt(r3, 1));
            } else
              console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          else if (t3.isGeometry) {
            var a3 = t3.vertices;
            for (r3 = t3.lineDistances, n2 = 0, i3 = a3.length; n2 < i3; n2 += 2)
              Oi.copy(a3[n2]), Di.copy(a3[n2 + 1]), r3[n2] = n2 === 0 ? 0 : r3[n2 - 1], r3[n2 + 1] = r3[n2] + Oi.distanceTo(Di);
          }
          return this;
        } }), Ii.prototype = Object.assign(Object.create(Ci.prototype), { constructor: Ii, isLineLoop: true }), zi.prototype = Object.create(Ut.prototype), zi.prototype.constructor = zi, zi.prototype.isPointsMaterial = true, zi.prototype.copy = function(t3) {
          return Ut.prototype.copy.call(this, t3), this.color.copy(t3.color), this.map = t3.map, this.size = t3.size, this.sizeAttenuation = t3.sizeAttenuation, this.morphTargets = t3.morphTargets, this;
        };
        var Bi = new P2(), Fi = new xt(), Gi = new ut(), Ui = new d2();
        function Hi(t3, e4) {
          Y.call(this), this.type = "Points", this.geometry = t3 !== void 0 ? t3 : new se(), this.material = e4 !== void 0 ? e4 : new zi({ color: 16777215 * Math.random() }), this.updateMorphTargets();
        }
        function Vi(t3, e4, r3, n2, i3, a3, o5) {
          var s4 = Fi.distanceSqToPoint(t3);
          if (s4 < r3) {
            var c3 = new d2();
            Fi.closestPointToPoint(t3, c3), c3.applyMatrix4(n2);
            var l4 = i3.ray.origin.distanceTo(c3);
            if (l4 < i3.near || l4 > i3.far)
              return;
            a3.push({ distance: l4, distanceToRay: Math.sqrt(s4), point: c3, index: e4, face: null, object: o5 });
          }
        }
        function ji(t3, e4, r3, n2, i3, a3, o5, s4, c3) {
          y2.call(this, t3, e4, r3, n2, i3, a3, o5, s4, c3), this.format = o5 !== void 0 ? o5 : 1022, this.minFilter = a3 !== void 0 ? a3 : 1006, this.magFilter = i3 !== void 0 ? i3 : 1006, this.generateMipmaps = false;
        }
        function ki(t3, e4, r3, n2, i3, a3, o5, s4, c3, l4, h3, u3) {
          y2.call(this, null, a3, o5, s4, c3, l4, n2, i3, h3, u3), this.image = { width: e4, height: r3 }, this.mipmaps = t3, this.flipY = false, this.generateMipmaps = false;
        }
        function Wi(t3, e4, r3, n2, i3, a3, o5, s4, c3) {
          y2.call(this, t3, e4, r3, n2, i3, a3, o5, s4, c3), this.needsUpdate = true;
        }
        function qi(t3, e4, r3, n2, i3, a3, o5, s4, c3, l4) {
          if ((l4 = l4 !== void 0 ? l4 : 1026) !== 1026 && l4 !== 1027)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          r3 === void 0 && l4 === 1026 && (r3 = 1012), r3 === void 0 && l4 === 1027 && (r3 = 1020), y2.call(this, null, n2, i3, a3, o5, s4, l4, r3, c3), this.image = { width: t3, height: e4 }, this.magFilter = o5 !== void 0 ? o5 : 1003, this.minFilter = s4 !== void 0 ? s4 : 1003, this.flipY = false, this.generateMipmaps = false;
        }
        function Xi(t3) {
          se.call(this), this.type = "WireframeGeometry";
          var e4, r3, n2, i3, a3, o5, s4, c3, l4, h3, u3 = [], p3 = [0, 0], f3 = {}, m3 = ["a", "b", "c"];
          if (t3 && t3.isGeometry) {
            var g3 = t3.faces;
            for (e4 = 0, n2 = g3.length; e4 < n2; e4++) {
              var v3 = g3[e4];
              for (r3 = 0; r3 < 3; r3++)
                s4 = v3[m3[r3]], c3 = v3[m3[(r3 + 1) % 3]], p3[0] = Math.min(s4, c3), p3[1] = Math.max(s4, c3), f3[l4 = p3[0] + "," + p3[1]] === void 0 && (f3[l4] = { index1: p3[0], index2: p3[1] });
            }
            for (l4 in f3)
              o5 = f3[l4], h3 = t3.vertices[o5.index1], u3.push(h3.x, h3.y, h3.z), h3 = t3.vertices[o5.index2], u3.push(h3.x, h3.y, h3.z);
          } else if (t3 && t3.isBufferGeometry) {
            var y3, x3, b3, w3, _3, M3, S3;
            if (h3 = new d2(), t3.index !== null) {
              for (y3 = t3.attributes.position, x3 = t3.index, (b3 = t3.groups).length === 0 && (b3 = [{ start: 0, count: x3.count, materialIndex: 0 }]), i3 = 0, a3 = b3.length; i3 < a3; ++i3)
                for (e4 = _3 = (w3 = b3[i3]).start, n2 = _3 + w3.count; e4 < n2; e4 += 3)
                  for (r3 = 0; r3 < 3; r3++)
                    s4 = x3.getX(e4 + r3), c3 = x3.getX(e4 + (r3 + 1) % 3), p3[0] = Math.min(s4, c3), p3[1] = Math.max(s4, c3), f3[l4 = p3[0] + "," + p3[1]] === void 0 && (f3[l4] = { index1: p3[0], index2: p3[1] });
              for (l4 in f3)
                o5 = f3[l4], h3.fromBufferAttribute(y3, o5.index1), u3.push(h3.x, h3.y, h3.z), h3.fromBufferAttribute(y3, o5.index2), u3.push(h3.x, h3.y, h3.z);
            } else
              for (e4 = 0, n2 = (y3 = t3.attributes.position).count / 3; e4 < n2; e4++)
                for (r3 = 0; r3 < 3; r3++)
                  M3 = 3 * e4 + r3, h3.fromBufferAttribute(y3, M3), u3.push(h3.x, h3.y, h3.z), S3 = 3 * e4 + (r3 + 1) % 3, h3.fromBufferAttribute(y3, S3), u3.push(h3.x, h3.y, h3.z);
          }
          this.addAttribute("position", new Zt(u3, 3));
        }
        function Yi(t3, e4, r3) {
          Oe.call(this), this.type = "ParametricGeometry", this.parameters = { func: t3, slices: e4, stacks: r3 }, this.fromBufferGeometry(new Ji(t3, e4, r3)), this.mergeVertices();
        }
        function Ji(t3, e4, r3) {
          se.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: t3, slices: e4, stacks: r3 };
          var n2, i3, a3 = [], o5 = [], s4 = [], c3 = [], l4 = 1e-5, h3 = new d2(), u3 = new d2(), p3 = new d2(), f3 = new d2(), m3 = new d2();
          t3.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
          var g3 = e4 + 1;
          for (n2 = 0; n2 <= r3; n2++) {
            var v3 = n2 / r3;
            for (i3 = 0; i3 <= e4; i3++) {
              var y3 = i3 / e4;
              t3(y3, v3, u3), o5.push(u3.x, u3.y, u3.z), y3 - l4 >= 0 ? (t3(y3 - l4, v3, p3), f3.subVectors(u3, p3)) : (t3(y3 + l4, v3, p3), f3.subVectors(p3, u3)), v3 - l4 >= 0 ? (t3(y3, v3 - l4, p3), m3.subVectors(u3, p3)) : (t3(y3, v3 + l4, p3), m3.subVectors(p3, u3)), h3.crossVectors(f3, m3).normalize(), s4.push(h3.x, h3.y, h3.z), c3.push(y3, v3);
            }
          }
          for (n2 = 0; n2 < r3; n2++)
            for (i3 = 0; i3 < e4; i3++) {
              var x3 = n2 * g3 + i3, b3 = n2 * g3 + i3 + 1, w3 = (n2 + 1) * g3 + i3 + 1, _3 = (n2 + 1) * g3 + i3;
              a3.push(x3, b3, _3), a3.push(b3, w3, _3);
            }
          this.setIndex(a3), this.addAttribute("position", new Zt(o5, 3)), this.addAttribute("normal", new Zt(s4, 3)), this.addAttribute("uv", new Zt(c3, 2));
        }
        function Zi(t3, e4, r3, n2) {
          Oe.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: t3, indices: e4, radius: r3, detail: n2 }, this.fromBufferGeometry(new Qi(t3, e4, r3, n2)), this.mergeVertices();
        }
        function Qi(t3, e4, r3, n2) {
          se.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: t3, indices: e4, radius: r3, detail: n2 }, r3 = r3 || 1;
          var i3 = [], a3 = [];
          function o5(t4, e5, r4, n3) {
            var i4, a4, o6 = Math.pow(2, n3), c4 = [];
            for (i4 = 0; i4 <= o6; i4++) {
              c4[i4] = [];
              var l4 = t4.clone().lerp(r4, i4 / o6), h4 = e5.clone().lerp(r4, i4 / o6), u4 = o6 - i4;
              for (a4 = 0; a4 <= u4; a4++)
                c4[i4][a4] = a4 === 0 && i4 === o6 ? l4 : l4.clone().lerp(h4, a4 / u4);
            }
            for (i4 = 0; i4 < o6; i4++)
              for (a4 = 0; a4 < 2 * (o6 - i4) - 1; a4++) {
                var p3 = Math.floor(a4 / 2);
                a4 % 2 == 0 ? (s4(c4[i4][p3 + 1]), s4(c4[i4 + 1][p3]), s4(c4[i4][p3])) : (s4(c4[i4][p3 + 1]), s4(c4[i4 + 1][p3 + 1]), s4(c4[i4 + 1][p3]));
              }
          }
          function s4(t4) {
            i3.push(t4.x, t4.y, t4.z);
          }
          function c3(e5, r4) {
            var n3 = 3 * e5;
            r4.x = t3[n3 + 0], r4.y = t3[n3 + 1], r4.z = t3[n3 + 2];
          }
          function h3(t4, e5, r4, n3) {
            n3 < 0 && t4.x === 1 && (a3[e5] = t4.x - 1), r4.x === 0 && r4.z === 0 && (a3[e5] = n3 / 2 / Math.PI + 0.5);
          }
          function u3(t4) {
            return Math.atan2(t4.z, -t4.x);
          }
          !function(t4) {
            for (var r4 = new d2(), n3 = new d2(), i4 = new d2(), a4 = 0; a4 < e4.length; a4 += 3)
              c3(e4[a4 + 0], r4), c3(e4[a4 + 1], n3), c3(e4[a4 + 2], i4), o5(r4, n3, i4, t4);
          }(n2 = n2 || 0), function(t4) {
            for (var e5 = new d2(), r4 = 0; r4 < i3.length; r4 += 3)
              e5.x = i3[r4 + 0], e5.y = i3[r4 + 1], e5.z = i3[r4 + 2], e5.normalize().multiplyScalar(t4), i3[r4 + 0] = e5.x, i3[r4 + 1] = e5.y, i3[r4 + 2] = e5.z;
          }(r3), function() {
            for (var t4 = new d2(), e5 = 0; e5 < i3.length; e5 += 3) {
              t4.x = i3[e5 + 0], t4.y = i3[e5 + 1], t4.z = i3[e5 + 2];
              var r4 = u3(t4) / 2 / Math.PI + 0.5, n3 = (o6 = t4, Math.atan2(-o6.y, Math.sqrt(o6.x * o6.x + o6.z * o6.z)) / Math.PI + 0.5);
              a3.push(r4, 1 - n3);
            }
            var o6;
            (function() {
              for (var t5 = new d2(), e6 = new d2(), r5 = new d2(), n4 = new d2(), o7 = new l3(), s5 = new l3(), c4 = new l3(), p3 = 0, f3 = 0; p3 < i3.length; p3 += 9, f3 += 6) {
                t5.set(i3[p3 + 0], i3[p3 + 1], i3[p3 + 2]), e6.set(i3[p3 + 3], i3[p3 + 4], i3[p3 + 5]), r5.set(i3[p3 + 6], i3[p3 + 7], i3[p3 + 8]), o7.set(a3[f3 + 0], a3[f3 + 1]), s5.set(a3[f3 + 2], a3[f3 + 3]), c4.set(a3[f3 + 4], a3[f3 + 5]), n4.copy(t5).add(e6).add(r5).divideScalar(3);
                var m3 = u3(n4);
                h3(o7, f3 + 0, t5, m3), h3(s5, f3 + 2, e6, m3), h3(c4, f3 + 4, r5, m3);
              }
            })(), function() {
              for (var t5 = 0; t5 < a3.length; t5 += 6) {
                var e6 = a3[t5 + 0], r5 = a3[t5 + 2], n4 = a3[t5 + 4], i4 = Math.max(e6, r5, n4), o7 = Math.min(e6, r5, n4);
                i4 > 0.9 && o7 < 0.1 && (e6 < 0.2 && (a3[t5 + 0] += 1), r5 < 0.2 && (a3[t5 + 2] += 1), n4 < 0.2 && (a3[t5 + 4] += 1));
              }
            }();
          }(), this.addAttribute("position", new Zt(i3, 3)), this.addAttribute("normal", new Zt(i3.slice(), 3)), this.addAttribute("uv", new Zt(a3, 2)), n2 === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        }
        function Ki(t3, e4) {
          Oe.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: t3, detail: e4 }, this.fromBufferGeometry(new $i(t3, e4)), this.mergeVertices();
        }
        function $i(t3, e4) {
          Qi.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t3, e4), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: t3, detail: e4 };
        }
        function ta(t3, e4) {
          Oe.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: t3, detail: e4 }, this.fromBufferGeometry(new ea(t3, e4)), this.mergeVertices();
        }
        function ea(t3, e4) {
          Qi.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t3, e4), this.type = "OctahedronBufferGeometry", this.parameters = { radius: t3, detail: e4 };
        }
        function ra(t3, e4) {
          Oe.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: t3, detail: e4 }, this.fromBufferGeometry(new na(t3, e4)), this.mergeVertices();
        }
        function na(t3, e4) {
          var r3 = (1 + Math.sqrt(5)) / 2, n2 = [-1, r3, 0, 1, r3, 0, -1, -r3, 0, 1, -r3, 0, 0, -1, r3, 0, 1, r3, 0, -1, -r3, 0, 1, -r3, r3, 0, -1, r3, 0, 1, -r3, 0, -1, -r3, 0, 1];
          Qi.call(this, n2, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t3, e4), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: t3, detail: e4 };
        }
        function ia(t3, e4) {
          Oe.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: t3, detail: e4 }, this.fromBufferGeometry(new aa(t3, e4)), this.mergeVertices();
        }
        function aa(t3, e4) {
          var r3 = (1 + Math.sqrt(5)) / 2, n2 = 1 / r3, i3 = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n2, -r3, 0, -n2, r3, 0, n2, -r3, 0, n2, r3, -n2, -r3, 0, -n2, r3, 0, n2, -r3, 0, n2, r3, 0, -r3, 0, -n2, r3, 0, -n2, -r3, 0, n2, r3, 0, n2];
          Qi.call(this, i3, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t3, e4), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: t3, detail: e4 };
        }
        function oa(t3, e4, r3, n2, i3, a3) {
          Oe.call(this), this.type = "TubeGeometry", this.parameters = { path: t3, tubularSegments: e4, radius: r3, radialSegments: n2, closed: i3 }, a3 !== void 0 && console.warn("THREE.TubeGeometry: taper has been removed.");
          var o5 = new sa(t3, e4, r3, n2, i3);
          this.tangents = o5.tangents, this.normals = o5.normals, this.binormals = o5.binormals, this.fromBufferGeometry(o5), this.mergeVertices();
        }
        function sa(t3, e4, r3, n2, i3) {
          se.call(this), this.type = "TubeBufferGeometry", this.parameters = { path: t3, tubularSegments: e4, radius: r3, radialSegments: n2, closed: i3 }, e4 = e4 || 64, r3 = r3 || 1, n2 = n2 || 8, i3 = i3 || false;
          var a3 = t3.computeFrenetFrames(e4, i3);
          this.tangents = a3.tangents, this.normals = a3.normals, this.binormals = a3.binormals;
          var o5, s4, c3 = new d2(), h3 = new d2(), u3 = new l3(), p3 = new d2(), f3 = [], m3 = [], g3 = [], v3 = [];
          function y3(i4) {
            p3 = t3.getPointAt(i4 / e4, p3);
            var o6 = a3.normals[i4], l4 = a3.binormals[i4];
            for (s4 = 0; s4 <= n2; s4++) {
              var u4 = s4 / n2 * Math.PI * 2, d3 = Math.sin(u4), g4 = -Math.cos(u4);
              h3.x = g4 * o6.x + d3 * l4.x, h3.y = g4 * o6.y + d3 * l4.y, h3.z = g4 * o6.z + d3 * l4.z, h3.normalize(), m3.push(h3.x, h3.y, h3.z), c3.x = p3.x + r3 * h3.x, c3.y = p3.y + r3 * h3.y, c3.z = p3.z + r3 * h3.z, f3.push(c3.x, c3.y, c3.z);
            }
          }
          !function() {
            for (o5 = 0; o5 < e4; o5++)
              y3(o5);
            y3(i3 === false ? e4 : 0), function() {
              for (o5 = 0; o5 <= e4; o5++)
                for (s4 = 0; s4 <= n2; s4++)
                  u3.x = o5 / e4, u3.y = s4 / n2, g3.push(u3.x, u3.y);
            }(), function() {
              for (s4 = 1; s4 <= e4; s4++)
                for (o5 = 1; o5 <= n2; o5++) {
                  var t4 = (n2 + 1) * (s4 - 1) + (o5 - 1), r4 = (n2 + 1) * s4 + (o5 - 1), i4 = (n2 + 1) * s4 + o5, a4 = (n2 + 1) * (s4 - 1) + o5;
                  v3.push(t4, r4, a4), v3.push(r4, i4, a4);
                }
            }();
          }(), this.setIndex(v3), this.addAttribute("position", new Zt(f3, 3)), this.addAttribute("normal", new Zt(m3, 3)), this.addAttribute("uv", new Zt(g3, 2));
        }
        function ca(t3, e4, r3, n2, i3, a3, o5) {
          Oe.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: t3, tube: e4, tubularSegments: r3, radialSegments: n2, p: i3, q: a3 }, o5 !== void 0 && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new la(t3, e4, r3, n2, i3, a3)), this.mergeVertices();
        }
        function la(t3, e4, r3, n2, i3, a3) {
          se.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: t3, tube: e4, tubularSegments: r3, radialSegments: n2, p: i3, q: a3 }, t3 = t3 || 1, e4 = e4 || 0.4, r3 = Math.floor(r3) || 64, n2 = Math.floor(n2) || 8, i3 = i3 || 2, a3 = a3 || 3;
          var o5, s4, c3 = [], l4 = [], h3 = [], u3 = [], p3 = new d2(), f3 = new d2(), m3 = new d2(), g3 = new d2(), v3 = new d2(), y3 = new d2(), x3 = new d2();
          for (o5 = 0; o5 <= r3; ++o5) {
            var b3 = o5 / r3 * i3 * Math.PI * 2;
            for (L3(b3, i3, a3, t3, m3), L3(b3 + 0.01, i3, a3, t3, g3), y3.subVectors(g3, m3), x3.addVectors(g3, m3), v3.crossVectors(y3, x3), x3.crossVectors(v3, y3), v3.normalize(), x3.normalize(), s4 = 0; s4 <= n2; ++s4) {
              var w3 = s4 / n2 * Math.PI * 2, _3 = -e4 * Math.cos(w3), M3 = e4 * Math.sin(w3);
              p3.x = m3.x + (_3 * x3.x + M3 * v3.x), p3.y = m3.y + (_3 * x3.y + M3 * v3.y), p3.z = m3.z + (_3 * x3.z + M3 * v3.z), l4.push(p3.x, p3.y, p3.z), f3.subVectors(p3, m3).normalize(), h3.push(f3.x, f3.y, f3.z), u3.push(o5 / r3), u3.push(s4 / n2);
            }
          }
          for (s4 = 1; s4 <= r3; s4++)
            for (o5 = 1; o5 <= n2; o5++) {
              var S3 = (n2 + 1) * (s4 - 1) + (o5 - 1), T3 = (n2 + 1) * s4 + (o5 - 1), E4 = (n2 + 1) * s4 + o5, A3 = (n2 + 1) * (s4 - 1) + o5;
              c3.push(S3, T3, A3), c3.push(T3, E4, A3);
            }
          function L3(t4, e5, r4, n3, i4) {
            var a4 = Math.cos(t4), o6 = Math.sin(t4), s5 = r4 / e5 * t4, c4 = Math.cos(s5);
            i4.x = n3 * (2 + c4) * 0.5 * a4, i4.y = n3 * (2 + c4) * o6 * 0.5, i4.z = n3 * Math.sin(s5) * 0.5;
          }
          this.setIndex(c3), this.addAttribute("position", new Zt(l4, 3)), this.addAttribute("normal", new Zt(h3, 3)), this.addAttribute("uv", new Zt(u3, 2));
        }
        function ha(t3, e4, r3, n2, i3) {
          Oe.call(this), this.type = "TorusGeometry", this.parameters = { radius: t3, tube: e4, radialSegments: r3, tubularSegments: n2, arc: i3 }, this.fromBufferGeometry(new ua(t3, e4, r3, n2, i3)), this.mergeVertices();
        }
        function ua(t3, e4, r3, n2, i3) {
          se.call(this), this.type = "TorusBufferGeometry", this.parameters = { radius: t3, tube: e4, radialSegments: r3, tubularSegments: n2, arc: i3 }, t3 = t3 || 1, e4 = e4 || 0.4, r3 = Math.floor(r3) || 8, n2 = Math.floor(n2) || 6, i3 = i3 || 2 * Math.PI;
          var a3, o5, s4 = [], c3 = [], l4 = [], h3 = [], u3 = new d2(), p3 = new d2(), f3 = new d2();
          for (a3 = 0; a3 <= r3; a3++)
            for (o5 = 0; o5 <= n2; o5++) {
              var m3 = o5 / n2 * i3, g3 = a3 / r3 * Math.PI * 2;
              p3.x = (t3 + e4 * Math.cos(g3)) * Math.cos(m3), p3.y = (t3 + e4 * Math.cos(g3)) * Math.sin(m3), p3.z = e4 * Math.sin(g3), c3.push(p3.x, p3.y, p3.z), u3.x = t3 * Math.cos(m3), u3.y = t3 * Math.sin(m3), f3.subVectors(p3, u3).normalize(), l4.push(f3.x, f3.y, f3.z), h3.push(o5 / n2), h3.push(a3 / r3);
            }
          for (a3 = 1; a3 <= r3; a3++)
            for (o5 = 1; o5 <= n2; o5++) {
              var v3 = (n2 + 1) * a3 + o5 - 1, y3 = (n2 + 1) * (a3 - 1) + o5 - 1, x3 = (n2 + 1) * (a3 - 1) + o5, b3 = (n2 + 1) * a3 + o5;
              s4.push(v3, y3, b3), s4.push(y3, x3, b3);
            }
          this.setIndex(s4), this.addAttribute("position", new Zt(c3, 3)), this.addAttribute("normal", new Zt(l4, 3)), this.addAttribute("uv", new Zt(h3, 2));
        }
        Hi.prototype = Object.assign(Object.create(Y.prototype), { constructor: Hi, isPoints: true, raycast: function(t3, e4) {
          var r3 = this.geometry, n2 = this.matrixWorld, i3 = t3.params.Points.threshold;
          if (r3.boundingSphere === null && r3.computeBoundingSphere(), Gi.copy(r3.boundingSphere), Gi.applyMatrix4(n2), Gi.radius += i3, t3.ray.intersectsSphere(Gi) !== false) {
            Bi.getInverse(n2), Fi.copy(t3.ray).applyMatrix4(Bi);
            var a3 = i3 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o5 = a3 * a3;
            if (r3.isBufferGeometry) {
              var s4 = r3.index, c3 = r3.attributes.position.array;
              if (s4 !== null)
                for (var l4 = s4.array, h3 = 0, u3 = l4.length; h3 < u3; h3++) {
                  var p3 = l4[h3];
                  Ui.fromArray(c3, 3 * p3), Vi(Ui, p3, o5, n2, t3, e4, this);
                }
              else {
                h3 = 0;
                for (var d3 = c3.length / 3; h3 < d3; h3++)
                  Ui.fromArray(c3, 3 * h3), Vi(Ui, h3, o5, n2, t3, e4, this);
              }
            } else {
              var f3 = r3.vertices;
              for (h3 = 0, d3 = f3.length; h3 < d3; h3++)
                Vi(f3[h3], h3, o5, n2, t3, e4, this);
            }
          }
        }, updateMorphTargets: function() {
          var t3, e4, r3, n2 = this.geometry;
          if (n2.isBufferGeometry) {
            var i3 = n2.morphAttributes, a3 = Object.keys(i3);
            if (a3.length > 0) {
              var o5 = i3[a3[0]];
              if (o5 !== void 0)
                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t3 = 0, e4 = o5.length; t3 < e4; t3++)
                  r3 = o5[t3].name || String(t3), this.morphTargetInfluences.push(0), this.morphTargetDictionary[r3] = t3;
            }
          } else {
            var s4 = n2.morphTargets;
            s4 !== void 0 && s4.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }, clone: function() {
          return new this.constructor(this.geometry, this.material).copy(this);
        } }), ji.prototype = Object.assign(Object.create(y2.prototype), { constructor: ji, isVideoTexture: true, update: function() {
          var t3 = this.image;
          t3.readyState >= t3.HAVE_CURRENT_DATA && (this.needsUpdate = true);
        } }), ki.prototype = Object.create(y2.prototype), ki.prototype.constructor = ki, ki.prototype.isCompressedTexture = true, Wi.prototype = Object.create(y2.prototype), Wi.prototype.constructor = Wi, Wi.prototype.isCanvasTexture = true, qi.prototype = Object.create(y2.prototype), qi.prototype.constructor = qi, qi.prototype.isDepthTexture = true, Xi.prototype = Object.create(se.prototype), Xi.prototype.constructor = Xi, Yi.prototype = Object.create(Oe.prototype), Yi.prototype.constructor = Yi, Ji.prototype = Object.create(se.prototype), Ji.prototype.constructor = Ji, Zi.prototype = Object.create(Oe.prototype), Zi.prototype.constructor = Zi, Qi.prototype = Object.create(se.prototype), Qi.prototype.constructor = Qi, Ki.prototype = Object.create(Oe.prototype), Ki.prototype.constructor = Ki, $i.prototype = Object.create(Qi.prototype), $i.prototype.constructor = $i, ta.prototype = Object.create(Oe.prototype), ta.prototype.constructor = ta, ea.prototype = Object.create(Qi.prototype), ea.prototype.constructor = ea, ra.prototype = Object.create(Oe.prototype), ra.prototype.constructor = ra, na.prototype = Object.create(Qi.prototype), na.prototype.constructor = na, ia.prototype = Object.create(Oe.prototype), ia.prototype.constructor = ia, aa.prototype = Object.create(Qi.prototype), aa.prototype.constructor = aa, oa.prototype = Object.create(Oe.prototype), oa.prototype.constructor = oa, sa.prototype = Object.create(se.prototype), sa.prototype.constructor = sa, sa.prototype.toJSON = function() {
          var t3 = se.prototype.toJSON.call(this);
          return t3.path = this.parameters.path.toJSON(), t3;
        }, ca.prototype = Object.create(Oe.prototype), ca.prototype.constructor = ca, la.prototype = Object.create(se.prototype), la.prototype.constructor = la, ha.prototype = Object.create(Oe.prototype), ha.prototype.constructor = ha, ua.prototype = Object.create(se.prototype), ua.prototype.constructor = ua;
        var pa = function(t3, e4, r3) {
          r3 = r3 || 2;
          var n2, i3, a3, o5, s4, c3, l4, h3 = e4 && e4.length, u3 = h3 ? e4[0] * r3 : t3.length, p3 = da(t3, 0, u3, r3, true), d3 = [];
          if (!p3 || p3.next === p3.prev)
            return d3;
          if (h3 && (p3 = function(t4, e5, r4, n3) {
            var i4, a4, o6, s5, c4, l5 = [];
            for (i4 = 0, a4 = e5.length; i4 < a4; i4++)
              o6 = e5[i4] * n3, s5 = i4 < a4 - 1 ? e5[i4 + 1] * n3 : t4.length, (c4 = da(t4, o6, s5, n3, false)) === c4.next && (c4.steiner = true), l5.push(Ma(c4));
            for (l5.sort(ba), i4 = 0; i4 < l5.length; i4++)
              wa(l5[i4], r4), r4 = fa(r4, r4.next);
            return r4;
          }(t3, e4, p3, r3)), t3.length > 80 * r3) {
            n2 = a3 = t3[0], i3 = o5 = t3[1];
            for (var f3 = r3; f3 < u3; f3 += r3)
              (s4 = t3[f3]) < n2 && (n2 = s4), (c3 = t3[f3 + 1]) < i3 && (i3 = c3), s4 > a3 && (a3 = s4), c3 > o5 && (o5 = c3);
            l4 = (l4 = Math.max(a3 - n2, o5 - i3)) !== 0 ? 1 / l4 : 0;
          }
          return ma(p3, d3, r3, n2, i3, l4), d3;
        };
        function da(t3, e4, r3, n2, i3) {
          var a3, o5;
          if (i3 === function(t4, e5, r4, n3) {
            for (var i4 = 0, a4 = e5, o6 = r4 - n3; a4 < r4; a4 += n3)
              i4 += (t4[o6] - t4[a4]) * (t4[a4 + 1] + t4[o6 + 1]), o6 = a4;
            return i4;
          }(t3, e4, r3, n2) > 0)
            for (a3 = e4; a3 < r3; a3 += n2)
              o5 = Ca(a3, t3[a3], t3[a3 + 1], o5);
          else
            for (a3 = r3 - n2; a3 >= e4; a3 -= n2)
              o5 = Ca(a3, t3[a3], t3[a3 + 1], o5);
          return o5 && Aa(o5, o5.next) && (Oa(o5), o5 = o5.next), o5;
        }
        function fa(t3, e4) {
          if (!t3)
            return t3;
          e4 || (e4 = t3);
          var r3, n2 = t3;
          do {
            if (r3 = false, n2.steiner || !Aa(n2, n2.next) && Ea(n2.prev, n2, n2.next) !== 0)
              n2 = n2.next;
            else {
              if (Oa(n2), (n2 = e4 = n2.prev) === n2.next)
                break;
              r3 = true;
            }
          } while (r3 || n2 !== e4);
          return e4;
        }
        function ma(t3, e4, r3, n2, i3, a3, o5) {
          if (t3) {
            !o5 && a3 && function(t4, e5, r4, n3) {
              var i4 = t4;
              do {
                i4.z === null && (i4.z = _a(i4.x, i4.y, e5, r4, n3)), i4.prevZ = i4.prev, i4.nextZ = i4.next, i4 = i4.next;
              } while (i4 !== t4);
              i4.prevZ.nextZ = null, i4.prevZ = null, function(t5) {
                var e6, r5, n4, i5, a4, o6, s5, c4, l5 = 1;
                do {
                  for (r5 = t5, t5 = null, a4 = null, o6 = 0; r5; ) {
                    for (o6++, n4 = r5, s5 = 0, e6 = 0; e6 < l5 && (s5++, n4 = n4.nextZ); e6++)
                      ;
                    for (c4 = l5; s5 > 0 || c4 > 0 && n4; )
                      s5 !== 0 && (c4 === 0 || !n4 || r5.z <= n4.z) ? (i5 = r5, r5 = r5.nextZ, s5--) : (i5 = n4, n4 = n4.nextZ, c4--), a4 ? a4.nextZ = i5 : t5 = i5, i5.prevZ = a4, a4 = i5;
                    r5 = n4;
                  }
                  a4.nextZ = null, l5 *= 2;
                } while (o6 > 1);
              }(i4);
            }(t3, n2, i3, a3);
            for (var s4, c3, l4 = t3; t3.prev !== t3.next; )
              if (s4 = t3.prev, c3 = t3.next, a3 ? va(t3, n2, i3, a3) : ga(t3))
                e4.push(s4.i / r3), e4.push(t3.i / r3), e4.push(c3.i / r3), Oa(t3), t3 = c3.next, l4 = c3.next;
              else if ((t3 = c3) === l4) {
                o5 ? o5 === 1 ? ma(t3 = ya(t3, e4, r3), e4, r3, n2, i3, a3, 2) : o5 === 2 && xa(t3, e4, r3, n2, i3, a3) : ma(fa(t3), e4, r3, n2, i3, a3, 1);
                break;
              }
          }
        }
        function ga(t3) {
          var e4 = t3.prev, r3 = t3, n2 = t3.next;
          if (Ea(e4, r3, n2) >= 0)
            return false;
          for (var i3 = t3.next.next; i3 !== t3.prev; ) {
            if (Sa(e4.x, e4.y, r3.x, r3.y, n2.x, n2.y, i3.x, i3.y) && Ea(i3.prev, i3, i3.next) >= 0)
              return false;
            i3 = i3.next;
          }
          return true;
        }
        function va(t3, e4, r3, n2) {
          var i3 = t3.prev, a3 = t3, o5 = t3.next;
          if (Ea(i3, a3, o5) >= 0)
            return false;
          for (var s4 = i3.x < a3.x ? i3.x < o5.x ? i3.x : o5.x : a3.x < o5.x ? a3.x : o5.x, c3 = i3.y < a3.y ? i3.y < o5.y ? i3.y : o5.y : a3.y < o5.y ? a3.y : o5.y, l4 = i3.x > a3.x ? i3.x > o5.x ? i3.x : o5.x : a3.x > o5.x ? a3.x : o5.x, h3 = i3.y > a3.y ? i3.y > o5.y ? i3.y : o5.y : a3.y > o5.y ? a3.y : o5.y, u3 = _a(s4, c3, e4, r3, n2), p3 = _a(l4, h3, e4, r3, n2), d3 = t3.prevZ, f3 = t3.nextZ; d3 && d3.z >= u3 && f3 && f3.z <= p3; ) {
            if (d3 !== t3.prev && d3 !== t3.next && Sa(i3.x, i3.y, a3.x, a3.y, o5.x, o5.y, d3.x, d3.y) && Ea(d3.prev, d3, d3.next) >= 0)
              return false;
            if (d3 = d3.prevZ, f3 !== t3.prev && f3 !== t3.next && Sa(i3.x, i3.y, a3.x, a3.y, o5.x, o5.y, f3.x, f3.y) && Ea(f3.prev, f3, f3.next) >= 0)
              return false;
            f3 = f3.nextZ;
          }
          for (; d3 && d3.z >= u3; ) {
            if (d3 !== t3.prev && d3 !== t3.next && Sa(i3.x, i3.y, a3.x, a3.y, o5.x, o5.y, d3.x, d3.y) && Ea(d3.prev, d3, d3.next) >= 0)
              return false;
            d3 = d3.prevZ;
          }
          for (; f3 && f3.z <= p3; ) {
            if (f3 !== t3.prev && f3 !== t3.next && Sa(i3.x, i3.y, a3.x, a3.y, o5.x, o5.y, f3.x, f3.y) && Ea(f3.prev, f3, f3.next) >= 0)
              return false;
            f3 = f3.nextZ;
          }
          return true;
        }
        function ya(t3, e4, r3) {
          var n2 = t3;
          do {
            var i3 = n2.prev, a3 = n2.next.next;
            !Aa(i3, a3) && La(i3, n2, n2.next, a3) && Ra(i3, a3) && Ra(a3, i3) && (e4.push(i3.i / r3), e4.push(n2.i / r3), e4.push(a3.i / r3), Oa(n2), Oa(n2.next), n2 = t3 = a3), n2 = n2.next;
          } while (n2 !== t3);
          return n2;
        }
        function xa(t3, e4, r3, n2, i3, a3) {
          var o5 = t3;
          do {
            for (var s4 = o5.next.next; s4 !== o5.prev; ) {
              if (o5.i !== s4.i && Ta(o5, s4)) {
                var c3 = Pa(o5, s4);
                return o5 = fa(o5, o5.next), c3 = fa(c3, c3.next), ma(o5, e4, r3, n2, i3, a3), void ma(c3, e4, r3, n2, i3, a3);
              }
              s4 = s4.next;
            }
            o5 = o5.next;
          } while (o5 !== t3);
        }
        function ba(t3, e4) {
          return t3.x - e4.x;
        }
        function wa(t3, e4) {
          if (e4 = function(t4, e5) {
            var r4, n2 = e5, i3 = t4.x, a3 = t4.y, o5 = -1 / 0;
            do {
              if (a3 <= n2.y && a3 >= n2.next.y && n2.next.y !== n2.y) {
                var s4 = n2.x + (a3 - n2.y) * (n2.next.x - n2.x) / (n2.next.y - n2.y);
                if (s4 <= i3 && s4 > o5) {
                  if (o5 = s4, s4 === i3) {
                    if (a3 === n2.y)
                      return n2;
                    if (a3 === n2.next.y)
                      return n2.next;
                  }
                  r4 = n2.x < n2.next.x ? n2 : n2.next;
                }
              }
              n2 = n2.next;
            } while (n2 !== e5);
            if (!r4)
              return null;
            if (i3 === o5)
              return r4.prev;
            var c3, l4 = r4, h3 = r4.x, u3 = r4.y, p3 = 1 / 0;
            for (n2 = r4.next; n2 !== l4; )
              i3 >= n2.x && n2.x >= h3 && i3 !== n2.x && Sa(a3 < u3 ? i3 : o5, a3, h3, u3, a3 < u3 ? o5 : i3, a3, n2.x, n2.y) && ((c3 = Math.abs(a3 - n2.y) / (i3 - n2.x)) < p3 || c3 === p3 && n2.x > r4.x) && Ra(n2, t4) && (r4 = n2, p3 = c3), n2 = n2.next;
            return r4;
          }(t3, e4)) {
            var r3 = Pa(e4, t3);
            fa(r3, r3.next);
          }
        }
        function _a(t3, e4, r3, n2, i3) {
          return (t3 = 1431655765 & ((t3 = 858993459 & ((t3 = 252645135 & ((t3 = 16711935 & ((t3 = 32767 * (t3 - r3) * i3) | t3 << 8)) | t3 << 4)) | t3 << 2)) | t3 << 1)) | (e4 = 1431655765 & ((e4 = 858993459 & ((e4 = 252645135 & ((e4 = 16711935 & ((e4 = 32767 * (e4 - n2) * i3) | e4 << 8)) | e4 << 4)) | e4 << 2)) | e4 << 1)) << 1;
        }
        function Ma(t3) {
          var e4 = t3, r3 = t3;
          do {
            (e4.x < r3.x || e4.x === r3.x && e4.y < r3.y) && (r3 = e4), e4 = e4.next;
          } while (e4 !== t3);
          return r3;
        }
        function Sa(t3, e4, r3, n2, i3, a3, o5, s4) {
          return (i3 - o5) * (e4 - s4) - (t3 - o5) * (a3 - s4) >= 0 && (t3 - o5) * (n2 - s4) - (r3 - o5) * (e4 - s4) >= 0 && (r3 - o5) * (a3 - s4) - (i3 - o5) * (n2 - s4) >= 0;
        }
        function Ta(t3, e4) {
          return t3.next.i !== e4.i && t3.prev.i !== e4.i && !function(t4, e5) {
            var r3 = t4;
            do {
              if (r3.i !== t4.i && r3.next.i !== t4.i && r3.i !== e5.i && r3.next.i !== e5.i && La(r3, r3.next, t4, e5))
                return true;
              r3 = r3.next;
            } while (r3 !== t4);
            return false;
          }(t3, e4) && Ra(t3, e4) && Ra(e4, t3) && function(t4, e5) {
            var r3 = t4, n2 = false, i3 = (t4.x + e5.x) / 2, a3 = (t4.y + e5.y) / 2;
            do {
              r3.y > a3 != r3.next.y > a3 && r3.next.y !== r3.y && i3 < (r3.next.x - r3.x) * (a3 - r3.y) / (r3.next.y - r3.y) + r3.x && (n2 = !n2), r3 = r3.next;
            } while (r3 !== t4);
            return n2;
          }(t3, e4);
        }
        function Ea(t3, e4, r3) {
          return (e4.y - t3.y) * (r3.x - e4.x) - (e4.x - t3.x) * (r3.y - e4.y);
        }
        function Aa(t3, e4) {
          return t3.x === e4.x && t3.y === e4.y;
        }
        function La(t3, e4, r3, n2) {
          return !!(Aa(t3, r3) && Aa(e4, n2) || Aa(t3, n2) && Aa(r3, e4)) || Ea(t3, e4, r3) > 0 != Ea(t3, e4, n2) > 0 && Ea(r3, n2, t3) > 0 != Ea(r3, n2, e4) > 0;
        }
        function Ra(t3, e4) {
          return Ea(t3.prev, t3, t3.next) < 0 ? Ea(t3, e4, t3.next) >= 0 && Ea(t3, t3.prev, e4) >= 0 : Ea(t3, e4, t3.prev) < 0 || Ea(t3, t3.next, e4) < 0;
        }
        function Pa(t3, e4) {
          var r3 = new Da(t3.i, t3.x, t3.y), n2 = new Da(e4.i, e4.x, e4.y), i3 = t3.next, a3 = e4.prev;
          return t3.next = e4, e4.prev = t3, r3.next = i3, i3.prev = r3, n2.next = r3, r3.prev = n2, a3.next = n2, n2.prev = a3, n2;
        }
        function Ca(t3, e4, r3, n2) {
          var i3 = new Da(t3, e4, r3);
          return n2 ? (i3.next = n2.next, i3.prev = n2, n2.next.prev = i3, n2.next = i3) : (i3.prev = i3, i3.next = i3), i3;
        }
        function Oa(t3) {
          t3.next.prev = t3.prev, t3.prev.next = t3.next, t3.prevZ && (t3.prevZ.nextZ = t3.nextZ), t3.nextZ && (t3.nextZ.prevZ = t3.prevZ);
        }
        function Da(t3, e4, r3) {
          this.i = t3, this.x = e4, this.y = r3, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        var Na = { area: function(t3) {
          for (var e4 = t3.length, r3 = 0, n2 = e4 - 1, i3 = 0; i3 < e4; n2 = i3++)
            r3 += t3[n2].x * t3[i3].y - t3[i3].x * t3[n2].y;
          return 0.5 * r3;
        }, isClockWise: function(t3) {
          return Na.area(t3) < 0;
        }, triangulateShape: function(t3, e4) {
          var r3 = [], n2 = [], i3 = [];
          Ia(t3), za(r3, t3);
          var a3 = t3.length;
          e4.forEach(Ia);
          for (var o5 = 0; o5 < e4.length; o5++)
            n2.push(a3), a3 += e4[o5].length, za(r3, e4[o5]);
          var s4 = pa(r3, n2);
          for (o5 = 0; o5 < s4.length; o5 += 3)
            i3.push(s4.slice(o5, o5 + 3));
          return i3;
        } };
        function Ia(t3) {
          var e4 = t3.length;
          e4 > 2 && t3[e4 - 1].equals(t3[0]) && t3.pop();
        }
        function za(t3, e4) {
          for (var r3 = 0; r3 < e4.length; r3++)
            t3.push(e4[r3].x), t3.push(e4[r3].y);
        }
        function Ba(t3, e4) {
          Oe.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: t3, options: e4 }, this.fromBufferGeometry(new Fa(t3, e4)), this.mergeVertices();
        }
        function Fa(t3, e4) {
          se.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: t3, options: e4 }, t3 = Array.isArray(t3) ? t3 : [t3];
          for (var r3 = this, n2 = [], i3 = [], a3 = 0, o5 = t3.length; a3 < o5; a3++)
            s4(t3[a3]);
          function s4(t4) {
            var a4 = [], o6 = e4.curveSegments !== void 0 ? e4.curveSegments : 12, s5 = e4.steps !== void 0 ? e4.steps : 1, c3 = e4.depth !== void 0 ? e4.depth : 100, h3 = e4.bevelEnabled === void 0 || e4.bevelEnabled, u3 = e4.bevelThickness !== void 0 ? e4.bevelThickness : 6, p3 = e4.bevelSize !== void 0 ? e4.bevelSize : u3 - 2, f3 = e4.bevelOffset !== void 0 ? e4.bevelOffset : 0, m3 = e4.bevelSegments !== void 0 ? e4.bevelSegments : 3, g3 = e4.extrudePath, v3 = e4.UVGenerator !== void 0 ? e4.UVGenerator : Ga;
            e4.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c3 = e4.amount);
            var y3, x3, b3, w3, _3, M3, S3, T3, E4 = false;
            g3 && (y3 = g3.getSpacedPoints(s5), E4 = true, h3 = false, x3 = g3.computeFrenetFrames(s5, false), b3 = new d2(), w3 = new d2(), _3 = new d2()), h3 || (m3 = 0, u3 = 0, p3 = 0, f3 = 0);
            var A3 = t4.extractPoints(o6), L3 = A3.shape, R2 = A3.holes;
            if (!Na.isClockWise(L3))
              for (L3 = L3.reverse(), S3 = 0, T3 = R2.length; S3 < T3; S3++)
                M3 = R2[S3], Na.isClockWise(M3) && (R2[S3] = M3.reverse());
            var P3 = Na.triangulateShape(L3, R2), C2 = L3;
            for (S3 = 0, T3 = R2.length; S3 < T3; S3++)
              M3 = R2[S3], L3 = L3.concat(M3);
            function O2(t5, e5, r4) {
              return e5 || console.error("THREE.ExtrudeGeometry: vec does not exist"), e5.clone().multiplyScalar(r4).add(t5);
            }
            var D2, N2, I2, z2, B2, F2, G2 = L3.length, U2 = P3.length;
            function H2(t5, e5, r4) {
              var n3, i4, a5, o7 = t5.x - e5.x, s6 = t5.y - e5.y, c4 = r4.x - t5.x, h4 = r4.y - t5.y, u4 = o7 * o7 + s6 * s6, p4 = o7 * h4 - s6 * c4;
              if (Math.abs(p4) > Number.EPSILON) {
                var d3 = Math.sqrt(u4), f4 = Math.sqrt(c4 * c4 + h4 * h4), m4 = e5.x - s6 / d3, g4 = e5.y + o7 / d3, v4 = ((r4.x - h4 / f4 - m4) * h4 - (r4.y + c4 / f4 - g4) * c4) / (o7 * h4 - s6 * c4), y4 = (n3 = m4 + o7 * v4 - t5.x) * n3 + (i4 = g4 + s6 * v4 - t5.y) * i4;
                if (y4 <= 2)
                  return new l3(n3, i4);
                a5 = Math.sqrt(y4 / 2);
              } else {
                var x4 = false;
                o7 > Number.EPSILON ? c4 > Number.EPSILON && (x4 = true) : o7 < -Number.EPSILON ? c4 < -Number.EPSILON && (x4 = true) : Math.sign(s6) === Math.sign(h4) && (x4 = true), x4 ? (n3 = -s6, i4 = o7, a5 = Math.sqrt(u4)) : (n3 = o7, i4 = s6, a5 = Math.sqrt(u4 / 2));
              }
              return new l3(n3 / a5, i4 / a5);
            }
            for (var V2 = [], j2 = 0, k2 = C2.length, W2 = k2 - 1, q2 = j2 + 1; j2 < k2; j2++, W2++, q2++)
              W2 === k2 && (W2 = 0), q2 === k2 && (q2 = 0), V2[j2] = H2(C2[j2], C2[W2], C2[q2]);
            var X2, Y2, J2 = [], Z2 = V2.concat();
            for (S3 = 0, T3 = R2.length; S3 < T3; S3++) {
              for (M3 = R2[S3], X2 = [], j2 = 0, W2 = (k2 = M3.length) - 1, q2 = j2 + 1; j2 < k2; j2++, W2++, q2++)
                W2 === k2 && (W2 = 0), q2 === k2 && (q2 = 0), X2[j2] = H2(M3[j2], M3[W2], M3[q2]);
              J2.push(X2), Z2 = Z2.concat(X2);
            }
            for (D2 = 0; D2 < m3; D2++) {
              for (I2 = D2 / m3, z2 = u3 * Math.cos(I2 * Math.PI / 2), N2 = p3 * Math.sin(I2 * Math.PI / 2) + f3, j2 = 0, k2 = C2.length; j2 < k2; j2++)
                K2((B2 = O2(C2[j2], V2[j2], N2)).x, B2.y, -z2);
              for (S3 = 0, T3 = R2.length; S3 < T3; S3++)
                for (M3 = R2[S3], X2 = J2[S3], j2 = 0, k2 = M3.length; j2 < k2; j2++)
                  K2((B2 = O2(M3[j2], X2[j2], N2)).x, B2.y, -z2);
            }
            for (N2 = p3 + f3, j2 = 0; j2 < G2; j2++)
              B2 = h3 ? O2(L3[j2], Z2[j2], N2) : L3[j2], E4 ? (w3.copy(x3.normals[0]).multiplyScalar(B2.x), b3.copy(x3.binormals[0]).multiplyScalar(B2.y), _3.copy(y3[0]).add(w3).add(b3), K2(_3.x, _3.y, _3.z)) : K2(B2.x, B2.y, 0);
            for (Y2 = 1; Y2 <= s5; Y2++)
              for (j2 = 0; j2 < G2; j2++)
                B2 = h3 ? O2(L3[j2], Z2[j2], N2) : L3[j2], E4 ? (w3.copy(x3.normals[Y2]).multiplyScalar(B2.x), b3.copy(x3.binormals[Y2]).multiplyScalar(B2.y), _3.copy(y3[Y2]).add(w3).add(b3), K2(_3.x, _3.y, _3.z)) : K2(B2.x, B2.y, c3 / s5 * Y2);
            for (D2 = m3 - 1; D2 >= 0; D2--) {
              for (I2 = D2 / m3, z2 = u3 * Math.cos(I2 * Math.PI / 2), N2 = p3 * Math.sin(I2 * Math.PI / 2) + f3, j2 = 0, k2 = C2.length; j2 < k2; j2++)
                K2((B2 = O2(C2[j2], V2[j2], N2)).x, B2.y, c3 + z2);
              for (S3 = 0, T3 = R2.length; S3 < T3; S3++)
                for (M3 = R2[S3], X2 = J2[S3], j2 = 0, k2 = M3.length; j2 < k2; j2++)
                  B2 = O2(M3[j2], X2[j2], N2), E4 ? K2(B2.x, B2.y + y3[s5 - 1].y, y3[s5 - 1].x + z2) : K2(B2.x, B2.y, c3 + z2);
            }
            function Q2(t5, e5) {
              var r4, n3;
              for (j2 = t5.length; --j2 >= 0; ) {
                r4 = j2, (n3 = j2 - 1) < 0 && (n3 = t5.length - 1);
                var i4 = 0, a5 = s5 + 2 * m3;
                for (i4 = 0; i4 < a5; i4++) {
                  var o7 = G2 * i4, c4 = G2 * (i4 + 1);
                  tt2(e5 + r4 + o7, e5 + n3 + o7, e5 + n3 + c4, e5 + r4 + c4);
                }
              }
            }
            function K2(t5, e5, r4) {
              a4.push(t5), a4.push(e5), a4.push(r4);
            }
            function $2(t5, e5, i4) {
              et2(t5), et2(e5), et2(i4);
              var a5 = n2.length / 3, o7 = v3.generateTopUV(r3, n2, a5 - 3, a5 - 2, a5 - 1);
              rt2(o7[0]), rt2(o7[1]), rt2(o7[2]);
            }
            function tt2(t5, e5, i4, a5) {
              et2(t5), et2(e5), et2(a5), et2(e5), et2(i4), et2(a5);
              var o7 = n2.length / 3, s6 = v3.generateSideWallUV(r3, n2, o7 - 6, o7 - 3, o7 - 2, o7 - 1);
              rt2(s6[0]), rt2(s6[1]), rt2(s6[3]), rt2(s6[1]), rt2(s6[2]), rt2(s6[3]);
            }
            function et2(t5) {
              n2.push(a4[3 * t5 + 0]), n2.push(a4[3 * t5 + 1]), n2.push(a4[3 * t5 + 2]);
            }
            function rt2(t5) {
              i3.push(t5.x), i3.push(t5.y);
            }
            !function() {
              var t5 = n2.length / 3;
              if (h3) {
                var e5 = 0, i4 = G2 * e5;
                for (j2 = 0; j2 < U2; j2++)
                  $2((F2 = P3[j2])[2] + i4, F2[1] + i4, F2[0] + i4);
                for (i4 = G2 * (e5 = s5 + 2 * m3), j2 = 0; j2 < U2; j2++)
                  $2((F2 = P3[j2])[0] + i4, F2[1] + i4, F2[2] + i4);
              } else {
                for (j2 = 0; j2 < U2; j2++)
                  $2((F2 = P3[j2])[2], F2[1], F2[0]);
                for (j2 = 0; j2 < U2; j2++)
                  $2((F2 = P3[j2])[0] + G2 * s5, F2[1] + G2 * s5, F2[2] + G2 * s5);
              }
              r3.addGroup(t5, n2.length / 3 - t5, 0);
            }(), function() {
              var t5 = n2.length / 3, e5 = 0;
              for (Q2(C2, e5), e5 += C2.length, S3 = 0, T3 = R2.length; S3 < T3; S3++)
                Q2(M3 = R2[S3], e5), e5 += M3.length;
              r3.addGroup(t5, n2.length / 3 - t5, 1);
            }();
          }
          this.addAttribute("position", new Zt(n2, 3)), this.addAttribute("uv", new Zt(i3, 2)), this.computeVertexNormals();
        }
        Ba.prototype = Object.create(Oe.prototype), Ba.prototype.constructor = Ba, Ba.prototype.toJSON = function() {
          var t3 = Oe.prototype.toJSON.call(this);
          return Ua(this.parameters.shapes, this.parameters.options, t3);
        }, Fa.prototype = Object.create(se.prototype), Fa.prototype.constructor = Fa, Fa.prototype.toJSON = function() {
          var t3 = se.prototype.toJSON.call(this);
          return Ua(this.parameters.shapes, this.parameters.options, t3);
        };
        var Ga = { generateTopUV: function(t3, e4, r3, n2, i3) {
          var a3 = e4[3 * r3], o5 = e4[3 * r3 + 1], s4 = e4[3 * n2], c3 = e4[3 * n2 + 1], h3 = e4[3 * i3], u3 = e4[3 * i3 + 1];
          return [new l3(a3, o5), new l3(s4, c3), new l3(h3, u3)];
        }, generateSideWallUV: function(t3, e4, r3, n2, i3, a3) {
          var o5 = e4[3 * r3], s4 = e4[3 * r3 + 1], c3 = e4[3 * r3 + 2], h3 = e4[3 * n2], u3 = e4[3 * n2 + 1], p3 = e4[3 * n2 + 2], d3 = e4[3 * i3], f3 = e4[3 * i3 + 1], m3 = e4[3 * i3 + 2], g3 = e4[3 * a3], v3 = e4[3 * a3 + 1], y3 = e4[3 * a3 + 2];
          return Math.abs(s4 - u3) < 0.01 ? [new l3(o5, 1 - c3), new l3(h3, 1 - p3), new l3(d3, 1 - m3), new l3(g3, 1 - y3)] : [new l3(s4, 1 - c3), new l3(u3, 1 - p3), new l3(f3, 1 - m3), new l3(v3, 1 - y3)];
        } };
        function Ua(t3, e4, r3) {
          if (r3.shapes = [], Array.isArray(t3))
            for (var n2 = 0, i3 = t3.length; n2 < i3; n2++) {
              var a3 = t3[n2];
              r3.shapes.push(a3.uuid);
            }
          else
            r3.shapes.push(t3.uuid);
          return e4.extrudePath !== void 0 && (r3.options.extrudePath = e4.extrudePath.toJSON()), r3;
        }
        function Ha(t3, e4) {
          Oe.call(this), this.type = "TextGeometry", this.parameters = { text: t3, parameters: e4 }, this.fromBufferGeometry(new Va(t3, e4)), this.mergeVertices();
        }
        function Va(t3, e4) {
          var r3 = (e4 = e4 || {}).font;
          if (!r3 || !r3.isFont)
            return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Oe();
          var n2 = r3.generateShapes(t3, e4.size);
          e4.depth = e4.height !== void 0 ? e4.height : 50, e4.bevelThickness === void 0 && (e4.bevelThickness = 10), e4.bevelSize === void 0 && (e4.bevelSize = 8), e4.bevelEnabled === void 0 && (e4.bevelEnabled = false), Fa.call(this, n2, e4), this.type = "TextBufferGeometry";
        }
        function ja(t3, e4, r3, n2, i3, a3, o5) {
          Oe.call(this), this.type = "SphereGeometry", this.parameters = { radius: t3, widthSegments: e4, heightSegments: r3, phiStart: n2, phiLength: i3, thetaStart: a3, thetaLength: o5 }, this.fromBufferGeometry(new ka(t3, e4, r3, n2, i3, a3, o5)), this.mergeVertices();
        }
        function ka(t3, e4, r3, n2, i3, a3, o5) {
          se.call(this), this.type = "SphereBufferGeometry", this.parameters = { radius: t3, widthSegments: e4, heightSegments: r3, phiStart: n2, phiLength: i3, thetaStart: a3, thetaLength: o5 }, t3 = t3 || 1, e4 = Math.max(3, Math.floor(e4) || 8), r3 = Math.max(2, Math.floor(r3) || 6), n2 = n2 !== void 0 ? n2 : 0, i3 = i3 !== void 0 ? i3 : 2 * Math.PI, a3 = a3 !== void 0 ? a3 : 0, o5 = o5 !== void 0 ? o5 : Math.PI;
          var s4, c3, l4 = Math.min(a3 + o5, Math.PI), h3 = 0, u3 = [], p3 = new d2(), f3 = new d2(), m3 = [], g3 = [], v3 = [], y3 = [];
          for (c3 = 0; c3 <= r3; c3++) {
            var x3 = [], b3 = c3 / r3, w3 = 0;
            for (c3 == 0 && a3 == 0 ? w3 = 0.5 / e4 : c3 == r3 && l4 == Math.PI && (w3 = -0.5 / e4), s4 = 0; s4 <= e4; s4++) {
              var _3 = s4 / e4;
              p3.x = -t3 * Math.cos(n2 + _3 * i3) * Math.sin(a3 + b3 * o5), p3.y = t3 * Math.cos(a3 + b3 * o5), p3.z = t3 * Math.sin(n2 + _3 * i3) * Math.sin(a3 + b3 * o5), g3.push(p3.x, p3.y, p3.z), f3.copy(p3).normalize(), v3.push(f3.x, f3.y, f3.z), y3.push(_3 + w3, 1 - b3), x3.push(h3++);
            }
            u3.push(x3);
          }
          for (c3 = 0; c3 < r3; c3++)
            for (s4 = 0; s4 < e4; s4++) {
              var M3 = u3[c3][s4 + 1], S3 = u3[c3][s4], T3 = u3[c3 + 1][s4], E4 = u3[c3 + 1][s4 + 1];
              (c3 !== 0 || a3 > 0) && m3.push(M3, S3, E4), (c3 !== r3 - 1 || l4 < Math.PI) && m3.push(S3, T3, E4);
            }
          this.setIndex(m3), this.addAttribute("position", new Zt(g3, 3)), this.addAttribute("normal", new Zt(v3, 3)), this.addAttribute("uv", new Zt(y3, 2));
        }
        function Wa(t3, e4, r3, n2, i3, a3) {
          Oe.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: t3, outerRadius: e4, thetaSegments: r3, phiSegments: n2, thetaStart: i3, thetaLength: a3 }, this.fromBufferGeometry(new qa(t3, e4, r3, n2, i3, a3)), this.mergeVertices();
        }
        function qa(t3, e4, r3, n2, i3, a3) {
          se.call(this), this.type = "RingBufferGeometry", this.parameters = { innerRadius: t3, outerRadius: e4, thetaSegments: r3, phiSegments: n2, thetaStart: i3, thetaLength: a3 }, t3 = t3 || 0.5, e4 = e4 || 1, i3 = i3 !== void 0 ? i3 : 0, a3 = a3 !== void 0 ? a3 : 2 * Math.PI, r3 = r3 !== void 0 ? Math.max(3, r3) : 8;
          var o5, s4, c3, h3 = [], u3 = [], p3 = [], f3 = [], m3 = t3, g3 = (e4 - t3) / (n2 = n2 !== void 0 ? Math.max(1, n2) : 1), v3 = new d2(), y3 = new l3();
          for (s4 = 0; s4 <= n2; s4++) {
            for (c3 = 0; c3 <= r3; c3++)
              o5 = i3 + c3 / r3 * a3, v3.x = m3 * Math.cos(o5), v3.y = m3 * Math.sin(o5), u3.push(v3.x, v3.y, v3.z), p3.push(0, 0, 1), y3.x = (v3.x / e4 + 1) / 2, y3.y = (v3.y / e4 + 1) / 2, f3.push(y3.x, y3.y);
            m3 += g3;
          }
          for (s4 = 0; s4 < n2; s4++) {
            var x3 = s4 * (r3 + 1);
            for (c3 = 0; c3 < r3; c3++) {
              var b3 = o5 = c3 + x3, w3 = o5 + r3 + 1, _3 = o5 + r3 + 2, M3 = o5 + 1;
              h3.push(b3, w3, M3), h3.push(w3, _3, M3);
            }
          }
          this.setIndex(h3), this.addAttribute("position", new Zt(u3, 3)), this.addAttribute("normal", new Zt(p3, 3)), this.addAttribute("uv", new Zt(f3, 2));
        }
        function Xa(t3, e4, r3, n2) {
          Oe.call(this), this.type = "LatheGeometry", this.parameters = { points: t3, segments: e4, phiStart: r3, phiLength: n2 }, this.fromBufferGeometry(new Ya(t3, e4, r3, n2)), this.mergeVertices();
        }
        function Ya(t3, e4, r3, n2) {
          se.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: t3, segments: e4, phiStart: r3, phiLength: n2 }, e4 = Math.floor(e4) || 12, r3 = r3 || 0, n2 = n2 || 2 * Math.PI, n2 = s3.clamp(n2, 0, 2 * Math.PI);
          var i3, a3, o5, c3 = [], h3 = [], u3 = [], p3 = 1 / e4, f3 = new d2(), m3 = new l3();
          for (a3 = 0; a3 <= e4; a3++) {
            var g3 = r3 + a3 * p3 * n2, v3 = Math.sin(g3), y3 = Math.cos(g3);
            for (o5 = 0; o5 <= t3.length - 1; o5++)
              f3.x = t3[o5].x * v3, f3.y = t3[o5].y, f3.z = t3[o5].x * y3, h3.push(f3.x, f3.y, f3.z), m3.x = a3 / e4, m3.y = o5 / (t3.length - 1), u3.push(m3.x, m3.y);
          }
          for (a3 = 0; a3 < e4; a3++)
            for (o5 = 0; o5 < t3.length - 1; o5++) {
              var x3 = i3 = o5 + a3 * t3.length, b3 = i3 + t3.length, w3 = i3 + t3.length + 1, _3 = i3 + 1;
              c3.push(x3, b3, _3), c3.push(b3, w3, _3);
            }
          if (this.setIndex(c3), this.addAttribute("position", new Zt(h3, 3)), this.addAttribute("uv", new Zt(u3, 2)), this.computeVertexNormals(), n2 === 2 * Math.PI) {
            var M3 = this.attributes.normal.array, S3 = new d2(), T3 = new d2(), E4 = new d2();
            for (i3 = e4 * t3.length * 3, a3 = 0, o5 = 0; a3 < t3.length; a3++, o5 += 3)
              S3.x = M3[o5 + 0], S3.y = M3[o5 + 1], S3.z = M3[o5 + 2], T3.x = M3[i3 + o5 + 0], T3.y = M3[i3 + o5 + 1], T3.z = M3[i3 + o5 + 2], E4.addVectors(S3, T3).normalize(), M3[o5 + 0] = M3[i3 + o5 + 0] = E4.x, M3[o5 + 1] = M3[i3 + o5 + 1] = E4.y, M3[o5 + 2] = M3[i3 + o5 + 2] = E4.z;
          }
        }
        function Ja(t3, e4) {
          Oe.call(this), this.type = "ShapeGeometry", R(e4) === "object" && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e4 = e4.curveSegments), this.parameters = { shapes: t3, curveSegments: e4 }, this.fromBufferGeometry(new Za(t3, e4)), this.mergeVertices();
        }
        function Za(t3, e4) {
          se.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: t3, curveSegments: e4 }, e4 = e4 || 12;
          var r3 = [], n2 = [], i3 = [], a3 = [], o5 = 0, s4 = 0;
          if (Array.isArray(t3) === false)
            l4(t3);
          else
            for (var c3 = 0; c3 < t3.length; c3++)
              l4(t3[c3]), this.addGroup(o5, s4, c3), o5 += s4, s4 = 0;
          function l4(t4) {
            var o6, c4, l5, h3 = n2.length / 3, u3 = t4.extractPoints(e4), p3 = u3.shape, d3 = u3.holes;
            for (Na.isClockWise(p3) === false && (p3 = p3.reverse()), o6 = 0, c4 = d3.length; o6 < c4; o6++)
              l5 = d3[o6], Na.isClockWise(l5) === true && (d3[o6] = l5.reverse());
            var f3 = Na.triangulateShape(p3, d3);
            for (o6 = 0, c4 = d3.length; o6 < c4; o6++)
              l5 = d3[o6], p3 = p3.concat(l5);
            for (o6 = 0, c4 = p3.length; o6 < c4; o6++) {
              var m3 = p3[o6];
              n2.push(m3.x, m3.y, 0), i3.push(0, 0, 1), a3.push(m3.x, m3.y);
            }
            for (o6 = 0, c4 = f3.length; o6 < c4; o6++) {
              var g3 = f3[o6], v3 = g3[0] + h3, y3 = g3[1] + h3, x3 = g3[2] + h3;
              r3.push(v3, y3, x3), s4 += 3;
            }
          }
          this.setIndex(r3), this.addAttribute("position", new Zt(n2, 3)), this.addAttribute("normal", new Zt(i3, 3)), this.addAttribute("uv", new Zt(a3, 2));
        }
        function Qa(t3, e4) {
          if (e4.shapes = [], Array.isArray(t3))
            for (var r3 = 0, n2 = t3.length; r3 < n2; r3++) {
              var i3 = t3[r3];
              e4.shapes.push(i3.uuid);
            }
          else
            e4.shapes.push(t3.uuid);
          return e4;
        }
        function Ka(t3, e4) {
          se.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e4 }, e4 = e4 !== void 0 ? e4 : 1;
          var r3, n2, i3, a3, o5 = [], c3 = Math.cos(s3.DEG2RAD * e4), l4 = [0, 0], h3 = {}, u3 = ["a", "b", "c"];
          t3.isBufferGeometry ? (a3 = new Oe()).fromBufferGeometry(t3) : a3 = t3.clone(), a3.mergeVertices(), a3.computeFaceNormals();
          for (var p3 = a3.vertices, d3 = a3.faces, f3 = 0, m3 = d3.length; f3 < m3; f3++)
            for (var g3 = d3[f3], v3 = 0; v3 < 3; v3++)
              r3 = g3[u3[v3]], n2 = g3[u3[(v3 + 1) % 3]], l4[0] = Math.min(r3, n2), l4[1] = Math.max(r3, n2), h3[i3 = l4[0] + "," + l4[1]] === void 0 ? h3[i3] = { index1: l4[0], index2: l4[1], face1: f3, face2: void 0 } : h3[i3].face2 = f3;
          for (i3 in h3) {
            var y3 = h3[i3];
            if (y3.face2 === void 0 || d3[y3.face1].normal.dot(d3[y3.face2].normal) <= c3) {
              var x3 = p3[y3.index1];
              o5.push(x3.x, x3.y, x3.z), x3 = p3[y3.index2], o5.push(x3.x, x3.y, x3.z);
            }
          }
          this.addAttribute("position", new Zt(o5, 3));
        }
        function $a(t3, e4, r3, n2, i3, a3, o5, s4) {
          Oe.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: t3, radiusBottom: e4, height: r3, radialSegments: n2, heightSegments: i3, openEnded: a3, thetaStart: o5, thetaLength: s4 }, this.fromBufferGeometry(new to(t3, e4, r3, n2, i3, a3, o5, s4)), this.mergeVertices();
        }
        function to(t3, e4, r3, n2, i3, a3, o5, s4) {
          se.call(this), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: t3, radiusBottom: e4, height: r3, radialSegments: n2, heightSegments: i3, openEnded: a3, thetaStart: o5, thetaLength: s4 };
          var c3 = this;
          t3 = t3 !== void 0 ? t3 : 1, e4 = e4 !== void 0 ? e4 : 1, r3 = r3 || 1, n2 = Math.floor(n2) || 8, i3 = Math.floor(i3) || 1, a3 = a3 !== void 0 && a3, o5 = o5 !== void 0 ? o5 : 0, s4 = s4 !== void 0 ? s4 : 2 * Math.PI;
          var h3 = [], u3 = [], p3 = [], f3 = [], m3 = 0, g3 = [], v3 = r3 / 2, y3 = 0;
          function x3(r4) {
            var i4, a4, g4, x4 = new l3(), b3 = new d2(), w3 = 0, _3 = r4 === true ? t3 : e4, M3 = r4 === true ? 1 : -1;
            for (a4 = m3, i4 = 1; i4 <= n2; i4++)
              u3.push(0, v3 * M3, 0), p3.push(0, M3, 0), f3.push(0.5, 0.5), m3++;
            for (g4 = m3, i4 = 0; i4 <= n2; i4++) {
              var S3 = i4 / n2 * s4 + o5, T3 = Math.cos(S3), E4 = Math.sin(S3);
              b3.x = _3 * E4, b3.y = v3 * M3, b3.z = _3 * T3, u3.push(b3.x, b3.y, b3.z), p3.push(0, M3, 0), x4.x = 0.5 * T3 + 0.5, x4.y = 0.5 * E4 * M3 + 0.5, f3.push(x4.x, x4.y), m3++;
            }
            for (i4 = 0; i4 < n2; i4++) {
              var A3 = a4 + i4, L3 = g4 + i4;
              r4 === true ? h3.push(L3, L3 + 1, A3) : h3.push(L3 + 1, L3, A3), w3 += 3;
            }
            c3.addGroup(y3, w3, r4 === true ? 1 : 2), y3 += w3;
          }
          !function() {
            var a4, l4, x4 = new d2(), b3 = new d2(), w3 = 0, _3 = (e4 - t3) / r3;
            for (l4 = 0; l4 <= i3; l4++) {
              var M3 = [], S3 = l4 / i3, T3 = S3 * (e4 - t3) + t3;
              for (a4 = 0; a4 <= n2; a4++) {
                var E4 = a4 / n2, A3 = E4 * s4 + o5, L3 = Math.sin(A3), R2 = Math.cos(A3);
                b3.x = T3 * L3, b3.y = -S3 * r3 + v3, b3.z = T3 * R2, u3.push(b3.x, b3.y, b3.z), x4.set(L3, _3, R2).normalize(), p3.push(x4.x, x4.y, x4.z), f3.push(E4, 1 - S3), M3.push(m3++);
              }
              g3.push(M3);
            }
            for (a4 = 0; a4 < n2; a4++)
              for (l4 = 0; l4 < i3; l4++) {
                var P3 = g3[l4][a4], C2 = g3[l4 + 1][a4], O2 = g3[l4 + 1][a4 + 1], D2 = g3[l4][a4 + 1];
                h3.push(P3, C2, D2), h3.push(C2, O2, D2), w3 += 6;
              }
            c3.addGroup(y3, w3, 0), y3 += w3;
          }(), a3 === false && (t3 > 0 && x3(true), e4 > 0 && x3(false)), this.setIndex(h3), this.addAttribute("position", new Zt(u3, 3)), this.addAttribute("normal", new Zt(p3, 3)), this.addAttribute("uv", new Zt(f3, 2));
        }
        function eo(t3, e4, r3, n2, i3, a3, o5) {
          $a.call(this, 0, t3, e4, r3, n2, i3, a3, o5), this.type = "ConeGeometry", this.parameters = { radius: t3, height: e4, radialSegments: r3, heightSegments: n2, openEnded: i3, thetaStart: a3, thetaLength: o5 };
        }
        function ro(t3, e4, r3, n2, i3, a3, o5) {
          to.call(this, 0, t3, e4, r3, n2, i3, a3, o5), this.type = "ConeBufferGeometry", this.parameters = { radius: t3, height: e4, radialSegments: r3, heightSegments: n2, openEnded: i3, thetaStart: a3, thetaLength: o5 };
        }
        function no(t3, e4, r3, n2) {
          Oe.call(this), this.type = "CircleGeometry", this.parameters = { radius: t3, segments: e4, thetaStart: r3, thetaLength: n2 }, this.fromBufferGeometry(new io(t3, e4, r3, n2)), this.mergeVertices();
        }
        function io(t3, e4, r3, n2) {
          se.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: t3, segments: e4, thetaStart: r3, thetaLength: n2 }, t3 = t3 || 1, e4 = e4 !== void 0 ? Math.max(3, e4) : 8, r3 = r3 !== void 0 ? r3 : 0, n2 = n2 !== void 0 ? n2 : 2 * Math.PI;
          var i3, a3, o5 = [], s4 = [], c3 = [], h3 = [], u3 = new d2(), p3 = new l3();
          for (s4.push(0, 0, 0), c3.push(0, 0, 1), h3.push(0.5, 0.5), a3 = 0, i3 = 3; a3 <= e4; a3++, i3 += 3) {
            var f3 = r3 + a3 / e4 * n2;
            u3.x = t3 * Math.cos(f3), u3.y = t3 * Math.sin(f3), s4.push(u3.x, u3.y, u3.z), c3.push(0, 0, 1), p3.x = (s4[i3] / t3 + 1) / 2, p3.y = (s4[i3 + 1] / t3 + 1) / 2, h3.push(p3.x, p3.y);
          }
          for (i3 = 1; i3 <= e4; i3++)
            o5.push(i3, i3 + 1, 0);
          this.setIndex(o5), this.addAttribute("position", new Zt(s4, 3)), this.addAttribute("normal", new Zt(c3, 3)), this.addAttribute("uv", new Zt(h3, 2));
        }
        Ha.prototype = Object.create(Oe.prototype), Ha.prototype.constructor = Ha, Va.prototype = Object.create(Fa.prototype), Va.prototype.constructor = Va, ja.prototype = Object.create(Oe.prototype), ja.prototype.constructor = ja, ka.prototype = Object.create(se.prototype), ka.prototype.constructor = ka, Wa.prototype = Object.create(Oe.prototype), Wa.prototype.constructor = Wa, qa.prototype = Object.create(se.prototype), qa.prototype.constructor = qa, Xa.prototype = Object.create(Oe.prototype), Xa.prototype.constructor = Xa, Ya.prototype = Object.create(se.prototype), Ya.prototype.constructor = Ya, Ja.prototype = Object.create(Oe.prototype), Ja.prototype.constructor = Ja, Ja.prototype.toJSON = function() {
          var t3 = Oe.prototype.toJSON.call(this);
          return Qa(this.parameters.shapes, t3);
        }, Za.prototype = Object.create(se.prototype), Za.prototype.constructor = Za, Za.prototype.toJSON = function() {
          var t3 = se.prototype.toJSON.call(this);
          return Qa(this.parameters.shapes, t3);
        }, Ka.prototype = Object.create(se.prototype), Ka.prototype.constructor = Ka, $a.prototype = Object.create(Oe.prototype), $a.prototype.constructor = $a, to.prototype = Object.create(se.prototype), to.prototype.constructor = to, eo.prototype = Object.create($a.prototype), eo.prototype.constructor = eo, ro.prototype = Object.create(to.prototype), ro.prototype.constructor = ro, no.prototype = Object.create(Oe.prototype), no.prototype.constructor = no, io.prototype = Object.create(se.prototype), io.prototype.constructor = io;
        var ao = Object.freeze({ WireframeGeometry: Xi, ParametricGeometry: Yi, ParametricBufferGeometry: Ji, TetrahedronGeometry: Ki, TetrahedronBufferGeometry: $i, OctahedronGeometry: ta, OctahedronBufferGeometry: ea, IcosahedronGeometry: ra, IcosahedronBufferGeometry: na, DodecahedronGeometry: ia, DodecahedronBufferGeometry: aa, PolyhedronGeometry: Zi, PolyhedronBufferGeometry: Qi, TubeGeometry: oa, TubeBufferGeometry: sa, TorusKnotGeometry: ca, TorusKnotBufferGeometry: la, TorusGeometry: ha, TorusBufferGeometry: ua, TextGeometry: Ha, TextBufferGeometry: Va, SphereGeometry: ja, SphereBufferGeometry: ka, RingGeometry: Wa, RingBufferGeometry: qa, PlaneGeometry: rr, PlaneBufferGeometry: nr, LatheGeometry: Xa, LatheBufferGeometry: Ya, ShapeGeometry: Ja, ShapeBufferGeometry: Za, ExtrudeGeometry: Ba, ExtrudeBufferGeometry: Fa, EdgesGeometry: Ka, ConeGeometry: eo, ConeBufferGeometry: ro, CylinderGeometry: $a, CylinderBufferGeometry: to, CircleGeometry: no, CircleBufferGeometry: io, BoxGeometry: De, BoxBufferGeometry: Ne });
        function oo(t3) {
          Ut.call(this), this.type = "ShadowMaterial", this.color = new Nt(0), this.transparent = true, this.setValues(t3);
        }
        function so(t3) {
          Fe.call(this, t3), this.type = "RawShaderMaterial";
        }
        function co(t3) {
          Ut.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Nt(16777215), this.roughness = 0.5, this.metalness = 0.5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Nt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new l3(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.setValues(t3);
        }
        function lo(t3) {
          co.call(this), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = 0.5, this.clearcoat = 0, this.clearcoatRoughness = 0, this.sheen = null, this.clearcoatNormalScale = new l3(1, 1), this.clearcoatNormalMap = null, this.transparency = 0, this.setValues(t3);
        }
        function ho(t3) {
          Ut.call(this), this.type = "MeshPhongMaterial", this.color = new Nt(16777215), this.specular = new Nt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Nt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new l3(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.setValues(t3);
        }
        function uo(t3) {
          ho.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t3);
        }
        function po(t3) {
          Ut.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new l3(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.setValues(t3);
        }
        function fo(t3) {
          Ut.call(this), this.type = "MeshLambertMaterial", this.color = new Nt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Nt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.setValues(t3);
        }
        function mo(t3) {
          Ut.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Nt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new l3(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.lights = false, this.setValues(t3);
        }
        function go(t3) {
          Ti.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t3);
        }
        oo.prototype = Object.create(Ut.prototype), oo.prototype.constructor = oo, oo.prototype.isShadowMaterial = true, oo.prototype.copy = function(t3) {
          return Ut.prototype.copy.call(this, t3), this.color.copy(t3.color), this;
        }, so.prototype = Object.create(Fe.prototype), so.prototype.constructor = so, so.prototype.isRawShaderMaterial = true, co.prototype = Object.create(Ut.prototype), co.prototype.constructor = co, co.prototype.isMeshStandardMaterial = true, co.prototype.copy = function(t3) {
          return Ut.prototype.copy.call(this, t3), this.defines = { STANDARD: "" }, this.color.copy(t3.color), this.roughness = t3.roughness, this.metalness = t3.metalness, this.map = t3.map, this.lightMap = t3.lightMap, this.lightMapIntensity = t3.lightMapIntensity, this.aoMap = t3.aoMap, this.aoMapIntensity = t3.aoMapIntensity, this.emissive.copy(t3.emissive), this.emissiveMap = t3.emissiveMap, this.emissiveIntensity = t3.emissiveIntensity, this.bumpMap = t3.bumpMap, this.bumpScale = t3.bumpScale, this.normalMap = t3.normalMap, this.normalMapType = t3.normalMapType, this.normalScale.copy(t3.normalScale), this.displacementMap = t3.displacementMap, this.displacementScale = t3.displacementScale, this.displacementBias = t3.displacementBias, this.roughnessMap = t3.roughnessMap, this.metalnessMap = t3.metalnessMap, this.alphaMap = t3.alphaMap, this.envMap = t3.envMap, this.envMapIntensity = t3.envMapIntensity, this.refractionRatio = t3.refractionRatio, this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this.wireframeLinecap = t3.wireframeLinecap, this.wireframeLinejoin = t3.wireframeLinejoin, this.skinning = t3.skinning, this.morphTargets = t3.morphTargets, this.morphNormals = t3.morphNormals, this;
        }, lo.prototype = Object.create(co.prototype), lo.prototype.constructor = lo, lo.prototype.isMeshPhysicalMaterial = true, lo.prototype.copy = function(t3) {
          return co.prototype.copy.call(this, t3), this.defines = { STANDARD: "", PHYSICAL: "" }, this.reflectivity = t3.reflectivity, this.clearcoat = t3.clearcoat, this.clearcoatRoughness = t3.clearcoatRoughness, t3.sheen ? this.sheen = (this.sheen || new Nt()).copy(t3.sheen) : this.sheen = null, this.clearcoatNormalMap = t3.clearcoatNormalMap, this.clearcoatNormalScale.copy(t3.clearcoatNormalScale), this.transparency = t3.transparency, this;
        }, ho.prototype = Object.create(Ut.prototype), ho.prototype.constructor = ho, ho.prototype.isMeshPhongMaterial = true, ho.prototype.copy = function(t3) {
          return Ut.prototype.copy.call(this, t3), this.color.copy(t3.color), this.specular.copy(t3.specular), this.shininess = t3.shininess, this.map = t3.map, this.lightMap = t3.lightMap, this.lightMapIntensity = t3.lightMapIntensity, this.aoMap = t3.aoMap, this.aoMapIntensity = t3.aoMapIntensity, this.emissive.copy(t3.emissive), this.emissiveMap = t3.emissiveMap, this.emissiveIntensity = t3.emissiveIntensity, this.bumpMap = t3.bumpMap, this.bumpScale = t3.bumpScale, this.normalMap = t3.normalMap, this.normalMapType = t3.normalMapType, this.normalScale.copy(t3.normalScale), this.displacementMap = t3.displacementMap, this.displacementScale = t3.displacementScale, this.displacementBias = t3.displacementBias, this.specularMap = t3.specularMap, this.alphaMap = t3.alphaMap, this.envMap = t3.envMap, this.combine = t3.combine, this.reflectivity = t3.reflectivity, this.refractionRatio = t3.refractionRatio, this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this.wireframeLinecap = t3.wireframeLinecap, this.wireframeLinejoin = t3.wireframeLinejoin, this.skinning = t3.skinning, this.morphTargets = t3.morphTargets, this.morphNormals = t3.morphNormals, this;
        }, uo.prototype = Object.create(ho.prototype), uo.prototype.constructor = uo, uo.prototype.isMeshToonMaterial = true, uo.prototype.copy = function(t3) {
          return ho.prototype.copy.call(this, t3), this.gradientMap = t3.gradientMap, this;
        }, po.prototype = Object.create(Ut.prototype), po.prototype.constructor = po, po.prototype.isMeshNormalMaterial = true, po.prototype.copy = function(t3) {
          return Ut.prototype.copy.call(this, t3), this.bumpMap = t3.bumpMap, this.bumpScale = t3.bumpScale, this.normalMap = t3.normalMap, this.normalMapType = t3.normalMapType, this.normalScale.copy(t3.normalScale), this.displacementMap = t3.displacementMap, this.displacementScale = t3.displacementScale, this.displacementBias = t3.displacementBias, this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this.skinning = t3.skinning, this.morphTargets = t3.morphTargets, this.morphNormals = t3.morphNormals, this;
        }, fo.prototype = Object.create(Ut.prototype), fo.prototype.constructor = fo, fo.prototype.isMeshLambertMaterial = true, fo.prototype.copy = function(t3) {
          return Ut.prototype.copy.call(this, t3), this.color.copy(t3.color), this.map = t3.map, this.lightMap = t3.lightMap, this.lightMapIntensity = t3.lightMapIntensity, this.aoMap = t3.aoMap, this.aoMapIntensity = t3.aoMapIntensity, this.emissive.copy(t3.emissive), this.emissiveMap = t3.emissiveMap, this.emissiveIntensity = t3.emissiveIntensity, this.specularMap = t3.specularMap, this.alphaMap = t3.alphaMap, this.envMap = t3.envMap, this.combine = t3.combine, this.reflectivity = t3.reflectivity, this.refractionRatio = t3.refractionRatio, this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this.wireframeLinecap = t3.wireframeLinecap, this.wireframeLinejoin = t3.wireframeLinejoin, this.skinning = t3.skinning, this.morphTargets = t3.morphTargets, this.morphNormals = t3.morphNormals, this;
        }, mo.prototype = Object.create(Ut.prototype), mo.prototype.constructor = mo, mo.prototype.isMeshMatcapMaterial = true, mo.prototype.copy = function(t3) {
          return Ut.prototype.copy.call(this, t3), this.defines = { MATCAP: "" }, this.color.copy(t3.color), this.matcap = t3.matcap, this.map = t3.map, this.bumpMap = t3.bumpMap, this.bumpScale = t3.bumpScale, this.normalMap = t3.normalMap, this.normalMapType = t3.normalMapType, this.normalScale.copy(t3.normalScale), this.displacementMap = t3.displacementMap, this.displacementScale = t3.displacementScale, this.displacementBias = t3.displacementBias, this.alphaMap = t3.alphaMap, this.skinning = t3.skinning, this.morphTargets = t3.morphTargets, this.morphNormals = t3.morphNormals, this;
        }, go.prototype = Object.create(Ti.prototype), go.prototype.constructor = go, go.prototype.isLineDashedMaterial = true, go.prototype.copy = function(t3) {
          return Ti.prototype.copy.call(this, t3), this.scale = t3.scale, this.dashSize = t3.dashSize, this.gapSize = t3.gapSize, this;
        };
        var vo = Object.freeze({ ShadowMaterial: oo, SpriteMaterial: ri, RawShaderMaterial: so, ShaderMaterial: Fe, PointsMaterial: zi, MeshPhysicalMaterial: lo, MeshStandardMaterial: co, MeshPhongMaterial: ho, MeshToonMaterial: uo, MeshNormalMaterial: po, MeshLambertMaterial: fo, MeshDepthMaterial: Bn, MeshDistanceMaterial: Fn, MeshBasicMaterial: Ht, MeshMatcapMaterial: mo, LineDashedMaterial: go, LineBasicMaterial: Ti, Material: Ut }), yo = { arraySlice: function(t3, e4, r3) {
          return yo.isTypedArray(t3) ? new t3.constructor(t3.subarray(e4, r3 !== void 0 ? r3 : t3.length)) : t3.slice(e4, r3);
        }, convertArray: function(t3, e4, r3) {
          return !t3 || !r3 && t3.constructor === e4 ? t3 : typeof e4.BYTES_PER_ELEMENT == "number" ? new e4(t3) : Array.prototype.slice.call(t3);
        }, isTypedArray: function(t3) {
          return ArrayBuffer.isView(t3) && !(t3 instanceof DataView);
        }, getKeyframeOrder: function(t3) {
          for (var e4 = t3.length, r3 = new Array(e4), n2 = 0; n2 !== e4; ++n2)
            r3[n2] = n2;
          return r3.sort(function(e5, r4) {
            return t3[e5] - t3[r4];
          }), r3;
        }, sortedArray: function(t3, e4, r3) {
          for (var n2 = t3.length, i3 = new t3.constructor(n2), a3 = 0, o5 = 0; o5 !== n2; ++a3)
            for (var s4 = r3[a3] * e4, c3 = 0; c3 !== e4; ++c3)
              i3[o5++] = t3[s4 + c3];
          return i3;
        }, flattenJSON: function(t3, e4, r3, n2) {
          for (var i3 = 1, a3 = t3[0]; a3 !== void 0 && a3[n2] === void 0; )
            a3 = t3[i3++];
          if (a3 !== void 0) {
            var o5 = a3[n2];
            if (o5 !== void 0)
              if (Array.isArray(o5))
                do {
                  (o5 = a3[n2]) !== void 0 && (e4.push(a3.time), r3.push.apply(r3, o5)), a3 = t3[i3++];
                } while (a3 !== void 0);
              else if (o5.toArray !== void 0)
                do {
                  (o5 = a3[n2]) !== void 0 && (e4.push(a3.time), o5.toArray(r3, r3.length)), a3 = t3[i3++];
                } while (a3 !== void 0);
              else
                do {
                  (o5 = a3[n2]) !== void 0 && (e4.push(a3.time), r3.push(o5)), a3 = t3[i3++];
                } while (a3 !== void 0);
          }
        } };
        function xo(t3, e4, r3, n2) {
          this.parameterPositions = t3, this._cachedIndex = 0, this.resultBuffer = n2 !== void 0 ? n2 : new e4.constructor(r3), this.sampleValues = e4, this.valueSize = r3;
        }
        function bo(t3, e4, r3, n2) {
          xo.call(this, t3, e4, r3, n2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
        }
        function wo(t3, e4, r3, n2) {
          xo.call(this, t3, e4, r3, n2);
        }
        function _o(t3, e4, r3, n2) {
          xo.call(this, t3, e4, r3, n2);
        }
        function Mo(t3, e4, r3, n2) {
          if (t3 === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (e4 === void 0 || e4.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t3);
          this.name = t3, this.times = yo.convertArray(e4, this.TimeBufferType), this.values = yo.convertArray(r3, this.ValueBufferType), this.setInterpolation(n2 || this.DefaultInterpolation);
        }
        function So(t3, e4, r3) {
          Mo.call(this, t3, e4, r3);
        }
        function To(t3, e4, r3, n2) {
          Mo.call(this, t3, e4, r3, n2);
        }
        function Eo(t3, e4, r3, n2) {
          Mo.call(this, t3, e4, r3, n2);
        }
        function Ao(t3, e4, r3, n2) {
          xo.call(this, t3, e4, r3, n2);
        }
        function Lo(t3, e4, r3, n2) {
          Mo.call(this, t3, e4, r3, n2);
        }
        function Ro(t3, e4, r3, n2) {
          Mo.call(this, t3, e4, r3, n2);
        }
        function Po(t3, e4, r3, n2) {
          Mo.call(this, t3, e4, r3, n2);
        }
        function Co(t3, e4, r3) {
          this.name = t3, this.tracks = r3, this.duration = e4 !== void 0 ? e4 : -1, this.uuid = s3.generateUUID(), this.duration < 0 && this.resetDuration();
        }
        function Oo(t3) {
          if (t3.type === void 0)
            throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
          var e4 = function(t4) {
            switch (t4.toLowerCase()) {
              case "scalar":
              case "double":
              case "float":
              case "number":
              case "integer":
                return Eo;
              case "vector":
              case "vector2":
              case "vector3":
              case "vector4":
                return Po;
              case "color":
                return To;
              case "quaternion":
                return Lo;
              case "bool":
              case "boolean":
                return So;
              case "string":
                return Ro;
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t4);
          }(t3.type);
          if (t3.times === void 0) {
            var r3 = [], n2 = [];
            yo.flattenJSON(t3.keys, r3, n2, "value"), t3.times = r3, t3.values = n2;
          }
          return e4.parse !== void 0 ? e4.parse(t3) : new e4(t3.name, t3.times, t3.values, t3.interpolation);
        }
        Object.assign(xo.prototype, { evaluate: function(t3) {
          var e4 = this.parameterPositions, r3 = this._cachedIndex, n2 = e4[r3], i3 = e4[r3 - 1];
          t: {
            e: {
              var a3;
              r: {
                n:
                  if (!(t3 < n2)) {
                    for (var o5 = r3 + 2; ; ) {
                      if (n2 === void 0) {
                        if (t3 < i3)
                          break n;
                        return r3 = e4.length, this._cachedIndex = r3, this.afterEnd_(r3 - 1, t3, i3);
                      }
                      if (r3 === o5)
                        break;
                      if (i3 = n2, t3 < (n2 = e4[++r3]))
                        break e;
                    }
                    a3 = e4.length;
                    break r;
                  }
                if (t3 >= i3)
                  break t;
                var s4 = e4[1];
                for (t3 < s4 && (r3 = 2, i3 = s4), o5 = r3 - 2; ; ) {
                  if (i3 === void 0)
                    return this._cachedIndex = 0, this.beforeStart_(0, t3, n2);
                  if (r3 === o5)
                    break;
                  if (n2 = i3, t3 >= (i3 = e4[--r3 - 1]))
                    break e;
                }
                a3 = r3, r3 = 0;
              }
              for (; r3 < a3; ) {
                var c3 = r3 + a3 >>> 1;
                t3 < e4[c3] ? a3 = c3 : r3 = c3 + 1;
              }
              if (n2 = e4[r3], (i3 = e4[r3 - 1]) === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, t3, n2);
              if (n2 === void 0)
                return r3 = e4.length, this._cachedIndex = r3, this.afterEnd_(r3 - 1, i3, t3);
            }
            this._cachedIndex = r3, this.intervalChanged_(r3, i3, n2);
          }
          return this.interpolate_(r3, i3, t3, n2);
        }, settings: null, DefaultSettings_: {}, getSettings_: function() {
          return this.settings || this.DefaultSettings_;
        }, copySampleValue_: function(t3) {
          for (var e4 = this.resultBuffer, r3 = this.sampleValues, n2 = this.valueSize, i3 = t3 * n2, a3 = 0; a3 !== n2; ++a3)
            e4[a3] = r3[i3 + a3];
          return e4;
        }, interpolate_: function() {
          throw new Error("call to abstract method");
        }, intervalChanged_: function() {
        } }), Object.assign(xo.prototype, { beforeStart_: xo.prototype.copySampleValue_, afterEnd_: xo.prototype.copySampleValue_ }), bo.prototype = Object.assign(Object.create(xo.prototype), { constructor: bo, DefaultSettings_: { endingStart: 2400, endingEnd: 2400 }, intervalChanged_: function(t3, e4, r3) {
          var n2 = this.parameterPositions, i3 = t3 - 2, a3 = t3 + 1, o5 = n2[i3], s4 = n2[a3];
          if (o5 === void 0)
            switch (this.getSettings_().endingStart) {
              case 2401:
                i3 = t3, o5 = 2 * e4 - r3;
                break;
              case 2402:
                o5 = e4 + n2[i3 = n2.length - 2] - n2[i3 + 1];
                break;
              default:
                i3 = t3, o5 = r3;
            }
          if (s4 === void 0)
            switch (this.getSettings_().endingEnd) {
              case 2401:
                a3 = t3, s4 = 2 * r3 - e4;
                break;
              case 2402:
                a3 = 1, s4 = r3 + n2[1] - n2[0];
                break;
              default:
                a3 = t3 - 1, s4 = e4;
            }
          var c3 = 0.5 * (r3 - e4), l4 = this.valueSize;
          this._weightPrev = c3 / (e4 - o5), this._weightNext = c3 / (s4 - r3), this._offsetPrev = i3 * l4, this._offsetNext = a3 * l4;
        }, interpolate_: function(t3, e4, r3, n2) {
          for (var i3 = this.resultBuffer, a3 = this.sampleValues, o5 = this.valueSize, s4 = t3 * o5, c3 = s4 - o5, l4 = this._offsetPrev, h3 = this._offsetNext, u3 = this._weightPrev, p3 = this._weightNext, d3 = (r3 - e4) / (n2 - e4), f3 = d3 * d3, m3 = f3 * d3, g3 = -u3 * m3 + 2 * u3 * f3 - u3 * d3, v3 = (1 + u3) * m3 + (-1.5 - 2 * u3) * f3 + (-0.5 + u3) * d3 + 1, y3 = (-1 - p3) * m3 + (1.5 + p3) * f3 + 0.5 * d3, x3 = p3 * m3 - p3 * f3, b3 = 0; b3 !== o5; ++b3)
            i3[b3] = g3 * a3[l4 + b3] + v3 * a3[c3 + b3] + y3 * a3[s4 + b3] + x3 * a3[h3 + b3];
          return i3;
        } }), wo.prototype = Object.assign(Object.create(xo.prototype), { constructor: wo, interpolate_: function(t3, e4, r3, n2) {
          for (var i3 = this.resultBuffer, a3 = this.sampleValues, o5 = this.valueSize, s4 = t3 * o5, c3 = s4 - o5, l4 = (r3 - e4) / (n2 - e4), h3 = 1 - l4, u3 = 0; u3 !== o5; ++u3)
            i3[u3] = a3[c3 + u3] * h3 + a3[s4 + u3] * l4;
          return i3;
        } }), _o.prototype = Object.assign(Object.create(xo.prototype), { constructor: _o, interpolate_: function(t3) {
          return this.copySampleValue_(t3 - 1);
        } }), Object.assign(Mo, { toJSON: function(t3) {
          var e4, r3 = t3.constructor;
          if (r3.toJSON !== void 0)
            e4 = r3.toJSON(t3);
          else {
            e4 = { name: t3.name, times: yo.convertArray(t3.times, Array), values: yo.convertArray(t3.values, Array) };
            var n2 = t3.getInterpolation();
            n2 !== t3.DefaultInterpolation && (e4.interpolation = n2);
          }
          return e4.type = t3.ValueTypeName, e4;
        } }), Object.assign(Mo.prototype, { constructor: Mo, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function(t3) {
          return new _o(this.times, this.values, this.getValueSize(), t3);
        }, InterpolantFactoryMethodLinear: function(t3) {
          return new wo(this.times, this.values, this.getValueSize(), t3);
        }, InterpolantFactoryMethodSmooth: function(t3) {
          return new bo(this.times, this.values, this.getValueSize(), t3);
        }, setInterpolation: function(t3) {
          var e4;
          switch (t3) {
            case 2300:
              e4 = this.InterpolantFactoryMethodDiscrete;
              break;
            case 2301:
              e4 = this.InterpolantFactoryMethodLinear;
              break;
            case 2302:
              e4 = this.InterpolantFactoryMethodSmooth;
          }
          if (e4 === void 0) {
            var r3 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) {
              if (t3 === this.DefaultInterpolation)
                throw new Error(r3);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", r3), this;
          }
          return this.createInterpolant = e4, this;
        }, getInterpolation: function() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return 2300;
            case this.InterpolantFactoryMethodLinear:
              return 2301;
            case this.InterpolantFactoryMethodSmooth:
              return 2302;
          }
        }, getValueSize: function() {
          return this.values.length / this.times.length;
        }, shift: function(t3) {
          if (t3 !== 0)
            for (var e4 = this.times, r3 = 0, n2 = e4.length; r3 !== n2; ++r3)
              e4[r3] += t3;
          return this;
        }, scale: function(t3) {
          if (t3 !== 1)
            for (var e4 = this.times, r3 = 0, n2 = e4.length; r3 !== n2; ++r3)
              e4[r3] *= t3;
          return this;
        }, trim: function(t3, e4) {
          for (var r3 = this.times, n2 = r3.length, i3 = 0, a3 = n2 - 1; i3 !== n2 && r3[i3] < t3; )
            ++i3;
          for (; a3 !== -1 && r3[a3] > e4; )
            --a3;
          if (++a3, i3 !== 0 || a3 !== n2) {
            i3 >= a3 && (i3 = (a3 = Math.max(a3, 1)) - 1);
            var o5 = this.getValueSize();
            this.times = yo.arraySlice(r3, i3, a3), this.values = yo.arraySlice(this.values, i3 * o5, a3 * o5);
          }
          return this;
        }, validate: function() {
          var t3 = true, e4 = this.getValueSize();
          e4 - Math.floor(e4) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t3 = false);
          var r3 = this.times, n2 = this.values, i3 = r3.length;
          i3 === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t3 = false);
          for (var a3 = null, o5 = 0; o5 !== i3; o5++) {
            var s4 = r3[o5];
            if (typeof s4 == "number" && isNaN(s4)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o5, s4), t3 = false;
              break;
            }
            if (a3 !== null && a3 > s4) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, o5, s4, a3), t3 = false;
              break;
            }
            a3 = s4;
          }
          if (n2 !== void 0 && yo.isTypedArray(n2)) {
            o5 = 0;
            for (var c3 = n2.length; o5 !== c3; ++o5) {
              var l4 = n2[o5];
              if (isNaN(l4)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o5, l4), t3 = false;
                break;
              }
            }
          }
          return t3;
        }, optimize: function() {
          for (var t3 = this.times, e4 = this.values, r3 = this.getValueSize(), n2 = this.getInterpolation() === 2302, i3 = 1, a3 = t3.length - 1, o5 = 1; o5 < a3; ++o5) {
            var s4 = false, c3 = t3[o5];
            if (c3 !== t3[o5 + 1] && (o5 !== 1 || c3 !== c3[0]))
              if (n2)
                s4 = true;
              else
                for (var l4 = o5 * r3, h3 = l4 - r3, u3 = l4 + r3, p3 = 0; p3 !== r3; ++p3) {
                  var d3 = e4[l4 + p3];
                  if (d3 !== e4[h3 + p3] || d3 !== e4[u3 + p3]) {
                    s4 = true;
                    break;
                  }
                }
            if (s4) {
              if (o5 !== i3) {
                t3[i3] = t3[o5];
                var f3 = o5 * r3, m3 = i3 * r3;
                for (p3 = 0; p3 !== r3; ++p3)
                  e4[m3 + p3] = e4[f3 + p3];
              }
              ++i3;
            }
          }
          if (a3 > 0) {
            for (t3[i3] = t3[a3], f3 = a3 * r3, m3 = i3 * r3, p3 = 0; p3 !== r3; ++p3)
              e4[m3 + p3] = e4[f3 + p3];
            ++i3;
          }
          return i3 !== t3.length && (this.times = yo.arraySlice(t3, 0, i3), this.values = yo.arraySlice(e4, 0, i3 * r3)), this;
        }, clone: function() {
          var t3 = yo.arraySlice(this.times, 0), e4 = yo.arraySlice(this.values, 0), r3 = new this.constructor(this.name, t3, e4);
          return r3.createInterpolant = this.createInterpolant, r3;
        } }), So.prototype = Object.assign(Object.create(Mo.prototype), { constructor: So, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), To.prototype = Object.assign(Object.create(Mo.prototype), { constructor: To, ValueTypeName: "color" }), Eo.prototype = Object.assign(Object.create(Mo.prototype), { constructor: Eo, ValueTypeName: "number" }), Ao.prototype = Object.assign(Object.create(xo.prototype), { constructor: Ao, interpolate_: function(t3, e4, r3, n2) {
          for (var i3 = this.resultBuffer, a3 = this.sampleValues, o5 = this.valueSize, s4 = t3 * o5, c3 = (r3 - e4) / (n2 - e4), l4 = s4 + o5; s4 !== l4; s4 += 4)
            h2.slerpFlat(i3, 0, a3, s4 - o5, a3, s4, c3);
          return i3;
        } }), Lo.prototype = Object.assign(Object.create(Mo.prototype), { constructor: Lo, ValueTypeName: "quaternion", DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function(t3) {
          return new Ao(this.times, this.values, this.getValueSize(), t3);
        }, InterpolantFactoryMethodSmooth: void 0 }), Ro.prototype = Object.assign(Object.create(Mo.prototype), { constructor: Ro, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Po.prototype = Object.assign(Object.create(Mo.prototype), { constructor: Po, ValueTypeName: "vector" }), Object.assign(Co, { parse: function(t3) {
          for (var e4 = [], r3 = t3.tracks, n2 = 1 / (t3.fps || 1), i3 = 0, a3 = r3.length; i3 !== a3; ++i3)
            e4.push(Oo(r3[i3]).scale(n2));
          return new Co(t3.name, t3.duration, e4);
        }, toJSON: function(t3) {
          for (var e4 = [], r3 = t3.tracks, n2 = { name: t3.name, duration: t3.duration, tracks: e4, uuid: t3.uuid }, i3 = 0, a3 = r3.length; i3 !== a3; ++i3)
            e4.push(Mo.toJSON(r3[i3]));
          return n2;
        }, CreateFromMorphTargetSequence: function(t3, e4, r3, n2) {
          for (var i3 = e4.length, a3 = [], o5 = 0; o5 < i3; o5++) {
            var s4 = [], c3 = [];
            s4.push((o5 + i3 - 1) % i3, o5, (o5 + 1) % i3), c3.push(0, 1, 0);
            var l4 = yo.getKeyframeOrder(s4);
            s4 = yo.sortedArray(s4, 1, l4), c3 = yo.sortedArray(c3, 1, l4), n2 || s4[0] !== 0 || (s4.push(i3), c3.push(c3[0])), a3.push(new Eo(".morphTargetInfluences[" + e4[o5].name + "]", s4, c3).scale(1 / r3));
          }
          return new Co(t3, -1, a3);
        }, findByName: function(t3, e4) {
          var r3 = t3;
          if (!Array.isArray(t3)) {
            var n2 = t3;
            r3 = n2.geometry && n2.geometry.animations || n2.animations;
          }
          for (var i3 = 0; i3 < r3.length; i3++)
            if (r3[i3].name === e4)
              return r3[i3];
          return null;
        }, CreateClipsFromMorphTargetSequences: function(t3, e4, r3) {
          for (var n2 = {}, i3 = /^([\w-]*?)([\d]+)$/, a3 = 0, o5 = t3.length; a3 < o5; a3++) {
            var s4 = t3[a3], c3 = s4.name.match(i3);
            if (c3 && c3.length > 1) {
              var l4 = n2[u3 = c3[1]];
              l4 || (n2[u3] = l4 = []), l4.push(s4);
            }
          }
          var h3 = [];
          for (var u3 in n2)
            h3.push(Co.CreateFromMorphTargetSequence(u3, n2[u3], e4, r3));
          return h3;
        }, parseAnimation: function(t3, e4) {
          if (!t3)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
          for (var r3 = function(t4, e5, r4, n3, i4) {
            if (r4.length !== 0) {
              var a4 = [], o6 = [];
              yo.flattenJSON(r4, a4, o6, n3), a4.length !== 0 && i4.push(new t4(e5, a4, o6));
            }
          }, n2 = [], i3 = t3.name || "default", a3 = t3.length || -1, o5 = t3.fps || 30, s4 = t3.hierarchy || [], c3 = 0; c3 < s4.length; c3++) {
            var l4 = s4[c3].keys;
            if (l4 && l4.length !== 0)
              if (l4[0].morphTargets) {
                for (var h3 = {}, u3 = 0; u3 < l4.length; u3++)
                  if (l4[u3].morphTargets)
                    for (var p3 = 0; p3 < l4[u3].morphTargets.length; p3++)
                      h3[l4[u3].morphTargets[p3]] = -1;
                for (var d3 in h3) {
                  var f3 = [], m3 = [];
                  for (p3 = 0; p3 !== l4[u3].morphTargets.length; ++p3) {
                    var g3 = l4[u3];
                    f3.push(g3.time), m3.push(g3.morphTarget === d3 ? 1 : 0);
                  }
                  n2.push(new Eo(".morphTargetInfluence[" + d3 + "]", f3, m3));
                }
                a3 = h3.length * (o5 || 1);
              } else {
                var v3 = ".bones[" + e4[c3].name + "]";
                r3(Po, v3 + ".position", l4, "pos", n2), r3(Lo, v3 + ".quaternion", l4, "rot", n2), r3(Po, v3 + ".scale", l4, "scl", n2);
              }
          }
          return n2.length === 0 ? null : new Co(i3, a3, n2);
        } }), Object.assign(Co.prototype, { resetDuration: function() {
          for (var t3 = 0, e4 = 0, r3 = this.tracks.length; e4 !== r3; ++e4) {
            var n2 = this.tracks[e4];
            t3 = Math.max(t3, n2.times[n2.times.length - 1]);
          }
          return this.duration = t3, this;
        }, trim: function() {
          for (var t3 = 0; t3 < this.tracks.length; t3++)
            this.tracks[t3].trim(0, this.duration);
          return this;
        }, validate: function() {
          for (var t3 = true, e4 = 0; e4 < this.tracks.length; e4++)
            t3 = t3 && this.tracks[e4].validate();
          return t3;
        }, optimize: function() {
          for (var t3 = 0; t3 < this.tracks.length; t3++)
            this.tracks[t3].optimize();
          return this;
        }, clone: function() {
          for (var t3 = [], e4 = 0; e4 < this.tracks.length; e4++)
            t3.push(this.tracks[e4].clone());
          return new Co(this.name, this.duration, t3);
        } });
        var Do = { enabled: false, files: {}, add: function(t3, e4) {
          this.enabled !== false && (this.files[t3] = e4);
        }, get: function(t3) {
          if (this.enabled !== false)
            return this.files[t3];
        }, remove: function(t3) {
          delete this.files[t3];
        }, clear: function() {
          this.files = {};
        } };
        function No(t3, e4, r3) {
          var n2 = this, i3 = false, a3 = 0, o5 = 0, s4 = void 0;
          this.onStart = void 0, this.onLoad = t3, this.onProgress = e4, this.onError = r3, this.itemStart = function(t4) {
            o5++, i3 === false && n2.onStart !== void 0 && n2.onStart(t4, a3, o5), i3 = true;
          }, this.itemEnd = function(t4) {
            a3++, n2.onProgress !== void 0 && n2.onProgress(t4, a3, o5), a3 === o5 && (i3 = false, n2.onLoad !== void 0 && n2.onLoad());
          }, this.itemError = function(t4) {
            n2.onError !== void 0 && n2.onError(t4);
          }, this.resolveURL = function(t4) {
            return s4 ? s4(t4) : t4;
          }, this.setURLModifier = function(t4) {
            return s4 = t4, this;
          };
        }
        var Io = new No();
        function zo(t3) {
          this.manager = t3 !== void 0 ? t3 : Io, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = "";
        }
        Object.assign(zo.prototype, { load: function() {
        }, parse: function() {
        }, setCrossOrigin: function(t3) {
          return this.crossOrigin = t3, this;
        }, setPath: function(t3) {
          return this.path = t3, this;
        }, setResourcePath: function(t3) {
          return this.resourcePath = t3, this;
        } }), zo.Handlers = { handlers: [], add: function(t3, e4) {
          this.handlers.push(t3, e4);
        }, get: function(t3) {
          for (var e4 = this.handlers, r3 = 0, n2 = e4.length; r3 < n2; r3 += 2) {
            var i3 = e4[r3], a3 = e4[r3 + 1];
            if (i3.test(t3))
              return a3;
          }
          return null;
        } };
        var Bo = {};
        function Fo(t3) {
          zo.call(this, t3);
        }
        function Go(t3) {
          zo.call(this, t3);
        }
        function Uo(t3) {
          zo.call(this, t3), this._parser = null;
        }
        function Ho(t3) {
          zo.call(this, t3), this._parser = null;
        }
        function Vo(t3) {
          zo.call(this, t3);
        }
        function jo(t3) {
          zo.call(this, t3);
        }
        function ko(t3) {
          zo.call(this, t3);
        }
        function Wo() {
          this.type = "Curve", this.arcLengthDivisions = 200;
        }
        function qo(t3, e4, r3, n2, i3, a3, o5, s4) {
          Wo.call(this), this.type = "EllipseCurve", this.aX = t3 || 0, this.aY = e4 || 0, this.xRadius = r3 || 1, this.yRadius = n2 || 1, this.aStartAngle = i3 || 0, this.aEndAngle = a3 || 2 * Math.PI, this.aClockwise = o5 || false, this.aRotation = s4 || 0;
        }
        function Xo(t3, e4, r3, n2, i3, a3) {
          qo.call(this, t3, e4, r3, r3, n2, i3, a3), this.type = "ArcCurve";
        }
        function Yo() {
          var t3 = 0, e4 = 0, r3 = 0, n2 = 0;
          function i3(i4, a3, o5, s4) {
            t3 = i4, e4 = o5, r3 = -3 * i4 + 3 * a3 - 2 * o5 - s4, n2 = 2 * i4 - 2 * a3 + o5 + s4;
          }
          return { initCatmullRom: function(t4, e5, r4, n3, a3) {
            i3(e5, r4, a3 * (r4 - t4), a3 * (n3 - e5));
          }, initNonuniformCatmullRom: function(t4, e5, r4, n3, a3, o5, s4) {
            var c3 = (e5 - t4) / a3 - (r4 - t4) / (a3 + o5) + (r4 - e5) / o5, l4 = (r4 - e5) / o5 - (n3 - e5) / (o5 + s4) + (n3 - r4) / s4;
            i3(e5, r4, c3 *= o5, l4 *= o5);
          }, calc: function(i4) {
            var a3 = i4 * i4;
            return t3 + e4 * i4 + r3 * a3 + n2 * (a3 * i4);
          } };
        }
        Fo.prototype = Object.assign(Object.create(zo.prototype), { constructor: Fo, load: function(t3, e4, r3, i3) {
          t3 === void 0 && (t3 = ""), this.path !== void 0 && (t3 = this.path + t3), t3 = this.manager.resolveURL(t3);
          var a3 = this, o5 = Do.get(t3);
          if (o5 !== void 0)
            return a3.manager.itemStart(t3), setTimeout(function() {
              e4 && e4(o5), a3.manager.itemEnd(t3);
            }, 0), o5;
          if (Bo[t3] === void 0) {
            var s4, l4 = t3.match(/^data:(.*?)(;base64)?,(.*)$/);
            if (l4) {
              var h3 = l4[1], u3 = !!l4[2], p3 = l4[3];
              p3 = decodeURIComponent(p3), u3 && (s4 = p3, p3 = Object(n.atob)(s4));
              try {
                var d3, f3 = (this.responseType || "").toLowerCase();
                switch (f3) {
                  case "arraybuffer":
                  case "blob":
                    for (var m3 = new Uint8Array(p3.length), g3 = 0; g3 < p3.length; g3++)
                      m3[g3] = p3.charCodeAt(g3);
                    d3 = f3 === "blob" ? new Blob([m3.buffer], { type: h3 }) : m3.buffer;
                    break;
                  case "document":
                    var v3 = new DOMParser();
                    d3 = v3.parseFromString(p3, h3);
                    break;
                  case "json":
                    d3 = JSON.parse(p3);
                    break;
                  default:
                    d3 = p3;
                }
                setTimeout(function() {
                  e4 && e4(d3), a3.manager.itemEnd(t3);
                }, 0);
              } catch (e5) {
                setTimeout(function() {
                  i3 && i3(e5), a3.manager.itemError(t3), a3.manager.itemEnd(t3);
                }, 0);
              }
            } else {
              Bo[t3] = [], Bo[t3].push({ onLoad: e4, onProgress: r3, onError: i3 });
              var y3 = new c2();
              for (var x3 in y3.open("GET", t3, true), y3.addEventListener("load", function(e5) {
                var r4 = this.response;
                Do.add(t3, r4);
                var n2 = Bo[t3];
                if (delete Bo[t3], this.status === 200 || this.status === 0) {
                  this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                  for (var i4 = 0, o6 = n2.length; i4 < o6; i4++)
                    (s5 = n2[i4]).onLoad && s5.onLoad(r4);
                  a3.manager.itemEnd(t3);
                } else {
                  for (i4 = 0, o6 = n2.length; i4 < o6; i4++) {
                    var s5;
                    (s5 = n2[i4]).onError && s5.onError(e5);
                  }
                  a3.manager.itemError(t3), a3.manager.itemEnd(t3);
                }
              }, false), y3.addEventListener("progress", function(e5) {
                for (var r4 = Bo[t3], n2 = 0, i4 = r4.length; n2 < i4; n2++) {
                  var a4 = r4[n2];
                  a4.onProgress && a4.onProgress(e5);
                }
              }, false), y3.addEventListener("error", function(e5) {
                var r4 = Bo[t3];
                delete Bo[t3];
                for (var n2 = 0, i4 = r4.length; n2 < i4; n2++) {
                  var o6 = r4[n2];
                  o6.onError && o6.onError(e5);
                }
                a3.manager.itemError(t3), a3.manager.itemEnd(t3);
              }, false), y3.addEventListener("abort", function(e5) {
                var r4 = Bo[t3];
                delete Bo[t3];
                for (var n2 = 0, i4 = r4.length; n2 < i4; n2++) {
                  var o6 = r4[n2];
                  o6.onError && o6.onError(e5);
                }
                a3.manager.itemError(t3), a3.manager.itemEnd(t3);
              }, false), this.responseType !== void 0 && (y3.responseType = this.responseType), this.withCredentials !== void 0 && (y3.withCredentials = this.withCredentials), y3.overrideMimeType && y3.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain"), this.requestHeader)
                y3.setRequestHeader(x3, this.requestHeader[x3]);
              y3.send(null);
            }
            return a3.manager.itemStart(t3), y3;
          }
          Bo[t3].push({ onLoad: e4, onProgress: r3, onError: i3 });
        }, setResponseType: function(t3) {
          return this.responseType = t3, this;
        }, setWithCredentials: function(t3) {
          return this.withCredentials = t3, this;
        }, setMimeType: function(t3) {
          return this.mimeType = t3, this;
        }, setRequestHeader: function(t3) {
          return this.requestHeader = t3, this;
        } }), Go.prototype = Object.assign(Object.create(zo.prototype), { constructor: Go, load: function(t3, e4, r3, n2) {
          var i3 = this, a3 = new Fo(i3.manager);
          a3.setPath(i3.path), a3.load(t3, function(t4) {
            e4(i3.parse(JSON.parse(t4)));
          }, r3, n2);
        }, parse: function(t3) {
          for (var e4 = [], r3 = 0; r3 < t3.length; r3++) {
            var n2 = Co.parse(t3[r3]);
            e4.push(n2);
          }
          return e4;
        } }), Uo.prototype = Object.assign(Object.create(zo.prototype), { constructor: Uo, load: function(t3, e4, r3, n2) {
          var i3 = this, a3 = [], o5 = new ki();
          o5.image = a3;
          var s4 = new Fo(this.manager);
          function c3(c4) {
            s4.load(t3[c4], function(t4) {
              var r4 = i3._parser(t4, true);
              a3[c4] = { width: r4.width, height: r4.height, format: r4.format, mipmaps: r4.mipmaps }, (l4 += 1) === 6 && (r4.mipmapCount === 1 && (o5.minFilter = 1006), o5.format = r4.format, o5.needsUpdate = true, e4 && e4(o5));
            }, r3, n2);
          }
          if (s4.setPath(this.path), s4.setResponseType("arraybuffer"), Array.isArray(t3))
            for (var l4 = 0, h3 = 0, u3 = t3.length; h3 < u3; ++h3)
              c3(h3);
          else
            s4.load(t3, function(t4) {
              var r4 = i3._parser(t4, true);
              if (r4.isCubemap)
                for (var n3 = r4.mipmaps.length / r4.mipmapCount, s5 = 0; s5 < n3; s5++) {
                  a3[s5] = { mipmaps: [] };
                  for (var c4 = 0; c4 < r4.mipmapCount; c4++)
                    a3[s5].mipmaps.push(r4.mipmaps[s5 * r4.mipmapCount + c4]), a3[s5].format = r4.format, a3[s5].width = r4.width, a3[s5].height = r4.height;
                }
              else
                o5.image.width = r4.width, o5.image.height = r4.height, o5.mipmaps = r4.mipmaps;
              r4.mipmapCount === 1 && (o5.minFilter = 1006), o5.format = r4.format, o5.needsUpdate = true, e4 && e4(o5);
            }, r3, n2);
          return o5;
        } }), Ho.prototype = Object.assign(Object.create(zo.prototype), { constructor: Ho, load: function(t3, e4, r3, n2) {
          var i3 = this, a3 = new je(), o5 = new Fo(this.manager);
          return o5.setResponseType("arraybuffer"), o5.setPath(this.path), o5.load(t3, function(t4) {
            var r4 = i3._parser(t4);
            r4 && (r4.image !== void 0 ? a3.image = r4.image : r4.data !== void 0 && (a3.image.width = r4.width, a3.image.height = r4.height, a3.image.data = r4.data), a3.wrapS = r4.wrapS !== void 0 ? r4.wrapS : 1001, a3.wrapT = r4.wrapT !== void 0 ? r4.wrapT : 1001, a3.magFilter = r4.magFilter !== void 0 ? r4.magFilter : 1006, a3.minFilter = r4.minFilter !== void 0 ? r4.minFilter : 1008, a3.anisotropy = r4.anisotropy !== void 0 ? r4.anisotropy : 1, r4.format !== void 0 && (a3.format = r4.format), r4.type !== void 0 && (a3.type = r4.type), r4.mipmaps !== void 0 && (a3.mipmaps = r4.mipmaps), r4.mipmapCount === 1 && (a3.minFilter = 1006), a3.needsUpdate = true, e4 && e4(a3, r4));
          }, r3, n2), a3;
        } }), Vo.prototype = Object.assign(Object.create(zo.prototype), { constructor: Vo, load: function(t3, e4, r3, n2) {
          this.path !== void 0 && (t3 = this.path + t3), t3 = this.manager.resolveURL(t3);
          var a3 = this, o5 = Do.get(t3);
          if (o5 !== void 0)
            return a3.manager.itemStart(t3), setTimeout(function() {
              e4 && e4(o5), a3.manager.itemEnd(t3);
            }, 0), o5;
          var s4 = i2.createElementNS("http://www.w3.org/1999/xhtml", "img");
          function c3() {
            s4.removeEventListener("load", c3, false), s4.removeEventListener("error", l4, false), Do.add(t3, this), e4 && e4(this), a3.manager.itemEnd(t3);
          }
          function l4(e5) {
            s4.removeEventListener("load", c3, false), s4.removeEventListener("error", l4, false), n2 && n2(e5), a3.manager.itemError(t3), a3.manager.itemEnd(t3);
          }
          return s4.addEventListener("load", c3, false), s4.addEventListener("error", l4, false), t3.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (s4.crossOrigin = this.crossOrigin), a3.manager.itemStart(t3), s4.src = t3, s4;
        } }), jo.prototype = Object.assign(Object.create(zo.prototype), { constructor: jo, load: function(t3, e4, r3, n2) {
          var i3 = new mr(), a3 = new Vo(this.manager);
          a3.setCrossOrigin(this.crossOrigin), a3.setPath(this.path);
          var o5 = 0;
          function s4(r4) {
            a3.load(t3[r4], function(t4) {
              i3.images[r4] = t4, ++o5 == 6 && (i3.needsUpdate = true, e4 && e4(i3));
            }, void 0, n2);
          }
          for (var c3 = 0; c3 < t3.length; ++c3)
            s4(c3);
          return i3;
        } }), ko.prototype = Object.assign(Object.create(zo.prototype), { constructor: ko, load: function(t3, e4, r3, n2) {
          var i3 = new y2(), a3 = new Vo(this.manager);
          return a3.setCrossOrigin(this.crossOrigin), a3.setPath(this.path), a3.load(t3, function(r4) {
            i3.image = r4;
            var n3 = t3.search(/\.jpe?g($|\?)/i) > 0 || t3.search(/^data\:image\/jpeg/) === 0;
            i3.format = n3 ? 1022 : 1023, i3.needsUpdate = true, e4 !== void 0 && e4(i3);
          }, r3, n2), i3;
        } }), Object.assign(Wo.prototype, { getPoint: function() {
          return console.warn("THREE.Curve: .getPoint() not implemented."), null;
        }, getPointAt: function(t3, e4) {
          var r3 = this.getUtoTmapping(t3);
          return this.getPoint(r3, e4);
        }, getPoints: function(t3) {
          t3 === void 0 && (t3 = 5);
          for (var e4 = [], r3 = 0; r3 <= t3; r3++)
            e4.push(this.getPoint(r3 / t3));
          return e4;
        }, getSpacedPoints: function(t3) {
          t3 === void 0 && (t3 = 5);
          for (var e4 = [], r3 = 0; r3 <= t3; r3++)
            e4.push(this.getPointAt(r3 / t3));
          return e4;
        }, getLength: function() {
          var t3 = this.getLengths();
          return t3[t3.length - 1];
        }, getLengths: function(t3) {
          if (t3 === void 0 && (t3 = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t3 + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
          this.needsUpdate = false;
          var e4, r3, n2 = [], i3 = this.getPoint(0), a3 = 0;
          for (n2.push(0), r3 = 1; r3 <= t3; r3++)
            a3 += (e4 = this.getPoint(r3 / t3)).distanceTo(i3), n2.push(a3), i3 = e4;
          return this.cacheArcLengths = n2, n2;
        }, updateArcLengths: function() {
          this.needsUpdate = true, this.getLengths();
        }, getUtoTmapping: function(t3, e4) {
          var r3, n2 = this.getLengths(), i3 = 0, a3 = n2.length;
          r3 = e4 || t3 * n2[a3 - 1];
          for (var o5, s4 = 0, c3 = a3 - 1; s4 <= c3; )
            if ((o5 = n2[i3 = Math.floor(s4 + (c3 - s4) / 2)] - r3) < 0)
              s4 = i3 + 1;
            else {
              if (!(o5 > 0)) {
                c3 = i3;
                break;
              }
              c3 = i3 - 1;
            }
          if (n2[i3 = c3] === r3)
            return i3 / (a3 - 1);
          var l4 = n2[i3];
          return (i3 + (r3 - l4) / (n2[i3 + 1] - l4)) / (a3 - 1);
        }, getTangent: function(t3) {
          var e4 = t3 - 1e-4, r3 = t3 + 1e-4;
          e4 < 0 && (e4 = 0), r3 > 1 && (r3 = 1);
          var n2 = this.getPoint(e4);
          return this.getPoint(r3).clone().sub(n2).normalize();
        }, getTangentAt: function(t3) {
          var e4 = this.getUtoTmapping(t3);
          return this.getTangent(e4);
        }, computeFrenetFrames: function(t3, e4) {
          var r3, n2, i3, a3 = new d2(), o5 = [], c3 = [], l4 = [], h3 = new d2(), u3 = new P2();
          for (r3 = 0; r3 <= t3; r3++)
            n2 = r3 / t3, o5[r3] = this.getTangentAt(n2), o5[r3].normalize();
          c3[0] = new d2(), l4[0] = new d2();
          var p3 = Number.MAX_VALUE, f3 = Math.abs(o5[0].x), m3 = Math.abs(o5[0].y), g3 = Math.abs(o5[0].z);
          for (f3 <= p3 && (p3 = f3, a3.set(1, 0, 0)), m3 <= p3 && (p3 = m3, a3.set(0, 1, 0)), g3 <= p3 && a3.set(0, 0, 1), h3.crossVectors(o5[0], a3).normalize(), c3[0].crossVectors(o5[0], h3), l4[0].crossVectors(o5[0], c3[0]), r3 = 1; r3 <= t3; r3++)
            c3[r3] = c3[r3 - 1].clone(), l4[r3] = l4[r3 - 1].clone(), h3.crossVectors(o5[r3 - 1], o5[r3]), h3.length() > Number.EPSILON && (h3.normalize(), i3 = Math.acos(s3.clamp(o5[r3 - 1].dot(o5[r3]), -1, 1)), c3[r3].applyMatrix4(u3.makeRotationAxis(h3, i3))), l4[r3].crossVectors(o5[r3], c3[r3]);
          if (e4 === true)
            for (i3 = Math.acos(s3.clamp(c3[0].dot(c3[t3]), -1, 1)), i3 /= t3, o5[0].dot(h3.crossVectors(c3[0], c3[t3])) > 0 && (i3 = -i3), r3 = 1; r3 <= t3; r3++)
              c3[r3].applyMatrix4(u3.makeRotationAxis(o5[r3], i3 * r3)), l4[r3].crossVectors(o5[r3], c3[r3]);
          return { tangents: o5, normals: c3, binormals: l4 };
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          return this.arcLengthDivisions = t3.arcLengthDivisions, this;
        }, toJSON: function() {
          var t3 = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
          return t3.arcLengthDivisions = this.arcLengthDivisions, t3.type = this.type, t3;
        }, fromJSON: function(t3) {
          return this.arcLengthDivisions = t3.arcLengthDivisions, this;
        } }), qo.prototype = Object.create(Wo.prototype), qo.prototype.constructor = qo, qo.prototype.isEllipseCurve = true, qo.prototype.getPoint = function(t3, e4) {
          for (var r3 = e4 || new l3(), n2 = 2 * Math.PI, i3 = this.aEndAngle - this.aStartAngle, a3 = Math.abs(i3) < Number.EPSILON; i3 < 0; )
            i3 += n2;
          for (; i3 > n2; )
            i3 -= n2;
          i3 < Number.EPSILON && (i3 = a3 ? 0 : n2), this.aClockwise !== true || a3 || (i3 === n2 ? i3 = -n2 : i3 -= n2);
          var o5 = this.aStartAngle + t3 * i3, s4 = this.aX + this.xRadius * Math.cos(o5), c3 = this.aY + this.yRadius * Math.sin(o5);
          if (this.aRotation !== 0) {
            var h3 = Math.cos(this.aRotation), u3 = Math.sin(this.aRotation), p3 = s4 - this.aX, d3 = c3 - this.aY;
            s4 = p3 * h3 - d3 * u3 + this.aX, c3 = p3 * u3 + d3 * h3 + this.aY;
          }
          return r3.set(s4, c3);
        }, qo.prototype.copy = function(t3) {
          return Wo.prototype.copy.call(this, t3), this.aX = t3.aX, this.aY = t3.aY, this.xRadius = t3.xRadius, this.yRadius = t3.yRadius, this.aStartAngle = t3.aStartAngle, this.aEndAngle = t3.aEndAngle, this.aClockwise = t3.aClockwise, this.aRotation = t3.aRotation, this;
        }, qo.prototype.toJSON = function() {
          var t3 = Wo.prototype.toJSON.call(this);
          return t3.aX = this.aX, t3.aY = this.aY, t3.xRadius = this.xRadius, t3.yRadius = this.yRadius, t3.aStartAngle = this.aStartAngle, t3.aEndAngle = this.aEndAngle, t3.aClockwise = this.aClockwise, t3.aRotation = this.aRotation, t3;
        }, qo.prototype.fromJSON = function(t3) {
          return Wo.prototype.fromJSON.call(this, t3), this.aX = t3.aX, this.aY = t3.aY, this.xRadius = t3.xRadius, this.yRadius = t3.yRadius, this.aStartAngle = t3.aStartAngle, this.aEndAngle = t3.aEndAngle, this.aClockwise = t3.aClockwise, this.aRotation = t3.aRotation, this;
        }, Xo.prototype = Object.create(qo.prototype), Xo.prototype.constructor = Xo, Xo.prototype.isArcCurve = true;
        var Jo = new d2(), Zo = new Yo(), Qo = new Yo(), Ko = new Yo();
        function $o(t3, e4, r3, n2) {
          Wo.call(this), this.type = "CatmullRomCurve3", this.points = t3 || [], this.closed = e4 || false, this.curveType = r3 || "centripetal", this.tension = n2 || 0.5;
        }
        function ts(t3, e4, r3, n2, i3) {
          var a3 = 0.5 * (n2 - e4), o5 = 0.5 * (i3 - r3), s4 = t3 * t3;
          return (2 * r3 - 2 * n2 + a3 + o5) * (t3 * s4) + (-3 * r3 + 3 * n2 - 2 * a3 - o5) * s4 + a3 * t3 + r3;
        }
        function es(t3, e4, r3, n2) {
          return function(t4, e5) {
            var r4 = 1 - t4;
            return r4 * r4 * e5;
          }(t3, e4) + function(t4, e5) {
            return 2 * (1 - t4) * t4 * e5;
          }(t3, r3) + function(t4, e5) {
            return t4 * t4 * e5;
          }(t3, n2);
        }
        function rs(t3, e4, r3, n2, i3) {
          return function(t4, e5) {
            var r4 = 1 - t4;
            return r4 * r4 * r4 * e5;
          }(t3, e4) + function(t4, e5) {
            var r4 = 1 - t4;
            return 3 * r4 * r4 * t4 * e5;
          }(t3, r3) + function(t4, e5) {
            return 3 * (1 - t4) * t4 * t4 * e5;
          }(t3, n2) + function(t4, e5) {
            return t4 * t4 * t4 * e5;
          }(t3, i3);
        }
        function ns(t3, e4, r3, n2) {
          Wo.call(this), this.type = "CubicBezierCurve", this.v0 = t3 || new l3(), this.v1 = e4 || new l3(), this.v2 = r3 || new l3(), this.v3 = n2 || new l3();
        }
        function is(t3, e4, r3, n2) {
          Wo.call(this), this.type = "CubicBezierCurve3", this.v0 = t3 || new d2(), this.v1 = e4 || new d2(), this.v2 = r3 || new d2(), this.v3 = n2 || new d2();
        }
        function as(t3, e4) {
          Wo.call(this), this.type = "LineCurve", this.v1 = t3 || new l3(), this.v2 = e4 || new l3();
        }
        function os(t3, e4) {
          Wo.call(this), this.type = "LineCurve3", this.v1 = t3 || new d2(), this.v2 = e4 || new d2();
        }
        function ss(t3, e4, r3) {
          Wo.call(this), this.type = "QuadraticBezierCurve", this.v0 = t3 || new l3(), this.v1 = e4 || new l3(), this.v2 = r3 || new l3();
        }
        function cs(t3, e4, r3) {
          Wo.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t3 || new d2(), this.v1 = e4 || new d2(), this.v2 = r3 || new d2();
        }
        function ls(t3) {
          Wo.call(this), this.type = "SplineCurve", this.points = t3 || [];
        }
        $o.prototype = Object.create(Wo.prototype), $o.prototype.constructor = $o, $o.prototype.isCatmullRomCurve3 = true, $o.prototype.getPoint = function(t3, e4) {
          var r3, n2, i3, a3, o5 = e4 || new d2(), s4 = this.points, c3 = s4.length, l4 = (c3 - (this.closed ? 0 : 1)) * t3, h3 = Math.floor(l4), u3 = l4 - h3;
          if (this.closed ? h3 += h3 > 0 ? 0 : (Math.floor(Math.abs(h3) / c3) + 1) * c3 : u3 === 0 && h3 === c3 - 1 && (h3 = c3 - 2, u3 = 1), this.closed || h3 > 0 ? r3 = s4[(h3 - 1) % c3] : (Jo.subVectors(s4[0], s4[1]).add(s4[0]), r3 = Jo), n2 = s4[h3 % c3], i3 = s4[(h3 + 1) % c3], this.closed || h3 + 2 < c3 ? a3 = s4[(h3 + 2) % c3] : (Jo.subVectors(s4[c3 - 1], s4[c3 - 2]).add(s4[c3 - 1]), a3 = Jo), this.curveType === "centripetal" || this.curveType === "chordal") {
            var p3 = this.curveType === "chordal" ? 0.5 : 0.25, f3 = Math.pow(r3.distanceToSquared(n2), p3), m3 = Math.pow(n2.distanceToSquared(i3), p3), g3 = Math.pow(i3.distanceToSquared(a3), p3);
            m3 < 1e-4 && (m3 = 1), f3 < 1e-4 && (f3 = m3), g3 < 1e-4 && (g3 = m3), Zo.initNonuniformCatmullRom(r3.x, n2.x, i3.x, a3.x, f3, m3, g3), Qo.initNonuniformCatmullRom(r3.y, n2.y, i3.y, a3.y, f3, m3, g3), Ko.initNonuniformCatmullRom(r3.z, n2.z, i3.z, a3.z, f3, m3, g3);
          } else
            this.curveType === "catmullrom" && (Zo.initCatmullRom(r3.x, n2.x, i3.x, a3.x, this.tension), Qo.initCatmullRom(r3.y, n2.y, i3.y, a3.y, this.tension), Ko.initCatmullRom(r3.z, n2.z, i3.z, a3.z, this.tension));
          return o5.set(Zo.calc(u3), Qo.calc(u3), Ko.calc(u3)), o5;
        }, $o.prototype.copy = function(t3) {
          Wo.prototype.copy.call(this, t3), this.points = [];
          for (var e4 = 0, r3 = t3.points.length; e4 < r3; e4++) {
            var n2 = t3.points[e4];
            this.points.push(n2.clone());
          }
          return this.closed = t3.closed, this.curveType = t3.curveType, this.tension = t3.tension, this;
        }, $o.prototype.toJSON = function() {
          var t3 = Wo.prototype.toJSON.call(this);
          t3.points = [];
          for (var e4 = 0, r3 = this.points.length; e4 < r3; e4++) {
            var n2 = this.points[e4];
            t3.points.push(n2.toArray());
          }
          return t3.closed = this.closed, t3.curveType = this.curveType, t3.tension = this.tension, t3;
        }, $o.prototype.fromJSON = function(t3) {
          Wo.prototype.fromJSON.call(this, t3), this.points = [];
          for (var e4 = 0, r3 = t3.points.length; e4 < r3; e4++) {
            var n2 = t3.points[e4];
            this.points.push(new d2().fromArray(n2));
          }
          return this.closed = t3.closed, this.curveType = t3.curveType, this.tension = t3.tension, this;
        }, ns.prototype = Object.create(Wo.prototype), ns.prototype.constructor = ns, ns.prototype.isCubicBezierCurve = true, ns.prototype.getPoint = function(t3, e4) {
          var r3 = e4 || new l3(), n2 = this.v0, i3 = this.v1, a3 = this.v2, o5 = this.v3;
          return r3.set(rs(t3, n2.x, i3.x, a3.x, o5.x), rs(t3, n2.y, i3.y, a3.y, o5.y)), r3;
        }, ns.prototype.copy = function(t3) {
          return Wo.prototype.copy.call(this, t3), this.v0.copy(t3.v0), this.v1.copy(t3.v1), this.v2.copy(t3.v2), this.v3.copy(t3.v3), this;
        }, ns.prototype.toJSON = function() {
          var t3 = Wo.prototype.toJSON.call(this);
          return t3.v0 = this.v0.toArray(), t3.v1 = this.v1.toArray(), t3.v2 = this.v2.toArray(), t3.v3 = this.v3.toArray(), t3;
        }, ns.prototype.fromJSON = function(t3) {
          return Wo.prototype.fromJSON.call(this, t3), this.v0.fromArray(t3.v0), this.v1.fromArray(t3.v1), this.v2.fromArray(t3.v2), this.v3.fromArray(t3.v3), this;
        }, is.prototype = Object.create(Wo.prototype), is.prototype.constructor = is, is.prototype.isCubicBezierCurve3 = true, is.prototype.getPoint = function(t3, e4) {
          var r3 = e4 || new d2(), n2 = this.v0, i3 = this.v1, a3 = this.v2, o5 = this.v3;
          return r3.set(rs(t3, n2.x, i3.x, a3.x, o5.x), rs(t3, n2.y, i3.y, a3.y, o5.y), rs(t3, n2.z, i3.z, a3.z, o5.z)), r3;
        }, is.prototype.copy = function(t3) {
          return Wo.prototype.copy.call(this, t3), this.v0.copy(t3.v0), this.v1.copy(t3.v1), this.v2.copy(t3.v2), this.v3.copy(t3.v3), this;
        }, is.prototype.toJSON = function() {
          var t3 = Wo.prototype.toJSON.call(this);
          return t3.v0 = this.v0.toArray(), t3.v1 = this.v1.toArray(), t3.v2 = this.v2.toArray(), t3.v3 = this.v3.toArray(), t3;
        }, is.prototype.fromJSON = function(t3) {
          return Wo.prototype.fromJSON.call(this, t3), this.v0.fromArray(t3.v0), this.v1.fromArray(t3.v1), this.v2.fromArray(t3.v2), this.v3.fromArray(t3.v3), this;
        }, as.prototype = Object.create(Wo.prototype), as.prototype.constructor = as, as.prototype.isLineCurve = true, as.prototype.getPoint = function(t3, e4) {
          var r3 = e4 || new l3();
          return t3 === 1 ? r3.copy(this.v2) : (r3.copy(this.v2).sub(this.v1), r3.multiplyScalar(t3).add(this.v1)), r3;
        }, as.prototype.getPointAt = function(t3, e4) {
          return this.getPoint(t3, e4);
        }, as.prototype.getTangent = function() {
          return this.v2.clone().sub(this.v1).normalize();
        }, as.prototype.copy = function(t3) {
          return Wo.prototype.copy.call(this, t3), this.v1.copy(t3.v1), this.v2.copy(t3.v2), this;
        }, as.prototype.toJSON = function() {
          var t3 = Wo.prototype.toJSON.call(this);
          return t3.v1 = this.v1.toArray(), t3.v2 = this.v2.toArray(), t3;
        }, as.prototype.fromJSON = function(t3) {
          return Wo.prototype.fromJSON.call(this, t3), this.v1.fromArray(t3.v1), this.v2.fromArray(t3.v2), this;
        }, os.prototype = Object.create(Wo.prototype), os.prototype.constructor = os, os.prototype.isLineCurve3 = true, os.prototype.getPoint = function(t3, e4) {
          var r3 = e4 || new d2();
          return t3 === 1 ? r3.copy(this.v2) : (r3.copy(this.v2).sub(this.v1), r3.multiplyScalar(t3).add(this.v1)), r3;
        }, os.prototype.getPointAt = function(t3, e4) {
          return this.getPoint(t3, e4);
        }, os.prototype.copy = function(t3) {
          return Wo.prototype.copy.call(this, t3), this.v1.copy(t3.v1), this.v2.copy(t3.v2), this;
        }, os.prototype.toJSON = function() {
          var t3 = Wo.prototype.toJSON.call(this);
          return t3.v1 = this.v1.toArray(), t3.v2 = this.v2.toArray(), t3;
        }, os.prototype.fromJSON = function(t3) {
          return Wo.prototype.fromJSON.call(this, t3), this.v1.fromArray(t3.v1), this.v2.fromArray(t3.v2), this;
        }, ss.prototype = Object.create(Wo.prototype), ss.prototype.constructor = ss, ss.prototype.isQuadraticBezierCurve = true, ss.prototype.getPoint = function(t3, e4) {
          var r3 = e4 || new l3(), n2 = this.v0, i3 = this.v1, a3 = this.v2;
          return r3.set(es(t3, n2.x, i3.x, a3.x), es(t3, n2.y, i3.y, a3.y)), r3;
        }, ss.prototype.copy = function(t3) {
          return Wo.prototype.copy.call(this, t3), this.v0.copy(t3.v0), this.v1.copy(t3.v1), this.v2.copy(t3.v2), this;
        }, ss.prototype.toJSON = function() {
          var t3 = Wo.prototype.toJSON.call(this);
          return t3.v0 = this.v0.toArray(), t3.v1 = this.v1.toArray(), t3.v2 = this.v2.toArray(), t3;
        }, ss.prototype.fromJSON = function(t3) {
          return Wo.prototype.fromJSON.call(this, t3), this.v0.fromArray(t3.v0), this.v1.fromArray(t3.v1), this.v2.fromArray(t3.v2), this;
        }, cs.prototype = Object.create(Wo.prototype), cs.prototype.constructor = cs, cs.prototype.isQuadraticBezierCurve3 = true, cs.prototype.getPoint = function(t3, e4) {
          var r3 = e4 || new d2(), n2 = this.v0, i3 = this.v1, a3 = this.v2;
          return r3.set(es(t3, n2.x, i3.x, a3.x), es(t3, n2.y, i3.y, a3.y), es(t3, n2.z, i3.z, a3.z)), r3;
        }, cs.prototype.copy = function(t3) {
          return Wo.prototype.copy.call(this, t3), this.v0.copy(t3.v0), this.v1.copy(t3.v1), this.v2.copy(t3.v2), this;
        }, cs.prototype.toJSON = function() {
          var t3 = Wo.prototype.toJSON.call(this);
          return t3.v0 = this.v0.toArray(), t3.v1 = this.v1.toArray(), t3.v2 = this.v2.toArray(), t3;
        }, cs.prototype.fromJSON = function(t3) {
          return Wo.prototype.fromJSON.call(this, t3), this.v0.fromArray(t3.v0), this.v1.fromArray(t3.v1), this.v2.fromArray(t3.v2), this;
        }, ls.prototype = Object.create(Wo.prototype), ls.prototype.constructor = ls, ls.prototype.isSplineCurve = true, ls.prototype.getPoint = function(t3, e4) {
          var r3 = e4 || new l3(), n2 = this.points, i3 = (n2.length - 1) * t3, a3 = Math.floor(i3), o5 = i3 - a3, s4 = n2[a3 === 0 ? a3 : a3 - 1], c3 = n2[a3], h3 = n2[a3 > n2.length - 2 ? n2.length - 1 : a3 + 1], u3 = n2[a3 > n2.length - 3 ? n2.length - 1 : a3 + 2];
          return r3.set(ts(o5, s4.x, c3.x, h3.x, u3.x), ts(o5, s4.y, c3.y, h3.y, u3.y)), r3;
        }, ls.prototype.copy = function(t3) {
          Wo.prototype.copy.call(this, t3), this.points = [];
          for (var e4 = 0, r3 = t3.points.length; e4 < r3; e4++) {
            var n2 = t3.points[e4];
            this.points.push(n2.clone());
          }
          return this;
        }, ls.prototype.toJSON = function() {
          var t3 = Wo.prototype.toJSON.call(this);
          t3.points = [];
          for (var e4 = 0, r3 = this.points.length; e4 < r3; e4++) {
            var n2 = this.points[e4];
            t3.points.push(n2.toArray());
          }
          return t3;
        }, ls.prototype.fromJSON = function(t3) {
          Wo.prototype.fromJSON.call(this, t3), this.points = [];
          for (var e4 = 0, r3 = t3.points.length; e4 < r3; e4++) {
            var n2 = t3.points[e4];
            this.points.push(new l3().fromArray(n2));
          }
          return this;
        };
        var hs = Object.freeze({ ArcCurve: Xo, CatmullRomCurve3: $o, CubicBezierCurve: ns, CubicBezierCurve3: is, EllipseCurve: qo, LineCurve: as, LineCurve3: os, QuadraticBezierCurve: ss, QuadraticBezierCurve3: cs, SplineCurve: ls });
        function us() {
          Wo.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = false;
        }
        function ps(t3) {
          us.call(this), this.type = "Path", this.currentPoint = new l3(), t3 && this.setFromPoints(t3);
        }
        function ds(t3) {
          ps.call(this, t3), this.uuid = s3.generateUUID(), this.type = "Shape", this.holes = [];
        }
        function fs(t3, e4) {
          Y.call(this), this.type = "Light", this.color = new Nt(t3), this.intensity = e4 !== void 0 ? e4 : 1, this.receiveShadow = void 0;
        }
        function ms(t3, e4, r3) {
          fs.call(this, t3, r3), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Y.DefaultUp), this.updateMatrix(), this.groundColor = new Nt(e4);
        }
        function gs(t3) {
          this.camera = t3, this.bias = 0, this.radius = 1, this.mapSize = new l3(512, 512), this.map = null, this.mapPass = null, this.matrix = new P2(), this._frustum = new Ze(), this._frameExtents = new l3(1, 1), this._viewportCount = 1, this._viewports = [new x2(0, 0, 1, 1)];
        }
        function vs() {
          gs.call(this, new Ue(50, 1, 0.5, 500));
        }
        function ys(t3, e4, r3, n2, i3, a3) {
          fs.call(this, t3, e4), this.type = "SpotLight", this.position.copy(Y.DefaultUp), this.updateMatrix(), this.target = new Y(), Object.defineProperty(this, "power", { get: function() {
            return this.intensity * Math.PI;
          }, set: function(t4) {
            this.intensity = t4 / Math.PI;
          } }), this.distance = r3 !== void 0 ? r3 : 0, this.angle = n2 !== void 0 ? n2 : Math.PI / 3, this.penumbra = i3 !== void 0 ? i3 : 0, this.decay = a3 !== void 0 ? a3 : 1, this.shadow = new vs();
        }
        function xs() {
          gs.call(this, new Ue(90, 1, 0.5, 500)), this._frameExtents = new l3(4, 2), this._viewportCount = 6, this._viewports = [new x2(2, 1, 1, 1), new x2(0, 1, 1, 1), new x2(3, 1, 1, 1), new x2(1, 1, 1, 1), new x2(3, 0, 1, 1), new x2(1, 0, 1, 1)], this._cubeDirections = [new d2(1, 0, 0), new d2(-1, 0, 0), new d2(0, 0, 1), new d2(0, 0, -1), new d2(0, 1, 0), new d2(0, -1, 0)], this._cubeUps = [new d2(0, 1, 0), new d2(0, 1, 0), new d2(0, 1, 0), new d2(0, 1, 0), new d2(0, 0, 1), new d2(0, 0, -1)];
        }
        function bs(t3, e4, r3, n2) {
          fs.call(this, t3, e4), this.type = "PointLight", Object.defineProperty(this, "power", { get: function() {
            return 4 * this.intensity * Math.PI;
          }, set: function(t4) {
            this.intensity = t4 / (4 * Math.PI);
          } }), this.distance = r3 !== void 0 ? r3 : 0, this.decay = n2 !== void 0 ? n2 : 1, this.shadow = new xs();
        }
        function ws(t3, e4, r3, n2, i3, a3) {
          Ge.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t3 !== void 0 ? t3 : -1, this.right = e4 !== void 0 ? e4 : 1, this.top = r3 !== void 0 ? r3 : 1, this.bottom = n2 !== void 0 ? n2 : -1, this.near = i3 !== void 0 ? i3 : 0.1, this.far = a3 !== void 0 ? a3 : 2e3, this.updateProjectionMatrix();
        }
        function _s() {
          gs.call(this, new ws(-5, 5, 5, -5, 0.5, 500));
        }
        function Ms(t3, e4) {
          fs.call(this, t3, e4), this.type = "DirectionalLight", this.position.copy(Y.DefaultUp), this.updateMatrix(), this.target = new Y(), this.shadow = new _s();
        }
        function Ss(t3, e4) {
          fs.call(this, t3, e4), this.type = "AmbientLight", this.castShadow = void 0;
        }
        function Ts(t3, e4, r3, n2) {
          fs.call(this, t3, e4), this.type = "RectAreaLight", this.width = r3 !== void 0 ? r3 : 10, this.height = n2 !== void 0 ? n2 : 10;
        }
        function Es(t3) {
          zo.call(this, t3), this.textures = {};
        }
        us.prototype = Object.assign(Object.create(Wo.prototype), { constructor: us, add: function(t3) {
          this.curves.push(t3);
        }, closePath: function() {
          var t3 = this.curves[0].getPoint(0), e4 = this.curves[this.curves.length - 1].getPoint(1);
          t3.equals(e4) || this.curves.push(new as(e4, t3));
        }, getPoint: function(t3) {
          for (var e4 = t3 * this.getLength(), r3 = this.getCurveLengths(), n2 = 0; n2 < r3.length; ) {
            if (r3[n2] >= e4) {
              var i3 = r3[n2] - e4, a3 = this.curves[n2], o5 = a3.getLength(), s4 = o5 === 0 ? 0 : 1 - i3 / o5;
              return a3.getPointAt(s4);
            }
            n2++;
          }
          return null;
        }, getLength: function() {
          var t3 = this.getCurveLengths();
          return t3[t3.length - 1];
        }, updateArcLengths: function() {
          this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
        }, getCurveLengths: function() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
          for (var t3 = [], e4 = 0, r3 = 0, n2 = this.curves.length; r3 < n2; r3++)
            e4 += this.curves[r3].getLength(), t3.push(e4);
          return this.cacheLengths = t3, t3;
        }, getSpacedPoints: function(t3) {
          t3 === void 0 && (t3 = 40);
          for (var e4 = [], r3 = 0; r3 <= t3; r3++)
            e4.push(this.getPoint(r3 / t3));
          return this.autoClose && e4.push(e4[0]), e4;
        }, getPoints: function(t3) {
          t3 = t3 || 12;
          for (var e4, r3 = [], n2 = 0, i3 = this.curves; n2 < i3.length; n2++)
            for (var a3 = i3[n2], o5 = a3 && a3.isEllipseCurve ? 2 * t3 : a3 && (a3.isLineCurve || a3.isLineCurve3) ? 1 : a3 && a3.isSplineCurve ? t3 * a3.points.length : t3, s4 = a3.getPoints(o5), c3 = 0; c3 < s4.length; c3++) {
              var l4 = s4[c3];
              e4 && e4.equals(l4) || (r3.push(l4), e4 = l4);
            }
          return this.autoClose && r3.length > 1 && !r3[r3.length - 1].equals(r3[0]) && r3.push(r3[0]), r3;
        }, copy: function(t3) {
          Wo.prototype.copy.call(this, t3), this.curves = [];
          for (var e4 = 0, r3 = t3.curves.length; e4 < r3; e4++) {
            var n2 = t3.curves[e4];
            this.curves.push(n2.clone());
          }
          return this.autoClose = t3.autoClose, this;
        }, toJSON: function() {
          var t3 = Wo.prototype.toJSON.call(this);
          t3.autoClose = this.autoClose, t3.curves = [];
          for (var e4 = 0, r3 = this.curves.length; e4 < r3; e4++) {
            var n2 = this.curves[e4];
            t3.curves.push(n2.toJSON());
          }
          return t3;
        }, fromJSON: function(t3) {
          Wo.prototype.fromJSON.call(this, t3), this.autoClose = t3.autoClose, this.curves = [];
          for (var e4 = 0, r3 = t3.curves.length; e4 < r3; e4++) {
            var n2 = t3.curves[e4];
            this.curves.push(new hs[n2.type]().fromJSON(n2));
          }
          return this;
        } }), ps.prototype = Object.assign(Object.create(us.prototype), { constructor: ps, setFromPoints: function(t3) {
          this.moveTo(t3[0].x, t3[0].y);
          for (var e4 = 1, r3 = t3.length; e4 < r3; e4++)
            this.lineTo(t3[e4].x, t3[e4].y);
        }, moveTo: function(t3, e4) {
          this.currentPoint.set(t3, e4);
        }, lineTo: function(t3, e4) {
          var r3 = new as(this.currentPoint.clone(), new l3(t3, e4));
          this.curves.push(r3), this.currentPoint.set(t3, e4);
        }, quadraticCurveTo: function(t3, e4, r3, n2) {
          var i3 = new ss(this.currentPoint.clone(), new l3(t3, e4), new l3(r3, n2));
          this.curves.push(i3), this.currentPoint.set(r3, n2);
        }, bezierCurveTo: function(t3, e4, r3, n2, i3, a3) {
          var o5 = new ns(this.currentPoint.clone(), new l3(t3, e4), new l3(r3, n2), new l3(i3, a3));
          this.curves.push(o5), this.currentPoint.set(i3, a3);
        }, splineThru: function(t3) {
          var e4 = new ls([this.currentPoint.clone()].concat(t3));
          this.curves.push(e4), this.currentPoint.copy(t3[t3.length - 1]);
        }, arc: function(t3, e4, r3, n2, i3, a3) {
          var o5 = this.currentPoint.x, s4 = this.currentPoint.y;
          this.absarc(t3 + o5, e4 + s4, r3, n2, i3, a3);
        }, absarc: function(t3, e4, r3, n2, i3, a3) {
          this.absellipse(t3, e4, r3, r3, n2, i3, a3);
        }, ellipse: function(t3, e4, r3, n2, i3, a3, o5, s4) {
          var c3 = this.currentPoint.x, l4 = this.currentPoint.y;
          this.absellipse(t3 + c3, e4 + l4, r3, n2, i3, a3, o5, s4);
        }, absellipse: function(t3, e4, r3, n2, i3, a3, o5, s4) {
          var c3 = new qo(t3, e4, r3, n2, i3, a3, o5, s4);
          if (this.curves.length > 0) {
            var l4 = c3.getPoint(0);
            l4.equals(this.currentPoint) || this.lineTo(l4.x, l4.y);
          }
          this.curves.push(c3);
          var h3 = c3.getPoint(1);
          this.currentPoint.copy(h3);
        }, copy: function(t3) {
          return us.prototype.copy.call(this, t3), this.currentPoint.copy(t3.currentPoint), this;
        }, toJSON: function() {
          var t3 = us.prototype.toJSON.call(this);
          return t3.currentPoint = this.currentPoint.toArray(), t3;
        }, fromJSON: function(t3) {
          return us.prototype.fromJSON.call(this, t3), this.currentPoint.fromArray(t3.currentPoint), this;
        } }), ds.prototype = Object.assign(Object.create(ps.prototype), { constructor: ds, getPointsHoles: function(t3) {
          for (var e4 = [], r3 = 0, n2 = this.holes.length; r3 < n2; r3++)
            e4[r3] = this.holes[r3].getPoints(t3);
          return e4;
        }, extractPoints: function(t3) {
          return { shape: this.getPoints(t3), holes: this.getPointsHoles(t3) };
        }, copy: function(t3) {
          ps.prototype.copy.call(this, t3), this.holes = [];
          for (var e4 = 0, r3 = t3.holes.length; e4 < r3; e4++) {
            var n2 = t3.holes[e4];
            this.holes.push(n2.clone());
          }
          return this;
        }, toJSON: function() {
          var t3 = ps.prototype.toJSON.call(this);
          t3.uuid = this.uuid, t3.holes = [];
          for (var e4 = 0, r3 = this.holes.length; e4 < r3; e4++) {
            var n2 = this.holes[e4];
            t3.holes.push(n2.toJSON());
          }
          return t3;
        }, fromJSON: function(t3) {
          ps.prototype.fromJSON.call(this, t3), this.uuid = t3.uuid, this.holes = [];
          for (var e4 = 0, r3 = t3.holes.length; e4 < r3; e4++) {
            var n2 = t3.holes[e4];
            this.holes.push(new ps().fromJSON(n2));
          }
          return this;
        } }), fs.prototype = Object.assign(Object.create(Y.prototype), { constructor: fs, isLight: true, copy: function(t3) {
          return Y.prototype.copy.call(this, t3), this.color.copy(t3.color), this.intensity = t3.intensity, this;
        }, toJSON: function(t3) {
          var e4 = Y.prototype.toJSON.call(this, t3);
          return e4.object.color = this.color.getHex(), e4.object.intensity = this.intensity, this.groundColor !== void 0 && (e4.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e4.object.distance = this.distance), this.angle !== void 0 && (e4.object.angle = this.angle), this.decay !== void 0 && (e4.object.decay = this.decay), this.penumbra !== void 0 && (e4.object.penumbra = this.penumbra), this.shadow !== void 0 && (e4.object.shadow = this.shadow.toJSON()), e4;
        } }), ms.prototype = Object.assign(Object.create(fs.prototype), { constructor: ms, isHemisphereLight: true, copy: function(t3) {
          return fs.prototype.copy.call(this, t3), this.groundColor.copy(t3.groundColor), this;
        } }), Object.assign(gs.prototype, { _projScreenMatrix: new P2(), _lightPositionWorld: new d2(), _lookTarget: new d2(), getViewportCount: function() {
          return this._viewportCount;
        }, getFrustum: function() {
          return this._frustum;
        }, updateMatrices: function(t3) {
          var e4 = this.camera, r3 = this.matrix, n2 = this._projScreenMatrix, i3 = this._lookTarget, a3 = this._lightPositionWorld;
          a3.setFromMatrixPosition(t3.matrixWorld), e4.position.copy(a3), i3.setFromMatrixPosition(t3.target.matrixWorld), e4.lookAt(i3), e4.updateMatrixWorld(), n2.multiplyMatrices(e4.projectionMatrix, e4.matrixWorldInverse), this._frustum.setFromMatrix(n2), r3.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), r3.multiply(e4.projectionMatrix), r3.multiply(e4.matrixWorldInverse);
        }, getViewport: function(t3) {
          return this._viewports[t3];
        }, getFrameExtents: function() {
          return this._frameExtents;
        }, copy: function(t3) {
          return this.camera = t3.camera.clone(), this.bias = t3.bias, this.radius = t3.radius, this.mapSize.copy(t3.mapSize), this;
        }, clone: function() {
          return new this.constructor().copy(this);
        }, toJSON: function() {
          var t3 = {};
          return this.bias !== 0 && (t3.bias = this.bias), this.radius !== 1 && (t3.radius = this.radius), this.mapSize.x === 512 && this.mapSize.y === 512 || (t3.mapSize = this.mapSize.toArray()), t3.camera = this.camera.toJSON(false).object, delete t3.camera.matrix, t3;
        } }), vs.prototype = Object.assign(Object.create(gs.prototype), { constructor: vs, isSpotLightShadow: true, updateMatrices: function(t3, e4, r3) {
          var n2 = this.camera, i3 = 2 * s3.RAD2DEG * t3.angle, a3 = this.mapSize.width / this.mapSize.height, o5 = t3.distance || n2.far;
          i3 === n2.fov && a3 === n2.aspect && o5 === n2.far || (n2.fov = i3, n2.aspect = a3, n2.far = o5, n2.updateProjectionMatrix()), gs.prototype.updateMatrices.call(this, t3, e4, r3);
        } }), ys.prototype = Object.assign(Object.create(fs.prototype), { constructor: ys, isSpotLight: true, copy: function(t3) {
          return fs.prototype.copy.call(this, t3), this.distance = t3.distance, this.angle = t3.angle, this.penumbra = t3.penumbra, this.decay = t3.decay, this.target = t3.target.clone(), this.shadow = t3.shadow.clone(), this;
        } }), xs.prototype = Object.assign(Object.create(gs.prototype), { constructor: xs, isPointLightShadow: true, updateMatrices: function(t3, e4, r3) {
          var n2 = this.camera, i3 = this.matrix, a3 = this._lightPositionWorld, o5 = this._lookTarget, s4 = this._projScreenMatrix;
          a3.setFromMatrixPosition(t3.matrixWorld), n2.position.copy(a3), o5.copy(n2.position), o5.add(this._cubeDirections[r3]), n2.up.copy(this._cubeUps[r3]), n2.lookAt(o5), n2.updateMatrixWorld(), i3.makeTranslation(-a3.x, -a3.y, -a3.z), s4.multiplyMatrices(n2.projectionMatrix, n2.matrixWorldInverse), this._frustum.setFromMatrix(s4);
        } }), bs.prototype = Object.assign(Object.create(fs.prototype), { constructor: bs, isPointLight: true, copy: function(t3) {
          return fs.prototype.copy.call(this, t3), this.distance = t3.distance, this.decay = t3.decay, this.shadow = t3.shadow.clone(), this;
        } }), ws.prototype = Object.assign(Object.create(Ge.prototype), { constructor: ws, isOrthographicCamera: true, copy: function(t3, e4) {
          return Ge.prototype.copy.call(this, t3, e4), this.left = t3.left, this.right = t3.right, this.top = t3.top, this.bottom = t3.bottom, this.near = t3.near, this.far = t3.far, this.zoom = t3.zoom, this.view = t3.view === null ? null : Object.assign({}, t3.view), this;
        }, setViewOffset: function(t3, e4, r3, n2, i3, a3) {
          this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t3, this.view.fullHeight = e4, this.view.offsetX = r3, this.view.offsetY = n2, this.view.width = i3, this.view.height = a3, this.updateProjectionMatrix();
        }, clearViewOffset: function() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }, updateProjectionMatrix: function() {
          var t3 = (this.right - this.left) / (2 * this.zoom), e4 = (this.top - this.bottom) / (2 * this.zoom), r3 = (this.right + this.left) / 2, n2 = (this.top + this.bottom) / 2, i3 = r3 - t3, a3 = r3 + t3, o5 = n2 + e4, s4 = n2 - e4;
          if (this.view !== null && this.view.enabled) {
            var c3 = this.zoom / (this.view.width / this.view.fullWidth), l4 = this.zoom / (this.view.height / this.view.fullHeight), h3 = (this.right - this.left) / this.view.width, u3 = (this.top - this.bottom) / this.view.height;
            a3 = (i3 += h3 * (this.view.offsetX / c3)) + h3 * (this.view.width / c3), s4 = (o5 -= u3 * (this.view.offsetY / l4)) - u3 * (this.view.height / l4);
          }
          this.projectionMatrix.makeOrthographic(i3, a3, o5, s4, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        }, toJSON: function(t3) {
          var e4 = Y.prototype.toJSON.call(this, t3);
          return e4.object.zoom = this.zoom, e4.object.left = this.left, e4.object.right = this.right, e4.object.top = this.top, e4.object.bottom = this.bottom, e4.object.near = this.near, e4.object.far = this.far, this.view !== null && (e4.object.view = Object.assign({}, this.view)), e4;
        } }), _s.prototype = Object.assign(Object.create(gs.prototype), { constructor: _s, isDirectionalLightShadow: true, updateMatrices: function(t3, e4, r3) {
          gs.prototype.updateMatrices.call(this, t3, e4, r3);
        } }), Ms.prototype = Object.assign(Object.create(fs.prototype), { constructor: Ms, isDirectionalLight: true, copy: function(t3) {
          return fs.prototype.copy.call(this, t3), this.target = t3.target.clone(), this.shadow = t3.shadow.clone(), this;
        } }), Ss.prototype = Object.assign(Object.create(fs.prototype), { constructor: Ss, isAmbientLight: true }), Ts.prototype = Object.assign(Object.create(fs.prototype), { constructor: Ts, isRectAreaLight: true, copy: function(t3) {
          return fs.prototype.copy.call(this, t3), this.width = t3.width, this.height = t3.height, this;
        }, toJSON: function(t3) {
          var e4 = fs.prototype.toJSON.call(this, t3);
          return e4.object.width = this.width, e4.object.height = this.height, e4;
        } }), Es.prototype = Object.assign(Object.create(zo.prototype), { constructor: Es, load: function(t3, e4, r3, n2) {
          var i3 = this, a3 = new Fo(i3.manager);
          a3.setPath(i3.path), a3.load(t3, function(t4) {
            e4(i3.parse(JSON.parse(t4)));
          }, r3, n2);
        }, parse: function(t3) {
          var e4 = this.textures;
          function r3(t4) {
            return e4[t4] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", t4), e4[t4];
          }
          var n2 = new vo[t3.type]();
          if (t3.uuid !== void 0 && (n2.uuid = t3.uuid), t3.name !== void 0 && (n2.name = t3.name), t3.color !== void 0 && n2.color.setHex(t3.color), t3.roughness !== void 0 && (n2.roughness = t3.roughness), t3.metalness !== void 0 && (n2.metalness = t3.metalness), t3.emissive !== void 0 && n2.emissive.setHex(t3.emissive), t3.specular !== void 0 && n2.specular.setHex(t3.specular), t3.shininess !== void 0 && (n2.shininess = t3.shininess), t3.clearcoat !== void 0 && (n2.clearcoat = t3.clearcoat), t3.clearcoatRoughness !== void 0 && (n2.clearcoatRoughness = t3.clearcoatRoughness), t3.vertexColors !== void 0 && (n2.vertexColors = t3.vertexColors), t3.fog !== void 0 && (n2.fog = t3.fog), t3.flatShading !== void 0 && (n2.flatShading = t3.flatShading), t3.blending !== void 0 && (n2.blending = t3.blending), t3.combine !== void 0 && (n2.combine = t3.combine), t3.side !== void 0 && (n2.side = t3.side), t3.opacity !== void 0 && (n2.opacity = t3.opacity), t3.transparent !== void 0 && (n2.transparent = t3.transparent), t3.alphaTest !== void 0 && (n2.alphaTest = t3.alphaTest), t3.depthTest !== void 0 && (n2.depthTest = t3.depthTest), t3.depthWrite !== void 0 && (n2.depthWrite = t3.depthWrite), t3.colorWrite !== void 0 && (n2.colorWrite = t3.colorWrite), t3.wireframe !== void 0 && (n2.wireframe = t3.wireframe), t3.wireframeLinewidth !== void 0 && (n2.wireframeLinewidth = t3.wireframeLinewidth), t3.wireframeLinecap !== void 0 && (n2.wireframeLinecap = t3.wireframeLinecap), t3.wireframeLinejoin !== void 0 && (n2.wireframeLinejoin = t3.wireframeLinejoin), t3.rotation !== void 0 && (n2.rotation = t3.rotation), t3.linewidth !== 1 && (n2.linewidth = t3.linewidth), t3.dashSize !== void 0 && (n2.dashSize = t3.dashSize), t3.gapSize !== void 0 && (n2.gapSize = t3.gapSize), t3.scale !== void 0 && (n2.scale = t3.scale), t3.polygonOffset !== void 0 && (n2.polygonOffset = t3.polygonOffset), t3.polygonOffsetFactor !== void 0 && (n2.polygonOffsetFactor = t3.polygonOffsetFactor), t3.polygonOffsetUnits !== void 0 && (n2.polygonOffsetUnits = t3.polygonOffsetUnits), t3.skinning !== void 0 && (n2.skinning = t3.skinning), t3.morphTargets !== void 0 && (n2.morphTargets = t3.morphTargets), t3.morphNormals !== void 0 && (n2.morphNormals = t3.morphNormals), t3.dithering !== void 0 && (n2.dithering = t3.dithering), t3.visible !== void 0 && (n2.visible = t3.visible), t3.toneMapped !== void 0 && (n2.toneMapped = t3.toneMapped), t3.userData !== void 0 && (n2.userData = t3.userData), t3.uniforms !== void 0)
            for (var i3 in t3.uniforms) {
              var a3 = t3.uniforms[i3];
              switch (n2.uniforms[i3] = {}, a3.type) {
                case "t":
                  n2.uniforms[i3].value = r3(a3.value);
                  break;
                case "c":
                  n2.uniforms[i3].value = new Nt().setHex(a3.value);
                  break;
                case "v2":
                  n2.uniforms[i3].value = new l3().fromArray(a3.value);
                  break;
                case "v3":
                  n2.uniforms[i3].value = new d2().fromArray(a3.value);
                  break;
                case "v4":
                  n2.uniforms[i3].value = new x2().fromArray(a3.value);
                  break;
                case "m3":
                  n2.uniforms[i3].value = new m2().fromArray(a3.value);
                case "m4":
                  n2.uniforms[i3].value = new P2().fromArray(a3.value);
                  break;
                default:
                  n2.uniforms[i3].value = a3.value;
              }
            }
          if (t3.defines !== void 0 && (n2.defines = t3.defines), t3.vertexShader !== void 0 && (n2.vertexShader = t3.vertexShader), t3.fragmentShader !== void 0 && (n2.fragmentShader = t3.fragmentShader), t3.extensions !== void 0)
            for (var o5 in t3.extensions)
              n2.extensions[o5] = t3.extensions[o5];
          if (t3.shading !== void 0 && (n2.flatShading = t3.shading === 1), t3.size !== void 0 && (n2.size = t3.size), t3.sizeAttenuation !== void 0 && (n2.sizeAttenuation = t3.sizeAttenuation), t3.map !== void 0 && (n2.map = r3(t3.map)), t3.matcap !== void 0 && (n2.matcap = r3(t3.matcap)), t3.alphaMap !== void 0 && (n2.alphaMap = r3(t3.alphaMap), n2.transparent = true), t3.bumpMap !== void 0 && (n2.bumpMap = r3(t3.bumpMap)), t3.bumpScale !== void 0 && (n2.bumpScale = t3.bumpScale), t3.normalMap !== void 0 && (n2.normalMap = r3(t3.normalMap)), t3.normalMapType !== void 0 && (n2.normalMapType = t3.normalMapType), t3.normalScale !== void 0) {
            var s4 = t3.normalScale;
            Array.isArray(s4) === false && (s4 = [s4, s4]), n2.normalScale = new l3().fromArray(s4);
          }
          return t3.displacementMap !== void 0 && (n2.displacementMap = r3(t3.displacementMap)), t3.displacementScale !== void 0 && (n2.displacementScale = t3.displacementScale), t3.displacementBias !== void 0 && (n2.displacementBias = t3.displacementBias), t3.roughnessMap !== void 0 && (n2.roughnessMap = r3(t3.roughnessMap)), t3.metalnessMap !== void 0 && (n2.metalnessMap = r3(t3.metalnessMap)), t3.emissiveMap !== void 0 && (n2.emissiveMap = r3(t3.emissiveMap)), t3.emissiveIntensity !== void 0 && (n2.emissiveIntensity = t3.emissiveIntensity), t3.specularMap !== void 0 && (n2.specularMap = r3(t3.specularMap)), t3.envMap !== void 0 && (n2.envMap = r3(t3.envMap)), t3.envMapIntensity !== void 0 && (n2.envMapIntensity = t3.envMapIntensity), t3.reflectivity !== void 0 && (n2.reflectivity = t3.reflectivity), t3.refractionRatio !== void 0 && (n2.refractionRatio = t3.refractionRatio), t3.lightMap !== void 0 && (n2.lightMap = r3(t3.lightMap)), t3.lightMapIntensity !== void 0 && (n2.lightMapIntensity = t3.lightMapIntensity), t3.aoMap !== void 0 && (n2.aoMap = r3(t3.aoMap)), t3.aoMapIntensity !== void 0 && (n2.aoMapIntensity = t3.aoMapIntensity), t3.gradientMap !== void 0 && (n2.gradientMap = r3(t3.gradientMap)), t3.clearcoatNormalMap !== void 0 && (n2.clearcoatNormalMap = r3(t3.clearcoatNormalMap)), t3.clearcoatNormalScale !== void 0 && (n2.clearcoatNormalScale = new l3().fromArray(t3.clearcoatNormalScale)), n2;
        }, setTextures: function(t3) {
          return this.textures = t3, this;
        } });
        var As = { decodeText: function(t3) {
          if (typeof TextDecoder != "undefined")
            return new TextDecoder().decode(t3);
          for (var e4 = "", r3 = 0, n2 = t3.length; r3 < n2; r3++)
            e4 += String.fromCharCode(t3[r3]);
          try {
            return decodeURIComponent(escape(e4));
          } catch (t4) {
            return e4;
          }
        }, extractUrlBase: function(t3) {
          var e4 = t3.lastIndexOf("/");
          return e4 === -1 ? "./" : t3.substr(0, e4 + 1);
        } };
        function Ls() {
          se.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0;
        }
        function Rs(t3, e4, r3, n2) {
          typeof r3 == "number" && (n2 = r3, r3 = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Vt.call(this, t3, e4, r3), this.meshPerAttribute = n2 || 1;
        }
        function Ps(t3) {
          zo.call(this, t3);
        }
        Ls.prototype = Object.assign(Object.create(se.prototype), { constructor: Ls, isInstancedBufferGeometry: true, copy: function(t3) {
          return se.prototype.copy.call(this, t3), this.maxInstancedCount = t3.maxInstancedCount, this;
        }, clone: function() {
          return new this.constructor().copy(this);
        }, toJSON: function() {
          var t3 = se.prototype.toJSON.call(this);
          return t3.maxInstancedCount = this.maxInstancedCount, t3.isInstancedBufferGeometry = true, t3;
        } }), Rs.prototype = Object.assign(Object.create(Vt.prototype), { constructor: Rs, isInstancedBufferAttribute: true, copy: function(t3) {
          return Vt.prototype.copy.call(this, t3), this.meshPerAttribute = t3.meshPerAttribute, this;
        }, toJSON: function() {
          var t3 = Vt.prototype.toJSON.call(this);
          return t3.meshPerAttribute = this.meshPerAttribute, t3.isInstancedBufferAttribute = true, t3;
        } }), Ps.prototype = Object.assign(Object.create(zo.prototype), { constructor: Ps, load: function(t3, e4, r3, n2) {
          var i3 = this, a3 = new Fo(i3.manager);
          a3.setPath(i3.path), a3.load(t3, function(t4) {
            e4(i3.parse(JSON.parse(t4)));
          }, r3, n2);
        }, parse: function(t3) {
          var e4 = t3.isInstancedBufferGeometry ? new Ls() : new se(), r3 = t3.data.index;
          if (r3 !== void 0) {
            var n2 = new Cs[r3.type](r3.array);
            e4.setIndex(new Vt(n2, 1));
          }
          var i3 = t3.data.attributes;
          for (var a3 in i3) {
            var o5 = i3[a3], s4 = (n2 = new Cs[o5.type](o5.array), new (o5.isInstancedBufferAttribute ? Rs : Vt)(n2, o5.itemSize, o5.normalized));
            o5.name !== void 0 && (s4.name = o5.name), e4.addAttribute(a3, s4);
          }
          var c3 = t3.data.morphAttributes;
          if (c3)
            for (var a3 in c3) {
              for (var l4 = c3[a3], h3 = [], u3 = 0, p3 = l4.length; u3 < p3; u3++)
                o5 = l4[u3], s4 = new Vt(n2 = new Cs[o5.type](o5.array), o5.itemSize, o5.normalized), o5.name !== void 0 && (s4.name = o5.name), h3.push(s4);
              e4.morphAttributes[a3] = h3;
            }
          var f3 = t3.data.groups || t3.data.drawcalls || t3.data.offsets;
          if (f3 !== void 0) {
            u3 = 0;
            for (var m3 = f3.length; u3 !== m3; ++u3) {
              var g3 = f3[u3];
              e4.addGroup(g3.start, g3.count, g3.materialIndex);
            }
          }
          var v3 = t3.data.boundingSphere;
          if (v3 !== void 0) {
            var y3 = new d2();
            v3.center !== void 0 && y3.fromArray(v3.center), e4.boundingSphere = new ut(y3, v3.radius);
          }
          return t3.name && (e4.name = t3.name), t3.userData && (e4.userData = t3.userData), e4;
        } });
        var Cs = { Int8Array, Uint8Array, Uint8ClampedArray: typeof Uint8ClampedArray != "undefined" ? Uint8ClampedArray : Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
        function Os(t3) {
          zo.call(this, t3);
        }
        Os.prototype = Object.assign(Object.create(zo.prototype), { constructor: Os, load: function(t3, e4, r3, n2) {
          var i3 = this, a3 = this.path === "" ? As.extractUrlBase(t3) : this.path;
          this.resourcePath = this.resourcePath || a3;
          var o5 = new Fo(i3.manager);
          o5.setPath(this.path), o5.load(t3, function(r4) {
            var a4 = null;
            try {
              a4 = JSON.parse(r4);
            } catch (e5) {
              return n2 !== void 0 && n2(e5), void console.error("THREE:ObjectLoader: Can't parse " + t3 + ".", e5.message);
            }
            var o6 = a4.metadata;
            o6 !== void 0 && o6.type !== void 0 && o6.type.toLowerCase() !== "geometry" ? i3.parse(a4, e4) : console.error("THREE.ObjectLoader: Can't load " + t3);
          }, r3, n2);
        }, parse: function(t3, e4) {
          var r3 = this.parseShape(t3.shapes), n2 = this.parseGeometries(t3.geometries, r3), i3 = this.parseImages(t3.images, function() {
            e4 !== void 0 && e4(s4);
          }), a3 = this.parseTextures(t3.textures, i3), o5 = this.parseMaterials(t3.materials, a3), s4 = this.parseObject(t3.object, n2, o5);
          return t3.animations && (s4.animations = this.parseAnimations(t3.animations)), t3.images !== void 0 && t3.images.length !== 0 || e4 !== void 0 && e4(s4), s4;
        }, parseShape: function(t3) {
          var e4 = {};
          if (t3 !== void 0)
            for (var r3 = 0, n2 = t3.length; r3 < n2; r3++) {
              var i3 = new ds().fromJSON(t3[r3]);
              e4[i3.uuid] = i3;
            }
          return e4;
        }, parseGeometries: function(t3, e4) {
          var r3 = {};
          if (t3 !== void 0)
            for (var n2 = new Ps(), i3 = 0, o5 = t3.length; i3 < o5; i3++) {
              var s4, c3 = t3[i3];
              switch (c3.type) {
                case "PlaneGeometry":
                case "PlaneBufferGeometry":
                  s4 = new ao[c3.type](c3.width, c3.height, c3.widthSegments, c3.heightSegments);
                  break;
                case "BoxGeometry":
                case "BoxBufferGeometry":
                case "CubeGeometry":
                  s4 = new ao[c3.type](c3.width, c3.height, c3.depth, c3.widthSegments, c3.heightSegments, c3.depthSegments);
                  break;
                case "CircleGeometry":
                case "CircleBufferGeometry":
                  s4 = new ao[c3.type](c3.radius, c3.segments, c3.thetaStart, c3.thetaLength);
                  break;
                case "CylinderGeometry":
                case "CylinderBufferGeometry":
                  s4 = new ao[c3.type](c3.radiusTop, c3.radiusBottom, c3.height, c3.radialSegments, c3.heightSegments, c3.openEnded, c3.thetaStart, c3.thetaLength);
                  break;
                case "ConeGeometry":
                case "ConeBufferGeometry":
                  s4 = new ao[c3.type](c3.radius, c3.height, c3.radialSegments, c3.heightSegments, c3.openEnded, c3.thetaStart, c3.thetaLength);
                  break;
                case "SphereGeometry":
                case "SphereBufferGeometry":
                  s4 = new ao[c3.type](c3.radius, c3.widthSegments, c3.heightSegments, c3.phiStart, c3.phiLength, c3.thetaStart, c3.thetaLength);
                  break;
                case "DodecahedronGeometry":
                case "DodecahedronBufferGeometry":
                case "IcosahedronGeometry":
                case "IcosahedronBufferGeometry":
                case "OctahedronGeometry":
                case "OctahedronBufferGeometry":
                case "TetrahedronGeometry":
                case "TetrahedronBufferGeometry":
                  s4 = new ao[c3.type](c3.radius, c3.detail);
                  break;
                case "RingGeometry":
                case "RingBufferGeometry":
                  s4 = new ao[c3.type](c3.innerRadius, c3.outerRadius, c3.thetaSegments, c3.phiSegments, c3.thetaStart, c3.thetaLength);
                  break;
                case "TorusGeometry":
                case "TorusBufferGeometry":
                  s4 = new ao[c3.type](c3.radius, c3.tube, c3.radialSegments, c3.tubularSegments, c3.arc);
                  break;
                case "TorusKnotGeometry":
                case "TorusKnotBufferGeometry":
                  s4 = new ao[c3.type](c3.radius, c3.tube, c3.tubularSegments, c3.radialSegments, c3.p, c3.q);
                  break;
                case "TubeGeometry":
                case "TubeBufferGeometry":
                  s4 = new ao[c3.type](new hs[c3.path.type]().fromJSON(c3.path), c3.tubularSegments, c3.radius, c3.radialSegments, c3.closed);
                  break;
                case "LatheGeometry":
                case "LatheBufferGeometry":
                  s4 = new ao[c3.type](c3.points, c3.segments, c3.phiStart, c3.phiLength);
                  break;
                case "PolyhedronGeometry":
                case "PolyhedronBufferGeometry":
                  s4 = new ao[c3.type](c3.vertices, c3.indices, c3.radius, c3.details);
                  break;
                case "ShapeGeometry":
                case "ShapeBufferGeometry":
                  for (var l4 = [], h3 = 0, u3 = c3.shapes.length; h3 < u3; h3++) {
                    var p3 = e4[c3.shapes[h3]];
                    l4.push(p3);
                  }
                  s4 = new ao[c3.type](l4, c3.curveSegments);
                  break;
                case "ExtrudeGeometry":
                case "ExtrudeBufferGeometry":
                  for (l4 = [], h3 = 0, u3 = c3.shapes.length; h3 < u3; h3++)
                    p3 = e4[c3.shapes[h3]], l4.push(p3);
                  var d3 = c3.options.extrudePath;
                  d3 !== void 0 && (c3.options.extrudePath = new hs[d3.type]().fromJSON(d3)), s4 = new ao[c3.type](l4, c3.options);
                  break;
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  s4 = n2.parse(c3);
                  break;
                case "Geometry":
                  "THREE" in a2 && "LegacyJSONLoader" in THREE ? s4 = new THREE.LegacyJSONLoader().parse(c3, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                  break;
                default:
                  console.warn('THREE.ObjectLoader: Unsupported geometry type "' + c3.type + '"');
                  continue;
              }
              s4.uuid = c3.uuid, c3.name !== void 0 && (s4.name = c3.name), s4.isBufferGeometry === true && c3.userData !== void 0 && (s4.userData = c3.userData), r3[c3.uuid] = s4;
            }
          return r3;
        }, parseMaterials: function(t3, e4) {
          var r3 = {}, n2 = {};
          if (t3 !== void 0) {
            var i3 = new Es();
            i3.setTextures(e4);
            for (var a3 = 0, o5 = t3.length; a3 < o5; a3++) {
              var s4 = t3[a3];
              if (s4.type === "MultiMaterial") {
                for (var c3 = [], l4 = 0; l4 < s4.materials.length; l4++) {
                  var h3 = s4.materials[l4];
                  r3[h3.uuid] === void 0 && (r3[h3.uuid] = i3.parse(h3)), c3.push(r3[h3.uuid]);
                }
                n2[s4.uuid] = c3;
              } else
                r3[s4.uuid] === void 0 && (r3[s4.uuid] = i3.parse(s4)), n2[s4.uuid] = r3[s4.uuid];
            }
          }
          return n2;
        }, parseAnimations: function(t3) {
          for (var e4 = [], r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3], i3 = Co.parse(n2);
            n2.uuid !== void 0 && (i3.uuid = n2.uuid), e4.push(i3);
          }
          return e4;
        }, parseImages: function(t3, e4) {
          var r3 = this, n2 = {};
          function i3(t4) {
            return r3.manager.itemStart(t4), a3.load(t4, function() {
              r3.manager.itemEnd(t4);
            }, void 0, function() {
              r3.manager.itemError(t4), r3.manager.itemEnd(t4);
            });
          }
          if (t3 !== void 0 && t3.length > 0) {
            var a3 = new Vo(new No(e4));
            a3.setCrossOrigin(this.crossOrigin);
            for (var o5 = 0, s4 = t3.length; o5 < s4; o5++) {
              var c3 = t3[o5], l4 = c3.url;
              if (Array.isArray(l4)) {
                n2[c3.uuid] = [];
                for (var h3 = 0, u3 = l4.length; h3 < u3; h3++) {
                  var p3 = l4[h3], d3 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p3) ? p3 : r3.resourcePath + p3;
                  n2[c3.uuid].push(i3(d3));
                }
              } else
                d3 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c3.url) ? c3.url : r3.resourcePath + c3.url, n2[c3.uuid] = i3(d3);
            }
          }
          return n2;
        }, parseTextures: function(t3, e4) {
          function r3(t4, e5) {
            return typeof t4 == "number" ? t4 : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t4), e5[t4]);
          }
          var n2 = {};
          if (t3 !== void 0)
            for (var i3 = 0, a3 = t3.length; i3 < a3; i3++) {
              var o5, s4 = t3[i3];
              s4.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', s4.uuid), e4[s4.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", s4.image), (o5 = Array.isArray(e4[s4.image]) ? new mr(e4[s4.image]) : new y2(e4[s4.image])).needsUpdate = true, o5.uuid = s4.uuid, s4.name !== void 0 && (o5.name = s4.name), s4.mapping !== void 0 && (o5.mapping = r3(s4.mapping, Ns)), s4.offset !== void 0 && o5.offset.fromArray(s4.offset), s4.repeat !== void 0 && o5.repeat.fromArray(s4.repeat), s4.center !== void 0 && o5.center.fromArray(s4.center), s4.rotation !== void 0 && (o5.rotation = s4.rotation), s4.wrap !== void 0 && (o5.wrapS = r3(s4.wrap[0], Is), o5.wrapT = r3(s4.wrap[1], Is)), s4.format !== void 0 && (o5.format = s4.format), s4.type !== void 0 && (o5.type = s4.type), s4.encoding !== void 0 && (o5.encoding = s4.encoding), s4.minFilter !== void 0 && (o5.minFilter = r3(s4.minFilter, zs)), s4.magFilter !== void 0 && (o5.magFilter = r3(s4.magFilter, zs)), s4.anisotropy !== void 0 && (o5.anisotropy = s4.anisotropy), s4.flipY !== void 0 && (o5.flipY = s4.flipY), s4.premultiplyAlpha !== void 0 && (o5.premultiplyAlpha = s4.premultiplyAlpha), s4.unpackAlignment !== void 0 && (o5.unpackAlignment = s4.unpackAlignment), n2[s4.uuid] = o5;
            }
          return n2;
        }, parseObject: function(t3, e4, r3) {
          var n2;
          function i3(t4) {
            return e4[t4] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", t4), e4[t4];
          }
          function a3(t4) {
            if (t4 !== void 0) {
              if (Array.isArray(t4)) {
                for (var e5 = [], n3 = 0, i4 = t4.length; n3 < i4; n3++) {
                  var a4 = t4[n3];
                  r3[a4] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", a4), e5.push(r3[a4]);
                }
                return e5;
              }
              return r3[t4] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", t4), r3[t4];
            }
          }
          switch (t3.type) {
            case "Scene":
              n2 = new J(), t3.background !== void 0 && Number.isInteger(t3.background) && (n2.background = new Nt(t3.background)), t3.fog !== void 0 && (t3.fog.type === "Fog" ? n2.fog = new $n(t3.fog.color, t3.fog.near, t3.fog.far) : t3.fog.type === "FogExp2" && (n2.fog = new Kn(t3.fog.color, t3.fog.density)));
              break;
            case "PerspectiveCamera":
              n2 = new Ue(t3.fov, t3.aspect, t3.near, t3.far), t3.focus !== void 0 && (n2.focus = t3.focus), t3.zoom !== void 0 && (n2.zoom = t3.zoom), t3.filmGauge !== void 0 && (n2.filmGauge = t3.filmGauge), t3.filmOffset !== void 0 && (n2.filmOffset = t3.filmOffset), t3.view !== void 0 && (n2.view = Object.assign({}, t3.view));
              break;
            case "OrthographicCamera":
              n2 = new ws(t3.left, t3.right, t3.top, t3.bottom, t3.near, t3.far), t3.zoom !== void 0 && (n2.zoom = t3.zoom), t3.view !== void 0 && (n2.view = Object.assign({}, t3.view));
              break;
            case "AmbientLight":
              n2 = new Ss(t3.color, t3.intensity);
              break;
            case "DirectionalLight":
              n2 = new Ms(t3.color, t3.intensity);
              break;
            case "PointLight":
              n2 = new bs(t3.color, t3.intensity, t3.distance, t3.decay);
              break;
            case "RectAreaLight":
              n2 = new Ts(t3.color, t3.intensity, t3.width, t3.height);
              break;
            case "SpotLight":
              n2 = new ys(t3.color, t3.intensity, t3.distance, t3.angle, t3.penumbra, t3.decay);
              break;
            case "HemisphereLight":
              n2 = new ms(t3.color, t3.groundColor, t3.intensity);
              break;
            case "SkinnedMesh":
              console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
            case "Mesh":
              var o5 = i3(t3.geometry), s4 = a3(t3.material);
              n2 = o5.bones && o5.bones.length > 0 ? new bi(o5, s4) : new Te(o5, s4), t3.drawMode !== void 0 && n2.setDrawMode(t3.drawMode);
              break;
            case "LOD":
              n2 = new xi();
              break;
            case "Line":
              n2 = new Ci(i3(t3.geometry), a3(t3.material), t3.mode);
              break;
            case "LineLoop":
              n2 = new Ii(i3(t3.geometry), a3(t3.material));
              break;
            case "LineSegments":
              n2 = new Ni(i3(t3.geometry), a3(t3.material));
              break;
            case "PointCloud":
            case "Points":
              n2 = new Hi(i3(t3.geometry), a3(t3.material));
              break;
            case "Sprite":
              n2 = new mi(a3(t3.material));
              break;
            case "Group":
              n2 = new jn();
              break;
            default:
              n2 = new Y();
          }
          if (n2.uuid = t3.uuid, t3.name !== void 0 && (n2.name = t3.name), t3.matrix !== void 0 ? (n2.matrix.fromArray(t3.matrix), t3.matrixAutoUpdate !== void 0 && (n2.matrixAutoUpdate = t3.matrixAutoUpdate), n2.matrixAutoUpdate && n2.matrix.decompose(n2.position, n2.quaternion, n2.scale)) : (t3.position !== void 0 && n2.position.fromArray(t3.position), t3.rotation !== void 0 && n2.rotation.fromArray(t3.rotation), t3.quaternion !== void 0 && n2.quaternion.fromArray(t3.quaternion), t3.scale !== void 0 && n2.scale.fromArray(t3.scale)), t3.castShadow !== void 0 && (n2.castShadow = t3.castShadow), t3.receiveShadow !== void 0 && (n2.receiveShadow = t3.receiveShadow), t3.shadow && (t3.shadow.bias !== void 0 && (n2.shadow.bias = t3.shadow.bias), t3.shadow.radius !== void 0 && (n2.shadow.radius = t3.shadow.radius), t3.shadow.mapSize !== void 0 && n2.shadow.mapSize.fromArray(t3.shadow.mapSize), t3.shadow.camera !== void 0 && (n2.shadow.camera = this.parseObject(t3.shadow.camera))), t3.visible !== void 0 && (n2.visible = t3.visible), t3.frustumCulled !== void 0 && (n2.frustumCulled = t3.frustumCulled), t3.renderOrder !== void 0 && (n2.renderOrder = t3.renderOrder), t3.userData !== void 0 && (n2.userData = t3.userData), t3.layers !== void 0 && (n2.layers.mask = t3.layers), t3.children !== void 0)
            for (var c3 = t3.children, l4 = 0; l4 < c3.length; l4++)
              n2.add(this.parseObject(c3[l4], e4, r3));
          if (t3.type === "LOD")
            for (var h3 = t3.levels, u3 = 0; u3 < h3.length; u3++) {
              var p3 = h3[u3], d3 = n2.getObjectByProperty("uuid", p3.object);
              d3 !== void 0 && n2.addLevel(d3, p3.distance);
            }
          return n2;
        } });
        var Ds, Ns = { UVMapping: 300, CubeReflectionMapping: 301, CubeRefractionMapping: 302, EquirectangularReflectionMapping: 303, EquirectangularRefractionMapping: 304, SphericalReflectionMapping: 305, CubeUVReflectionMapping: 306, CubeUVRefractionMapping: 307 }, Is = { RepeatWrapping: 1e3, ClampToEdgeWrapping: 1001, MirroredRepeatWrapping: 1002 }, zs = { NearestFilter: 1003, NearestMipmapNearestFilter: 1004, NearestMipmapLinearFilter: 1005, LinearFilter: 1006, LinearMipmapNearestFilter: 1007, LinearMipmapLinearFilter: 1008 };
        function Bs(t3) {
          typeof createImageBitmap == "undefined" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch == "undefined" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), zo.call(this, t3), this.options = void 0;
        }
        function Fs() {
          this.type = "ShapePath", this.color = new Nt(), this.subPaths = [], this.currentPath = null;
        }
        function Gs(t3) {
          this.type = "Font", this.data = t3;
        }
        function Us(t3, e4, r3, n2, i3) {
          var a3 = i3.glyphs[t3] || i3.glyphs["?"];
          if (a3) {
            var o5, s4, c3, l4, h3, u3, p3, d3, f3 = new Fs();
            if (a3.o)
              for (var m3 = a3._cachedOutline || (a3._cachedOutline = a3.o.split(" ")), g3 = 0, v3 = m3.length; g3 < v3; )
                switch (m3[g3++]) {
                  case "m":
                    o5 = m3[g3++] * e4 + r3, s4 = m3[g3++] * e4 + n2, f3.moveTo(o5, s4);
                    break;
                  case "l":
                    o5 = m3[g3++] * e4 + r3, s4 = m3[g3++] * e4 + n2, f3.lineTo(o5, s4);
                    break;
                  case "q":
                    c3 = m3[g3++] * e4 + r3, l4 = m3[g3++] * e4 + n2, h3 = m3[g3++] * e4 + r3, u3 = m3[g3++] * e4 + n2, f3.quadraticCurveTo(h3, u3, c3, l4);
                    break;
                  case "b":
                    c3 = m3[g3++] * e4 + r3, l4 = m3[g3++] * e4 + n2, h3 = m3[g3++] * e4 + r3, u3 = m3[g3++] * e4 + n2, p3 = m3[g3++] * e4 + r3, d3 = m3[g3++] * e4 + n2, f3.bezierCurveTo(h3, u3, p3, d3, c3, l4);
                }
            return { offsetX: a3.ha * e4, path: f3 };
          }
          console.error('THREE.Font: character "' + t3 + '" does not exists in font family ' + i3.familyName + ".");
        }
        function Hs(t3) {
          zo.call(this, t3);
        }
        Bs.prototype = Object.assign(Object.create(zo.prototype), { constructor: Bs, setOptions: function(t3) {
          return this.options = t3, this;
        }, load: function(t3, e4, r3, n2) {
          t3 === void 0 && (t3 = ""), this.path !== void 0 && (t3 = this.path + t3), t3 = this.manager.resolveURL(t3);
          var i3 = this, a3 = Do.get(t3);
          if (a3 !== void 0)
            return i3.manager.itemStart(t3), setTimeout(function() {
              e4 && e4(a3), i3.manager.itemEnd(t3);
            }, 0), a3;
          fetch(t3).then(function(t4) {
            return t4.blob();
          }).then(function(t4) {
            return i3.options === void 0 ? createImageBitmap(t4) : createImageBitmap(t4, i3.options);
          }).then(function(r4) {
            Do.add(t3, r4), e4 && e4(r4), i3.manager.itemEnd(t3);
          }).catch(function(e5) {
            n2 && n2(e5), i3.manager.itemError(t3), i3.manager.itemEnd(t3);
          }), i3.manager.itemStart(t3);
        } }), Object.assign(Fs.prototype, { moveTo: function(t3, e4) {
          this.currentPath = new ps(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t3, e4);
        }, lineTo: function(t3, e4) {
          this.currentPath.lineTo(t3, e4);
        }, quadraticCurveTo: function(t3, e4, r3, n2) {
          this.currentPath.quadraticCurveTo(t3, e4, r3, n2);
        }, bezierCurveTo: function(t3, e4, r3, n2, i3, a3) {
          this.currentPath.bezierCurveTo(t3, e4, r3, n2, i3, a3);
        }, splineThru: function(t3) {
          this.currentPath.splineThru(t3);
        }, toShapes: function(t3, e4) {
          function r3(t4) {
            for (var e5 = [], r4 = 0, n3 = t4.length; r4 < n3; r4++) {
              var i4 = t4[r4], a4 = new ds();
              a4.curves = i4.curves, e5.push(a4);
            }
            return e5;
          }
          function n2(t4, e5) {
            for (var r4 = e5.length, n3 = false, i4 = r4 - 1, a4 = 0; a4 < r4; i4 = a4++) {
              var o6 = e5[i4], s5 = e5[a4], c4 = s5.x - o6.x, l5 = s5.y - o6.y;
              if (Math.abs(l5) > Number.EPSILON) {
                if (l5 < 0 && (o6 = e5[a4], c4 = -c4, s5 = e5[i4], l5 = -l5), t4.y < o6.y || t4.y > s5.y)
                  continue;
                if (t4.y === o6.y) {
                  if (t4.x === o6.x)
                    return true;
                } else {
                  var h4 = l5 * (t4.x - o6.x) - c4 * (t4.y - o6.y);
                  if (h4 === 0)
                    return true;
                  if (h4 < 0)
                    continue;
                  n3 = !n3;
                }
              } else {
                if (t4.y !== o6.y)
                  continue;
                if (s5.x <= t4.x && t4.x <= o6.x || o6.x <= t4.x && t4.x <= s5.x)
                  return true;
              }
            }
            return n3;
          }
          var i3 = Na.isClockWise, a3 = this.subPaths;
          if (a3.length === 0)
            return [];
          if (e4 === true)
            return r3(a3);
          var o5, s4, c3, l4 = [];
          if (a3.length === 1)
            return s4 = a3[0], (c3 = new ds()).curves = s4.curves, l4.push(c3), l4;
          var h3 = !i3(a3[0].getPoints());
          h3 = t3 ? !h3 : h3;
          var u3, p3, d3 = [], f3 = [], m3 = [], g3 = 0;
          f3[g3] = void 0, m3[g3] = [];
          for (var v3 = 0, y3 = a3.length; v3 < y3; v3++)
            o5 = i3(u3 = (s4 = a3[v3]).getPoints()), (o5 = t3 ? !o5 : o5) ? (!h3 && f3[g3] && g3++, f3[g3] = { s: new ds(), p: u3 }, f3[g3].s.curves = s4.curves, h3 && g3++, m3[g3] = []) : m3[g3].push({ h: s4, p: u3[0] });
          if (!f3[0])
            return r3(a3);
          if (f3.length > 1) {
            for (var x3 = false, b3 = [], w3 = 0, _3 = f3.length; w3 < _3; w3++)
              d3[w3] = [];
            for (w3 = 0, _3 = f3.length; w3 < _3; w3++)
              for (var M3 = m3[w3], S3 = 0; S3 < M3.length; S3++) {
                for (var T3 = M3[S3], E4 = true, A3 = 0; A3 < f3.length; A3++)
                  n2(T3.p, f3[A3].p) && (w3 !== A3 && b3.push({ froms: w3, tos: A3, hole: S3 }), E4 ? (E4 = false, d3[A3].push(T3)) : x3 = true);
                E4 && d3[w3].push(T3);
              }
            b3.length > 0 && (x3 || (m3 = d3));
          }
          v3 = 0;
          for (var L3 = f3.length; v3 < L3; v3++) {
            c3 = f3[v3].s, l4.push(c3);
            for (var R2 = 0, P3 = (p3 = m3[v3]).length; R2 < P3; R2++)
              c3.holes.push(p3[R2].h);
          }
          return l4;
        } }), Object.assign(Gs.prototype, { isFont: true, generateShapes: function(t3, e4) {
          e4 === void 0 && (e4 = 100);
          for (var r3 = [], n2 = function(t4, e5, r4) {
            for (var n3 = Array.from ? Array.from(t4) : String(t4).split(""), i4 = e5 / r4.resolution, a4 = (r4.boundingBox.yMax - r4.boundingBox.yMin + r4.underlineThickness) * i4, o5 = [], s4 = 0, c3 = 0, l4 = 0; l4 < n3.length; l4++) {
              var h3 = n3[l4];
              if (h3 === "\n")
                s4 = 0, c3 -= a4;
              else {
                var u3 = Us(h3, i4, s4, c3, r4);
                s4 += u3.offsetX, o5.push(u3.path);
              }
            }
            return o5;
          }(t3, e4, this.data), i3 = 0, a3 = n2.length; i3 < a3; i3++)
            Array.prototype.push.apply(r3, n2[i3].toShapes());
          return r3;
        } }), Hs.prototype = Object.assign(Object.create(zo.prototype), { constructor: Hs, load: function(t3, e4, r3, n2) {
          var i3 = this, a3 = new Fo(this.manager);
          a3.setPath(this.path), a3.load(t3, function(t4) {
            var r4;
            try {
              r4 = JSON.parse(t4);
            } catch (e5) {
              console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), r4 = JSON.parse(t4.substring(65, t4.length - 2));
            }
            var n3 = i3.parse(r4);
            e4 && e4(n3);
          }, r3, n2);
        }, parse: function(t3) {
          return new Gs(t3);
        } });
        var Vs = { getContext: function() {
          return Ds === void 0 && (Ds = new (a2.AudioContext || a2.webkitAudioContext)()), Ds;
        }, setContext: function(t3) {
          Ds = t3;
        } };
        function js(t3) {
          zo.call(this, t3);
        }
        function ks() {
          this.coefficients = [];
          for (var t3 = 0; t3 < 9; t3++)
            this.coefficients.push(new d2());
        }
        function Ws(t3, e4) {
          fs.call(this, void 0, e4), this.sh = t3 !== void 0 ? t3 : new ks();
        }
        function qs(t3, e4, r3) {
          Ws.call(this, void 0, r3);
          var n2 = new Nt().set(t3), i3 = new Nt().set(e4), a3 = new d2(n2.r, n2.g, n2.b), o5 = new d2(i3.r, i3.g, i3.b), s4 = Math.sqrt(Math.PI), c3 = s4 * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(a3).add(o5).multiplyScalar(s4), this.sh.coefficients[1].copy(a3).sub(o5).multiplyScalar(c3);
        }
        function Xs(t3, e4) {
          Ws.call(this, void 0, e4);
          var r3 = new Nt().set(t3);
          this.sh.coefficients[0].set(r3.r, r3.g, r3.b).multiplyScalar(2 * Math.sqrt(Math.PI));
        }
        js.prototype = Object.assign(Object.create(zo.prototype), { constructor: js, load: function(t3, e4, r3, n2) {
          var i3 = new Fo(this.manager);
          i3.setResponseType("arraybuffer"), i3.setPath(this.path), i3.load(t3, function(t4) {
            var r4 = t4.slice(0);
            Vs.getContext().decodeAudioData(r4, function(t5) {
              e4(t5);
            });
          }, r3, n2);
        } }), Object.assign(ks.prototype, { isSphericalHarmonics3: true, set: function(t3) {
          for (var e4 = 0; e4 < 9; e4++)
            this.coefficients[e4].copy(t3[e4]);
          return this;
        }, zero: function() {
          for (var t3 = 0; t3 < 9; t3++)
            this.coefficients[t3].set(0, 0, 0);
          return this;
        }, getAt: function(t3, e4) {
          var r3 = t3.x, n2 = t3.y, i3 = t3.z, a3 = this.coefficients;
          return e4.copy(a3[0]).multiplyScalar(0.282095), e4.addScale(a3[1], 0.488603 * n2), e4.addScale(a3[2], 0.488603 * i3), e4.addScale(a3[3], 0.488603 * r3), e4.addScale(a3[4], r3 * n2 * 1.092548), e4.addScale(a3[5], n2 * i3 * 1.092548), e4.addScale(a3[6], 0.315392 * (3 * i3 * i3 - 1)), e4.addScale(a3[7], r3 * i3 * 1.092548), e4.addScale(a3[8], 0.546274 * (r3 * r3 - n2 * n2)), e4;
        }, getIrradianceAt: function(t3, e4) {
          var r3 = t3.x, n2 = t3.y, i3 = t3.z, a3 = this.coefficients;
          return e4.copy(a3[0]).multiplyScalar(0.886227), e4.addScale(a3[1], 1.023328 * n2), e4.addScale(a3[2], 1.023328 * i3), e4.addScale(a3[3], 1.023328 * r3), e4.addScale(a3[4], 0.858086 * r3 * n2), e4.addScale(a3[5], 0.858086 * n2 * i3), e4.addScale(a3[6], 0.743125 * i3 * i3 - 0.247708), e4.addScale(a3[7], 0.858086 * r3 * i3), e4.addScale(a3[8], 0.429043 * (r3 * r3 - n2 * n2)), e4;
        }, add: function(t3) {
          for (var e4 = 0; e4 < 9; e4++)
            this.coefficients[e4].add(t3.coefficients[e4]);
          return this;
        }, scale: function(t3) {
          for (var e4 = 0; e4 < 9; e4++)
            this.coefficients[e4].multiplyScalar(t3);
          return this;
        }, lerp: function(t3, e4) {
          for (var r3 = 0; r3 < 9; r3++)
            this.coefficients[r3].lerp(t3.coefficients[r3], e4);
          return this;
        }, equals: function(t3) {
          for (var e4 = 0; e4 < 9; e4++)
            if (!this.coefficients[e4].equals(t3.coefficients[e4]))
              return false;
          return true;
        }, copy: function(t3) {
          return this.set(t3.coefficients);
        }, clone: function() {
          return new this.constructor().copy(this);
        }, fromArray: function(t3, e4) {
          e4 === void 0 && (e4 = 0);
          for (var r3 = this.coefficients, n2 = 0; n2 < 9; n2++)
            r3[n2].fromArray(t3, e4 + 3 * n2);
          return this;
        }, toArray: function(t3, e4) {
          t3 === void 0 && (t3 = []), e4 === void 0 && (e4 = 0);
          for (var r3 = this.coefficients, n2 = 0; n2 < 9; n2++)
            r3[n2].toArray(t3, e4 + 3 * n2);
          return t3;
        } }), Object.assign(ks, { getBasisAt: function(t3, e4) {
          var r3 = t3.x, n2 = t3.y, i3 = t3.z;
          e4[0] = 0.282095, e4[1] = 0.488603 * n2, e4[2] = 0.488603 * i3, e4[3] = 0.488603 * r3, e4[4] = 1.092548 * r3 * n2, e4[5] = 1.092548 * n2 * i3, e4[6] = 0.315392 * (3 * i3 * i3 - 1), e4[7] = 1.092548 * r3 * i3, e4[8] = 0.546274 * (r3 * r3 - n2 * n2);
        } }), Ws.prototype = Object.assign(Object.create(fs.prototype), { constructor: Ws, isLightProbe: true, copy: function(t3) {
          return fs.prototype.copy.call(this, t3), this.sh.copy(t3.sh), this.intensity = t3.intensity, this;
        }, toJSON: function(t3) {
          return fs.prototype.toJSON.call(this, t3);
        } }), qs.prototype = Object.assign(Object.create(Ws.prototype), { constructor: qs, isHemisphereLightProbe: true, copy: function(t3) {
          return Ws.prototype.copy.call(this, t3), this;
        }, toJSON: function(t3) {
          return Ws.prototype.toJSON.call(this, t3);
        } }), Xs.prototype = Object.assign(Object.create(Ws.prototype), { constructor: Xs, isAmbientLightProbe: true, copy: function(t3) {
          return Ws.prototype.copy.call(this, t3), this;
        }, toJSON: function(t3) {
          return Ws.prototype.toJSON.call(this, t3);
        } });
        var Ys = new P2(), Js = new P2();
        function Zs() {
          this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Ue(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new Ue(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
        }
        function Qs(t3) {
          this.autoStart = t3 === void 0 || t3, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
        }
        Object.assign(Zs.prototype, { update: function(t3) {
          var e4 = this._cache;
          if (e4.focus !== t3.focus || e4.fov !== t3.fov || e4.aspect !== t3.aspect * this.aspect || e4.near !== t3.near || e4.far !== t3.far || e4.zoom !== t3.zoom || e4.eyeSep !== this.eyeSep) {
            e4.focus = t3.focus, e4.fov = t3.fov, e4.aspect = t3.aspect * this.aspect, e4.near = t3.near, e4.far = t3.far, e4.zoom = t3.zoom, e4.eyeSep = this.eyeSep;
            var r3, n2, i3 = t3.projectionMatrix.clone(), a3 = e4.eyeSep / 2, o5 = a3 * e4.near / e4.focus, c3 = e4.near * Math.tan(s3.DEG2RAD * e4.fov * 0.5) / e4.zoom;
            Js.elements[12] = -a3, Ys.elements[12] = a3, r3 = -c3 * e4.aspect + o5, n2 = c3 * e4.aspect + o5, i3.elements[0] = 2 * e4.near / (n2 - r3), i3.elements[8] = (n2 + r3) / (n2 - r3), this.cameraL.projectionMatrix.copy(i3), r3 = -c3 * e4.aspect - o5, n2 = c3 * e4.aspect - o5, i3.elements[0] = 2 * e4.near / (n2 - r3), i3.elements[8] = (n2 + r3) / (n2 - r3), this.cameraR.projectionMatrix.copy(i3);
          }
          this.cameraL.matrixWorld.copy(t3.matrixWorld).multiply(Js), this.cameraR.matrixWorld.copy(t3.matrixWorld).multiply(Ys);
        } }), Object.assign(Qs.prototype, { start: function() {
          this.startTime = (typeof performance == "undefined" ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
        }, stop: function() {
          this.getElapsedTime(), this.running = false, this.autoStart = false;
        }, getElapsedTime: function() {
          return this.getDelta(), this.elapsedTime;
        }, getDelta: function() {
          var t3 = 0;
          if (this.autoStart && !this.running)
            return this.start(), 0;
          if (this.running) {
            var e4 = (typeof performance == "undefined" ? Date : performance).now();
            t3 = (e4 - this.oldTime) / 1e3, this.oldTime = e4, this.elapsedTime += t3;
          }
          return t3;
        } });
        var Ks = new d2(), $s = new h2(), tc = new d2(), ec = new d2();
        function rc() {
          Y.call(this), this.type = "AudioListener", this.context = Vs.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Qs();
        }
        function nc(t3) {
          Y.call(this), this.type = "Audio", this.listener = t3, this.context = t3.context, this.gain = this.context.createGain(), this.gain.connect(t3.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.startTime = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.sourceType = "empty", this.filters = [];
        }
        rc.prototype = Object.assign(Object.create(Y.prototype), { constructor: rc, getInput: function() {
          return this.gain;
        }, removeFilter: function() {
          return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
        }, getFilter: function() {
          return this.filter;
        }, setFilter: function(t3) {
          return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t3, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
        }, getMasterVolume: function() {
          return this.gain.gain.value;
        }, setMasterVolume: function(t3) {
          return this.gain.gain.setTargetAtTime(t3, this.context.currentTime, 0.01), this;
        }, updateMatrixWorld: function(t3) {
          Y.prototype.updateMatrixWorld.call(this, t3);
          var e4 = this.context.listener, r3 = this.up;
          if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Ks, $s, tc), ec.set(0, 0, -1).applyQuaternion($s), e4.positionX) {
            var n2 = this.context.currentTime + this.timeDelta;
            e4.positionX.linearRampToValueAtTime(Ks.x, n2), e4.positionY.linearRampToValueAtTime(Ks.y, n2), e4.positionZ.linearRampToValueAtTime(Ks.z, n2), e4.forwardX.linearRampToValueAtTime(ec.x, n2), e4.forwardY.linearRampToValueAtTime(ec.y, n2), e4.forwardZ.linearRampToValueAtTime(ec.z, n2), e4.upX.linearRampToValueAtTime(r3.x, n2), e4.upY.linearRampToValueAtTime(r3.y, n2), e4.upZ.linearRampToValueAtTime(r3.z, n2);
          } else
            e4.setPosition(Ks.x, Ks.y, Ks.z), e4.setOrientation(ec.x, ec.y, ec.z, r3.x, r3.y, r3.z);
        } }), nc.prototype = Object.assign(Object.create(Y.prototype), { constructor: nc, getOutput: function() {
          return this.gain;
        }, setNodeSource: function(t3) {
          return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = t3, this.connect(), this;
        }, setMediaElementSource: function(t3) {
          return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t3), this.connect(), this;
        }, setBuffer: function(t3) {
          return this.buffer = t3, this.sourceType = "buffer", this.autoplay && this.play(), this;
        }, play: function() {
          if (this.isPlaying !== true) {
            if (this.hasPlaybackControl !== false) {
              var t3 = this.context.createBufferSource();
              return t3.buffer = this.buffer, t3.loop = this.loop, t3.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, t3.start(this.startTime, this.offset, this.duration), this.isPlaying = true, this.source = t3, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
            }
            console.warn("THREE.Audio: this Audio has no playback control.");
          } else
            console.warn("THREE.Audio: Audio is already playing.");
        }, pause: function() {
          if (this.hasPlaybackControl !== false)
            return this.isPlaying === true && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = false), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }, stop: function() {
          if (this.hasPlaybackControl !== false)
            return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = false, this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }, connect: function() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (var t3 = 1, e4 = this.filters.length; t3 < e4; t3++)
              this.filters[t3 - 1].connect(this.filters[t3]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else
            this.source.connect(this.getOutput());
          return this;
        }, disconnect: function() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (var t3 = 1, e4 = this.filters.length; t3 < e4; t3++)
              this.filters[t3 - 1].disconnect(this.filters[t3]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else
            this.source.disconnect(this.getOutput());
          return this;
        }, getFilters: function() {
          return this.filters;
        }, setFilters: function(t3) {
          return t3 || (t3 = []), this.isPlaying === true ? (this.disconnect(), this.filters = t3, this.connect()) : this.filters = t3, this;
        }, setDetune: function(t3) {
          if (this.detune = t3, this.source.detune !== void 0)
            return this.isPlaying === true && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
        }, getDetune: function() {
          return this.detune;
        }, getFilter: function() {
          return this.getFilters()[0];
        }, setFilter: function(t3) {
          return this.setFilters(t3 ? [t3] : []);
        }, setPlaybackRate: function(t3) {
          if (this.hasPlaybackControl !== false)
            return this.playbackRate = t3, this.isPlaying === true && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }, getPlaybackRate: function() {
          return this.playbackRate;
        }, onEnded: function() {
          this.isPlaying = false;
        }, getLoop: function() {
          return this.hasPlaybackControl === false ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
        }, setLoop: function(t3) {
          if (this.hasPlaybackControl !== false)
            return this.loop = t3, this.isPlaying === true && (this.source.loop = this.loop), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }, getVolume: function() {
          return this.gain.gain.value;
        }, setVolume: function(t3) {
          return this.gain.gain.setTargetAtTime(t3, this.context.currentTime, 0.01), this;
        } });
        var ic = new d2(), ac = new h2(), oc = new d2(), sc = new d2();
        function cc(t3) {
          nc.call(this, t3), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
        }
        function lc(t3, e4) {
          this.analyser = t3.context.createAnalyser(), this.analyser.fftSize = e4 !== void 0 ? e4 : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t3.getOutput().connect(this.analyser);
        }
        function hc(t3, e4, r3) {
          this.binding = t3, this.valueSize = r3;
          var n2, i3 = Float64Array;
          switch (e4) {
            case "quaternion":
              n2 = this._slerp;
              break;
            case "string":
            case "bool":
              i3 = Array, n2 = this._select;
              break;
            default:
              n2 = this._lerp;
          }
          this.buffer = new i3(4 * r3), this._mixBufferRegion = n2, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0;
        }
        cc.prototype = Object.assign(Object.create(nc.prototype), { constructor: cc, getOutput: function() {
          return this.panner;
        }, getRefDistance: function() {
          return this.panner.refDistance;
        }, setRefDistance: function(t3) {
          return this.panner.refDistance = t3, this;
        }, getRolloffFactor: function() {
          return this.panner.rolloffFactor;
        }, setRolloffFactor: function(t3) {
          return this.panner.rolloffFactor = t3, this;
        }, getDistanceModel: function() {
          return this.panner.distanceModel;
        }, setDistanceModel: function(t3) {
          return this.panner.distanceModel = t3, this;
        }, getMaxDistance: function() {
          return this.panner.maxDistance;
        }, setMaxDistance: function(t3) {
          return this.panner.maxDistance = t3, this;
        }, setDirectionalCone: function(t3, e4, r3) {
          return this.panner.coneInnerAngle = t3, this.panner.coneOuterAngle = e4, this.panner.coneOuterGain = r3, this;
        }, updateMatrixWorld: function(t3) {
          if (Y.prototype.updateMatrixWorld.call(this, t3), this.hasPlaybackControl !== true || this.isPlaying !== false) {
            this.matrixWorld.decompose(ic, ac, oc), sc.set(0, 0, 1).applyQuaternion(ac);
            var e4 = this.panner;
            if (e4.positionX) {
              var r3 = this.context.currentTime + this.listener.timeDelta;
              e4.positionX.linearRampToValueAtTime(ic.x, r3), e4.positionY.linearRampToValueAtTime(ic.y, r3), e4.positionZ.linearRampToValueAtTime(ic.z, r3), e4.orientationX.linearRampToValueAtTime(sc.x, r3), e4.orientationY.linearRampToValueAtTime(sc.y, r3), e4.orientationZ.linearRampToValueAtTime(sc.z, r3);
            } else
              e4.setPosition(ic.x, ic.y, ic.z), e4.setOrientation(sc.x, sc.y, sc.z);
          }
        } }), Object.assign(lc.prototype, { getFrequencyData: function() {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        }, getAverageFrequency: function() {
          for (var t3 = 0, e4 = this.getFrequencyData(), r3 = 0; r3 < e4.length; r3++)
            t3 += e4[r3];
          return t3 / e4.length;
        } }), Object.assign(hc.prototype, { accumulate: function(t3, e4) {
          var r3 = this.buffer, n2 = this.valueSize, i3 = t3 * n2 + n2, a3 = this.cumulativeWeight;
          if (a3 === 0) {
            for (var o5 = 0; o5 !== n2; ++o5)
              r3[i3 + o5] = r3[o5];
            a3 = e4;
          } else {
            var s4 = e4 / (a3 += e4);
            this._mixBufferRegion(r3, i3, 0, s4, n2);
          }
          this.cumulativeWeight = a3;
        }, apply: function(t3) {
          var e4 = this.valueSize, r3 = this.buffer, n2 = t3 * e4 + e4, i3 = this.cumulativeWeight, a3 = this.binding;
          if (this.cumulativeWeight = 0, i3 < 1) {
            var o5 = 3 * e4;
            this._mixBufferRegion(r3, n2, o5, 1 - i3, e4);
          }
          for (var s4 = e4, c3 = e4 + e4; s4 !== c3; ++s4)
            if (r3[s4] !== r3[s4 + e4]) {
              a3.setValue(r3, n2);
              break;
            }
        }, saveOriginalState: function() {
          var t3 = this.binding, e4 = this.buffer, r3 = this.valueSize, n2 = 3 * r3;
          t3.getValue(e4, n2);
          for (var i3 = r3, a3 = n2; i3 !== a3; ++i3)
            e4[i3] = e4[n2 + i3 % r3];
          this.cumulativeWeight = 0;
        }, restoreOriginalState: function() {
          var t3 = 3 * this.valueSize;
          this.binding.setValue(this.buffer, t3);
        }, _select: function(t3, e4, r3, n2, i3) {
          if (n2 >= 0.5)
            for (var a3 = 0; a3 !== i3; ++a3)
              t3[e4 + a3] = t3[r3 + a3];
        }, _slerp: function(t3, e4, r3, n2) {
          h2.slerpFlat(t3, e4, t3, e4, t3, r3, n2);
        }, _lerp: function(t3, e4, r3, n2, i3) {
          for (var a3 = 1 - n2, o5 = 0; o5 !== i3; ++o5) {
            var s4 = e4 + o5;
            t3[s4] = t3[s4] * a3 + t3[r3 + o5] * n2;
          }
        } });
        var uc = new RegExp("[\\[\\]\\.:\\/]", "g"), pc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", dc = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), fc = /(WCOD+)?/.source.replace("WCOD", pc), mc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), gc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), vc = new RegExp("^" + dc + fc + mc + gc + "$"), yc = ["material", "materials", "bones"];
        function xc(t3, e4, r3) {
          var n2 = r3 || bc.parseTrackName(e4);
          this._targetGroup = t3, this._bindings = t3.subscribe_(e4, n2);
        }
        function bc(t3, e4, r3) {
          this.path = e4, this.parsedPath = r3 || bc.parseTrackName(e4), this.node = bc.findNode(t3, this.parsedPath.nodeName) || t3, this.rootNode = t3;
        }
        function wc() {
          this.uuid = s3.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
          var t3 = {};
          this._indicesByUUID = t3;
          for (var e4 = 0, r3 = arguments.length; e4 !== r3; ++e4)
            t3[arguments[e4].uuid] = e4;
          this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
          var n2 = this;
          this.stats = { objects: { get total() {
            return n2._objects.length;
          }, get inUse() {
            return this.total - n2.nCachedObjects_;
          } }, get bindingsPerObject() {
            return n2._bindings.length;
          } };
        }
        function _c(t3, e4, r3) {
          this._mixer = t3, this._clip = e4, this._localRoot = r3 || null;
          for (var n2 = e4.tracks, i3 = n2.length, a3 = new Array(i3), o5 = { endingStart: 2400, endingEnd: 2400 }, s4 = 0; s4 !== i3; ++s4) {
            var c3 = n2[s4].createInterpolant(null);
            a3[s4] = c3, c3.settings = o5;
          }
          this._interpolantSettings = o5, this._interpolants = a3, this._propertyBindings = new Array(i3), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
        }
        function Mc(t3) {
          this._root = t3, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
        }
        function Sc(t3) {
          typeof t3 == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t3 = arguments[1]), this.value = t3;
        }
        function Tc(t3, e4, r3) {
          ti.call(this, t3, e4), this.meshPerAttribute = r3 || 1;
        }
        function Ec(t3, e4, r3, n2) {
          this.ray = new xt(t3, e4), this.near = r3 || 0, this.far = n2 || 1 / 0, this.camera = null, this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function() {
            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points;
          } } });
        }
        function Ac(t3, e4) {
          return t3.distance - e4.distance;
        }
        function Lc(t3, e4, r3, n2) {
          if (t3.visible !== false && (t3.raycast(e4, r3), n2 === true))
            for (var i3 = t3.children, a3 = 0, o5 = i3.length; a3 < o5; a3++)
              Lc(i3[a3], e4, r3, true);
        }
        function Rc(t3, e4, r3) {
          return this.radius = t3 !== void 0 ? t3 : 1, this.phi = e4 !== void 0 ? e4 : 0, this.theta = r3 !== void 0 ? r3 : 0, this;
        }
        function Pc(t3, e4, r3) {
          return this.radius = t3 !== void 0 ? t3 : 1, this.theta = e4 !== void 0 ? e4 : 0, this.y = r3 !== void 0 ? r3 : 0, this;
        }
        Object.assign(xc.prototype, { getValue: function(t3, e4) {
          this.bind();
          var r3 = this._targetGroup.nCachedObjects_, n2 = this._bindings[r3];
          n2 !== void 0 && n2.getValue(t3, e4);
        }, setValue: function(t3, e4) {
          for (var r3 = this._bindings, n2 = this._targetGroup.nCachedObjects_, i3 = r3.length; n2 !== i3; ++n2)
            r3[n2].setValue(t3, e4);
        }, bind: function() {
          for (var t3 = this._bindings, e4 = this._targetGroup.nCachedObjects_, r3 = t3.length; e4 !== r3; ++e4)
            t3[e4].bind();
        }, unbind: function() {
          for (var t3 = this._bindings, e4 = this._targetGroup.nCachedObjects_, r3 = t3.length; e4 !== r3; ++e4)
            t3[e4].unbind();
        } }), Object.assign(bc, { Composite: xc, create: function(t3, e4, r3) {
          return t3 && t3.isAnimationObjectGroup ? new bc.Composite(t3, e4, r3) : new bc(t3, e4, r3);
        }, sanitizeNodeName: function(t3) {
          return t3.replace(/\s/g, "_").replace(uc, "");
        }, parseTrackName: function(t3) {
          var e4 = vc.exec(t3);
          if (!e4)
            throw new Error("PropertyBinding: Cannot parse trackName: " + t3);
          var r3 = { nodeName: e4[2], objectName: e4[3], objectIndex: e4[4], propertyName: e4[5], propertyIndex: e4[6] }, n2 = r3.nodeName && r3.nodeName.lastIndexOf(".");
          if (n2 !== void 0 && n2 !== -1) {
            var i3 = r3.nodeName.substring(n2 + 1);
            yc.indexOf(i3) !== -1 && (r3.nodeName = r3.nodeName.substring(0, n2), r3.objectName = i3);
          }
          if (r3.propertyName === null || r3.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t3);
          return r3;
        }, findNode: function(t3, e4) {
          if (!e4 || e4 === "" || e4 === "root" || e4 === "." || e4 === -1 || e4 === t3.name || e4 === t3.uuid)
            return t3;
          if (t3.skeleton) {
            var r3 = t3.skeleton.getBoneByName(e4);
            if (r3 !== void 0)
              return r3;
          }
          if (t3.children) {
            var n2 = function t4(r4) {
              for (var n3 = 0; n3 < r4.length; n3++) {
                var i3 = r4[n3];
                if (i3.name === e4 || i3.uuid === e4)
                  return i3;
                var a3 = t4(i3.children);
                if (a3)
                  return a3;
              }
              return null;
            }(t3.children);
            if (n2)
              return n2;
          }
          return null;
        } }), Object.assign(bc.prototype, { _getValue_unavailable: function() {
        }, _setValue_unavailable: function() {
        }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function(t3, e4) {
          t3[e4] = this.node[this.propertyName];
        }, function(t3, e4) {
          for (var r3 = this.resolvedProperty, n2 = 0, i3 = r3.length; n2 !== i3; ++n2)
            t3[e4++] = r3[n2];
        }, function(t3, e4) {
          t3[e4] = this.resolvedProperty[this.propertyIndex];
        }, function(t3, e4) {
          this.resolvedProperty.toArray(t3, e4);
        }], SetterByBindingTypeAndVersioning: [[function(t3, e4) {
          this.targetObject[this.propertyName] = t3[e4];
        }, function(t3, e4) {
          this.targetObject[this.propertyName] = t3[e4], this.targetObject.needsUpdate = true;
        }, function(t3, e4) {
          this.targetObject[this.propertyName] = t3[e4], this.targetObject.matrixWorldNeedsUpdate = true;
        }], [function(t3, e4) {
          for (var r3 = this.resolvedProperty, n2 = 0, i3 = r3.length; n2 !== i3; ++n2)
            r3[n2] = t3[e4++];
        }, function(t3, e4) {
          for (var r3 = this.resolvedProperty, n2 = 0, i3 = r3.length; n2 !== i3; ++n2)
            r3[n2] = t3[e4++];
          this.targetObject.needsUpdate = true;
        }, function(t3, e4) {
          for (var r3 = this.resolvedProperty, n2 = 0, i3 = r3.length; n2 !== i3; ++n2)
            r3[n2] = t3[e4++];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }], [function(t3, e4) {
          this.resolvedProperty[this.propertyIndex] = t3[e4];
        }, function(t3, e4) {
          this.resolvedProperty[this.propertyIndex] = t3[e4], this.targetObject.needsUpdate = true;
        }, function(t3, e4) {
          this.resolvedProperty[this.propertyIndex] = t3[e4], this.targetObject.matrixWorldNeedsUpdate = true;
        }], [function(t3, e4) {
          this.resolvedProperty.fromArray(t3, e4);
        }, function(t3, e4) {
          this.resolvedProperty.fromArray(t3, e4), this.targetObject.needsUpdate = true;
        }, function(t3, e4) {
          this.resolvedProperty.fromArray(t3, e4), this.targetObject.matrixWorldNeedsUpdate = true;
        }]], getValue: function(t3, e4) {
          this.bind(), this.getValue(t3, e4);
        }, setValue: function(t3, e4) {
          this.bind(), this.setValue(t3, e4);
        }, bind: function() {
          var t3 = this.node, e4 = this.parsedPath, r3 = e4.objectName, n2 = e4.propertyName, i3 = e4.propertyIndex;
          if (t3 || (t3 = bc.findNode(this.rootNode, e4.nodeName) || this.rootNode, this.node = t3), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t3) {
            if (r3) {
              var a3 = e4.objectIndex;
              switch (r3) {
                case "materials":
                  if (!t3.material)
                    return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  if (!t3.material.materials)
                    return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  t3 = t3.material.materials;
                  break;
                case "bones":
                  if (!t3.skeleton)
                    return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  t3 = t3.skeleton.bones;
                  for (var o5 = 0; o5 < t3.length; o5++)
                    if (t3[o5].name === a3) {
                      a3 = o5;
                      break;
                    }
                  break;
                default:
                  if (t3[r3] === void 0)
                    return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  t3 = t3[r3];
              }
              if (a3 !== void 0) {
                if (t3[a3] === void 0)
                  return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t3);
                t3 = t3[a3];
              }
            }
            var s4 = t3[n2];
            if (s4 !== void 0) {
              var c3 = this.Versioning.None;
              this.targetObject = t3, t3.needsUpdate !== void 0 ? c3 = this.Versioning.NeedsUpdate : t3.matrixWorldNeedsUpdate !== void 0 && (c3 = this.Versioning.MatrixWorldNeedsUpdate);
              var l4 = this.BindingType.Direct;
              if (i3 !== void 0) {
                if (n2 === "morphTargetInfluences") {
                  if (!t3.geometry)
                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                  if (t3.geometry.isBufferGeometry) {
                    if (!t3.geometry.morphAttributes)
                      return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    for (o5 = 0; o5 < this.node.geometry.morphAttributes.position.length; o5++)
                      if (t3.geometry.morphAttributes.position[o5].name === i3) {
                        i3 = o5;
                        break;
                      }
                  } else {
                    if (!t3.geometry.morphTargets)
                      return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                    for (o5 = 0; o5 < this.node.geometry.morphTargets.length; o5++)
                      if (t3.geometry.morphTargets[o5].name === i3) {
                        i3 = o5;
                        break;
                      }
                  }
                }
                l4 = this.BindingType.ArrayElement, this.resolvedProperty = s4, this.propertyIndex = i3;
              } else
                s4.fromArray !== void 0 && s4.toArray !== void 0 ? (l4 = this.BindingType.HasFromToArray, this.resolvedProperty = s4) : Array.isArray(s4) ? (l4 = this.BindingType.EntireArray, this.resolvedProperty = s4) : this.propertyName = n2;
              this.getValue = this.GetterByBindingType[l4], this.setValue = this.SetterByBindingTypeAndVersioning[l4][c3];
            } else {
              var h3 = e4.nodeName;
              console.error("THREE.PropertyBinding: Trying to update property for track: " + h3 + "." + n2 + " but it wasn't found.", t3);
            }
          } else
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        }, unbind: function() {
          this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        } }), Object.assign(bc.prototype, { _getValue_unbound: bc.prototype.getValue, _setValue_unbound: bc.prototype.setValue }), Object.assign(wc.prototype, { isAnimationObjectGroup: true, add: function() {
          for (var t3 = this._objects, e4 = t3.length, r3 = this.nCachedObjects_, n2 = this._indicesByUUID, i3 = this._paths, a3 = this._parsedPaths, o5 = this._bindings, s4 = o5.length, c3 = void 0, l4 = 0, h3 = arguments.length; l4 !== h3; ++l4) {
            var u3 = arguments[l4], p3 = u3.uuid, d3 = n2[p3];
            if (d3 === void 0) {
              d3 = e4++, n2[p3] = d3, t3.push(u3);
              for (var f3 = 0, m3 = s4; f3 !== m3; ++f3)
                o5[f3].push(new bc(u3, i3[f3], a3[f3]));
            } else if (d3 < r3) {
              c3 = t3[d3];
              var g3 = --r3, v3 = t3[g3];
              for (n2[v3.uuid] = d3, t3[d3] = v3, n2[p3] = g3, t3[g3] = u3, f3 = 0, m3 = s4; f3 !== m3; ++f3) {
                var y3 = o5[f3], x3 = y3[g3], b3 = y3[d3];
                y3[d3] = x3, b3 === void 0 && (b3 = new bc(u3, i3[f3], a3[f3])), y3[g3] = b3;
              }
            } else
              t3[d3] !== c3 && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
          }
          this.nCachedObjects_ = r3;
        }, remove: function() {
          for (var t3 = this._objects, e4 = this.nCachedObjects_, r3 = this._indicesByUUID, n2 = this._bindings, i3 = n2.length, a3 = 0, o5 = arguments.length; a3 !== o5; ++a3) {
            var s4 = arguments[a3], c3 = s4.uuid, l4 = r3[c3];
            if (l4 !== void 0 && l4 >= e4) {
              var h3 = e4++, u3 = t3[h3];
              r3[u3.uuid] = l4, t3[l4] = u3, r3[c3] = h3, t3[h3] = s4;
              for (var p3 = 0, d3 = i3; p3 !== d3; ++p3) {
                var f3 = n2[p3], m3 = f3[h3], g3 = f3[l4];
                f3[l4] = m3, f3[h3] = g3;
              }
            }
          }
          this.nCachedObjects_ = e4;
        }, uncache: function() {
          for (var t3 = this._objects, e4 = t3.length, r3 = this.nCachedObjects_, n2 = this._indicesByUUID, i3 = this._bindings, a3 = i3.length, o5 = 0, s4 = arguments.length; o5 !== s4; ++o5) {
            var c3 = arguments[o5], l4 = c3.uuid, h3 = n2[l4];
            if (h3 !== void 0)
              if (delete n2[l4], h3 < r3) {
                var u3 = --r3, p3 = t3[u3], d3 = t3[y3 = --e4];
                n2[p3.uuid] = h3, t3[h3] = p3, n2[d3.uuid] = u3, t3[u3] = d3, t3.pop();
                for (var f3 = 0, m3 = a3; f3 !== m3; ++f3) {
                  var g3 = (x3 = i3[f3])[u3], v3 = x3[y3];
                  x3[h3] = g3, x3[u3] = v3, x3.pop();
                }
              } else {
                var y3;
                for (n2[(d3 = t3[y3 = --e4]).uuid] = h3, t3[h3] = d3, t3.pop(), f3 = 0, m3 = a3; f3 !== m3; ++f3) {
                  var x3;
                  (x3 = i3[f3])[h3] = x3[y3], x3.pop();
                }
              }
          }
          this.nCachedObjects_ = r3;
        }, subscribe_: function(t3, e4) {
          var r3 = this._bindingsIndicesByPath, n2 = r3[t3], i3 = this._bindings;
          if (n2 !== void 0)
            return i3[n2];
          var a3 = this._paths, o5 = this._parsedPaths, s4 = this._objects, c3 = s4.length, l4 = this.nCachedObjects_, h3 = new Array(c3);
          n2 = i3.length, r3[t3] = n2, a3.push(t3), o5.push(e4), i3.push(h3);
          for (var u3 = l4, p3 = s4.length; u3 !== p3; ++u3) {
            var d3 = s4[u3];
            h3[u3] = new bc(d3, t3, e4);
          }
          return h3;
        }, unsubscribe_: function(t3) {
          var e4 = this._bindingsIndicesByPath, r3 = e4[t3];
          if (r3 !== void 0) {
            var n2 = this._paths, i3 = this._parsedPaths, a3 = this._bindings, o5 = a3.length - 1, s4 = a3[o5];
            e4[t3[o5]] = r3, a3[r3] = s4, a3.pop(), i3[r3] = i3[o5], i3.pop(), n2[r3] = n2[o5], n2.pop();
          }
        } }), Object.assign(_c.prototype, { play: function() {
          return this._mixer._activateAction(this), this;
        }, stop: function() {
          return this._mixer._deactivateAction(this), this.reset();
        }, reset: function() {
          return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
        }, isRunning: function() {
          return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }, isScheduled: function() {
          return this._mixer._isActiveAction(this);
        }, startAt: function(t3) {
          return this._startTime = t3, this;
        }, setLoop: function(t3, e4) {
          return this.loop = t3, this.repetitions = e4, this;
        }, setEffectiveWeight: function(t3) {
          return this.weight = t3, this._effectiveWeight = this.enabled ? t3 : 0, this.stopFading();
        }, getEffectiveWeight: function() {
          return this._effectiveWeight;
        }, fadeIn: function(t3) {
          return this._scheduleFading(t3, 0, 1);
        }, fadeOut: function(t3) {
          return this._scheduleFading(t3, 1, 0);
        }, crossFadeFrom: function(t3, e4, r3) {
          if (t3.fadeOut(e4), this.fadeIn(e4), r3) {
            var n2 = this._clip.duration, i3 = t3._clip.duration, a3 = i3 / n2, o5 = n2 / i3;
            t3.warp(1, a3, e4), this.warp(o5, 1, e4);
          }
          return this;
        }, crossFadeTo: function(t3, e4, r3) {
          return t3.crossFadeFrom(this, e4, r3);
        }, stopFading: function() {
          var t3 = this._weightInterpolant;
          return t3 !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t3)), this;
        }, setEffectiveTimeScale: function(t3) {
          return this.timeScale = t3, this._effectiveTimeScale = this.paused ? 0 : t3, this.stopWarping();
        }, getEffectiveTimeScale: function() {
          return this._effectiveTimeScale;
        }, setDuration: function(t3) {
          return this.timeScale = this._clip.duration / t3, this.stopWarping();
        }, syncWith: function(t3) {
          return this.time = t3.time, this.timeScale = t3.timeScale, this.stopWarping();
        }, halt: function(t3) {
          return this.warp(this._effectiveTimeScale, 0, t3);
        }, warp: function(t3, e4, r3) {
          var n2 = this._mixer, i3 = n2.time, a3 = this._timeScaleInterpolant, o5 = this.timeScale;
          a3 === null && (a3 = n2._lendControlInterpolant(), this._timeScaleInterpolant = a3);
          var s4 = a3.parameterPositions, c3 = a3.sampleValues;
          return s4[0] = i3, s4[1] = i3 + r3, c3[0] = t3 / o5, c3[1] = e4 / o5, this;
        }, stopWarping: function() {
          var t3 = this._timeScaleInterpolant;
          return t3 !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t3)), this;
        }, getMixer: function() {
          return this._mixer;
        }, getClip: function() {
          return this._clip;
        }, getRoot: function() {
          return this._localRoot || this._mixer._root;
        }, _update: function(t3, e4, r3, n2) {
          if (this.enabled) {
            var i3 = this._startTime;
            if (i3 !== null) {
              var a3 = (t3 - i3) * r3;
              if (a3 < 0 || r3 === 0)
                return;
              this._startTime = null, e4 = r3 * a3;
            }
            e4 *= this._updateTimeScale(t3);
            var o5 = this._updateTime(e4), s4 = this._updateWeight(t3);
            if (s4 > 0)
              for (var c3 = this._interpolants, l4 = this._propertyBindings, h3 = 0, u3 = c3.length; h3 !== u3; ++h3)
                c3[h3].evaluate(o5), l4[h3].accumulate(n2, s4);
          } else
            this._updateWeight(t3);
        }, _updateWeight: function(t3) {
          var e4 = 0;
          if (this.enabled) {
            e4 = this.weight;
            var r3 = this._weightInterpolant;
            if (r3 !== null) {
              var n2 = r3.evaluate(t3)[0];
              e4 *= n2, t3 > r3.parameterPositions[1] && (this.stopFading(), n2 === 0 && (this.enabled = false));
            }
          }
          return this._effectiveWeight = e4, e4;
        }, _updateTimeScale: function(t3) {
          var e4 = 0;
          if (!this.paused) {
            e4 = this.timeScale;
            var r3 = this._timeScaleInterpolant;
            r3 !== null && (e4 *= r3.evaluate(t3)[0], t3 > r3.parameterPositions[1] && (this.stopWarping(), e4 === 0 ? this.paused = true : this.timeScale = e4));
          }
          return this._effectiveTimeScale = e4, e4;
        }, _updateTime: function(t3) {
          var e4 = this.time + t3, r3 = this._clip.duration, n2 = this.loop, i3 = this._loopCount, a3 = n2 === 2202;
          if (t3 === 0)
            return i3 === -1 ? e4 : a3 && (1 & i3) == 1 ? r3 - e4 : e4;
          if (n2 === 2200) {
            i3 === -1 && (this._loopCount = 0, this._setEndings(true, true, false));
            t: {
              if (e4 >= r3)
                e4 = r3;
              else {
                if (!(e4 < 0)) {
                  this.time = e4;
                  break t;
                }
                e4 = 0;
              }
              this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = e4, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t3 < 0 ? -1 : 1 });
            }
          } else {
            if (i3 === -1 && (t3 >= 0 ? (i3 = 0, this._setEndings(true, this.repetitions === 0, a3)) : this._setEndings(this.repetitions === 0, true, a3)), e4 >= r3 || e4 < 0) {
              var o5 = Math.floor(e4 / r3);
              e4 -= r3 * o5, i3 += Math.abs(o5);
              var s4 = this.repetitions - i3;
              if (s4 <= 0)
                this.clampWhenFinished ? this.paused = true : this.enabled = false, e4 = t3 > 0 ? r3 : 0, this.time = e4, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t3 > 0 ? 1 : -1 });
              else {
                if (s4 === 1) {
                  var c3 = t3 < 0;
                  this._setEndings(c3, !c3, a3);
                } else
                  this._setEndings(false, false, a3);
                this._loopCount = i3, this.time = e4, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: o5 });
              }
            } else
              this.time = e4;
            if (a3 && (1 & i3) == 1)
              return r3 - e4;
          }
          return e4;
        }, _setEndings: function(t3, e4, r3) {
          var n2 = this._interpolantSettings;
          r3 ? (n2.endingStart = 2401, n2.endingEnd = 2401) : (n2.endingStart = t3 ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n2.endingEnd = e4 ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
        }, _scheduleFading: function(t3, e4, r3) {
          var n2 = this._mixer, i3 = n2.time, a3 = this._weightInterpolant;
          a3 === null && (a3 = n2._lendControlInterpolant(), this._weightInterpolant = a3);
          var o5 = a3.parameterPositions, s4 = a3.sampleValues;
          return o5[0] = i3, s4[0] = e4, o5[1] = i3 + t3, s4[1] = r3, this;
        } }), Mc.prototype = Object.assign(Object.create(e3.prototype), { constructor: Mc, _bindAction: function(t3, e4) {
          var r3 = t3._localRoot || this._root, n2 = t3._clip.tracks, i3 = n2.length, a3 = t3._propertyBindings, o5 = t3._interpolants, s4 = r3.uuid, c3 = this._bindingsByRootAndName, l4 = c3[s4];
          l4 === void 0 && (l4 = {}, c3[s4] = l4);
          for (var h3 = 0; h3 !== i3; ++h3) {
            var u3 = n2[h3], p3 = u3.name, d3 = l4[p3];
            if (d3 !== void 0)
              a3[h3] = d3;
            else {
              if ((d3 = a3[h3]) !== void 0) {
                d3._cacheIndex === null && (++d3.referenceCount, this._addInactiveBinding(d3, s4, p3));
                continue;
              }
              var f3 = e4 && e4._propertyBindings[h3].binding.parsedPath;
              ++(d3 = new hc(bc.create(r3, p3, f3), u3.ValueTypeName, u3.getValueSize())).referenceCount, this._addInactiveBinding(d3, s4, p3), a3[h3] = d3;
            }
            o5[h3].resultBuffer = d3.buffer;
          }
        }, _activateAction: function(t3) {
          if (!this._isActiveAction(t3)) {
            if (t3._cacheIndex === null) {
              var e4 = (t3._localRoot || this._root).uuid, r3 = t3._clip.uuid, n2 = this._actionsByClip[r3];
              this._bindAction(t3, n2 && n2.knownActions[0]), this._addInactiveAction(t3, r3, e4);
            }
            for (var i3 = t3._propertyBindings, a3 = 0, o5 = i3.length; a3 !== o5; ++a3) {
              var s4 = i3[a3];
              s4.useCount++ == 0 && (this._lendBinding(s4), s4.saveOriginalState());
            }
            this._lendAction(t3);
          }
        }, _deactivateAction: function(t3) {
          if (this._isActiveAction(t3)) {
            for (var e4 = t3._propertyBindings, r3 = 0, n2 = e4.length; r3 !== n2; ++r3) {
              var i3 = e4[r3];
              --i3.useCount == 0 && (i3.restoreOriginalState(), this._takeBackBinding(i3));
            }
            this._takeBackAction(t3);
          }
        }, _initMemoryManager: function() {
          this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
          var t3 = this;
          this.stats = { actions: { get total() {
            return t3._actions.length;
          }, get inUse() {
            return t3._nActiveActions;
          } }, bindings: { get total() {
            return t3._bindings.length;
          }, get inUse() {
            return t3._nActiveBindings;
          } }, controlInterpolants: { get total() {
            return t3._controlInterpolants.length;
          }, get inUse() {
            return t3._nActiveControlInterpolants;
          } } };
        }, _isActiveAction: function(t3) {
          var e4 = t3._cacheIndex;
          return e4 !== null && e4 < this._nActiveActions;
        }, _addInactiveAction: function(t3, e4, r3) {
          var n2 = this._actions, i3 = this._actionsByClip, a3 = i3[e4];
          if (a3 === void 0)
            a3 = { knownActions: [t3], actionByRoot: {} }, t3._byClipCacheIndex = 0, i3[e4] = a3;
          else {
            var o5 = a3.knownActions;
            t3._byClipCacheIndex = o5.length, o5.push(t3);
          }
          t3._cacheIndex = n2.length, n2.push(t3), a3.actionByRoot[r3] = t3;
        }, _removeInactiveAction: function(t3) {
          var e4 = this._actions, r3 = e4[e4.length - 1], n2 = t3._cacheIndex;
          r3._cacheIndex = n2, e4[n2] = r3, e4.pop(), t3._cacheIndex = null;
          var i3 = t3._clip.uuid, a3 = this._actionsByClip, o5 = a3[i3], s4 = o5.knownActions, c3 = s4[s4.length - 1], l4 = t3._byClipCacheIndex;
          c3._byClipCacheIndex = l4, s4[l4] = c3, s4.pop(), t3._byClipCacheIndex = null, delete o5.actionByRoot[(t3._localRoot || this._root).uuid], s4.length === 0 && delete a3[i3], this._removeInactiveBindingsForAction(t3);
        }, _removeInactiveBindingsForAction: function(t3) {
          for (var e4 = t3._propertyBindings, r3 = 0, n2 = e4.length; r3 !== n2; ++r3) {
            var i3 = e4[r3];
            --i3.referenceCount == 0 && this._removeInactiveBinding(i3);
          }
        }, _lendAction: function(t3) {
          var e4 = this._actions, r3 = t3._cacheIndex, n2 = this._nActiveActions++, i3 = e4[n2];
          t3._cacheIndex = n2, e4[n2] = t3, i3._cacheIndex = r3, e4[r3] = i3;
        }, _takeBackAction: function(t3) {
          var e4 = this._actions, r3 = t3._cacheIndex, n2 = --this._nActiveActions, i3 = e4[n2];
          t3._cacheIndex = n2, e4[n2] = t3, i3._cacheIndex = r3, e4[r3] = i3;
        }, _addInactiveBinding: function(t3, e4, r3) {
          var n2 = this._bindingsByRootAndName, i3 = n2[e4], a3 = this._bindings;
          i3 === void 0 && (i3 = {}, n2[e4] = i3), i3[r3] = t3, t3._cacheIndex = a3.length, a3.push(t3);
        }, _removeInactiveBinding: function(t3) {
          var e4 = this._bindings, r3 = t3.binding, n2 = r3.rootNode.uuid, i3 = r3.path, a3 = this._bindingsByRootAndName, o5 = a3[n2], s4 = e4[e4.length - 1], c3 = t3._cacheIndex;
          s4._cacheIndex = c3, e4[c3] = s4, e4.pop(), delete o5[i3], Object.keys(o5).length === 0 && delete a3[n2];
        }, _lendBinding: function(t3) {
          var e4 = this._bindings, r3 = t3._cacheIndex, n2 = this._nActiveBindings++, i3 = e4[n2];
          t3._cacheIndex = n2, e4[n2] = t3, i3._cacheIndex = r3, e4[r3] = i3;
        }, _takeBackBinding: function(t3) {
          var e4 = this._bindings, r3 = t3._cacheIndex, n2 = --this._nActiveBindings, i3 = e4[n2];
          t3._cacheIndex = n2, e4[n2] = t3, i3._cacheIndex = r3, e4[r3] = i3;
        }, _lendControlInterpolant: function() {
          var t3 = this._controlInterpolants, e4 = this._nActiveControlInterpolants++, r3 = t3[e4];
          return r3 === void 0 && ((r3 = new wo(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e4, t3[e4] = r3), r3;
        }, _takeBackControlInterpolant: function(t3) {
          var e4 = this._controlInterpolants, r3 = t3.__cacheIndex, n2 = --this._nActiveControlInterpolants, i3 = e4[n2];
          t3.__cacheIndex = n2, e4[n2] = t3, i3.__cacheIndex = r3, e4[r3] = i3;
        }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function(t3, e4) {
          var r3 = e4 || this._root, n2 = r3.uuid, i3 = typeof t3 == "string" ? Co.findByName(r3, t3) : t3, a3 = i3 !== null ? i3.uuid : t3, o5 = this._actionsByClip[a3], s4 = null;
          if (o5 !== void 0) {
            var c3 = o5.actionByRoot[n2];
            if (c3 !== void 0)
              return c3;
            s4 = o5.knownActions[0], i3 === null && (i3 = s4._clip);
          }
          if (i3 === null)
            return null;
          var l4 = new _c(this, i3, e4);
          return this._bindAction(l4, s4), this._addInactiveAction(l4, a3, n2), l4;
        }, existingAction: function(t3, e4) {
          var r3 = e4 || this._root, n2 = r3.uuid, i3 = typeof t3 == "string" ? Co.findByName(r3, t3) : t3, a3 = i3 ? i3.uuid : t3, o5 = this._actionsByClip[a3];
          return o5 !== void 0 && o5.actionByRoot[n2] || null;
        }, stopAllAction: function() {
          var t3 = this._actions, e4 = this._nActiveActions, r3 = this._bindings, n2 = this._nActiveBindings;
          this._nActiveActions = 0, this._nActiveBindings = 0;
          for (var i3 = 0; i3 !== e4; ++i3)
            t3[i3].reset();
          for (i3 = 0; i3 !== n2; ++i3)
            r3[i3].useCount = 0;
          return this;
        }, update: function(t3) {
          t3 *= this.timeScale;
          for (var e4 = this._actions, r3 = this._nActiveActions, n2 = this.time += t3, i3 = Math.sign(t3), a3 = this._accuIndex ^= 1, o5 = 0; o5 !== r3; ++o5)
            e4[o5]._update(n2, t3, i3, a3);
          var s4 = this._bindings, c3 = this._nActiveBindings;
          for (o5 = 0; o5 !== c3; ++o5)
            s4[o5].apply(a3);
          return this;
        }, getRoot: function() {
          return this._root;
        }, uncacheClip: function(t3) {
          var e4 = this._actions, r3 = t3.uuid, n2 = this._actionsByClip, i3 = n2[r3];
          if (i3 !== void 0) {
            for (var a3 = i3.knownActions, o5 = 0, s4 = a3.length; o5 !== s4; ++o5) {
              var c3 = a3[o5];
              this._deactivateAction(c3);
              var l4 = c3._cacheIndex, h3 = e4[e4.length - 1];
              c3._cacheIndex = null, c3._byClipCacheIndex = null, h3._cacheIndex = l4, e4[l4] = h3, e4.pop(), this._removeInactiveBindingsForAction(c3);
            }
            delete n2[r3];
          }
        }, uncacheRoot: function(t3) {
          var e4 = t3.uuid, r3 = this._actionsByClip;
          for (var n2 in r3) {
            var i3 = r3[n2].actionByRoot[e4];
            i3 !== void 0 && (this._deactivateAction(i3), this._removeInactiveAction(i3));
          }
          var a3 = this._bindingsByRootAndName[e4];
          if (a3 !== void 0)
            for (var o5 in a3) {
              var s4 = a3[o5];
              s4.restoreOriginalState(), this._removeInactiveBinding(s4);
            }
        }, uncacheAction: function(t3, e4) {
          var r3 = this.existingAction(t3, e4);
          r3 !== null && (this._deactivateAction(r3), this._removeInactiveAction(r3));
        } }), Sc.prototype.clone = function() {
          return new Sc(this.value.clone === void 0 ? this.value : this.value.clone());
        }, Tc.prototype = Object.assign(Object.create(ti.prototype), { constructor: Tc, isInstancedInterleavedBuffer: true, copy: function(t3) {
          return ti.prototype.copy.call(this, t3), this.meshPerAttribute = t3.meshPerAttribute, this;
        } }), Object.assign(Ec.prototype, { linePrecision: 1, set: function(t3, e4) {
          this.ray.set(t3, e4);
        }, setFromCamera: function(t3, e4) {
          e4 && e4.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e4.matrixWorld), this.ray.direction.set(t3.x, t3.y, 0.5).unproject(e4).sub(this.ray.origin).normalize(), this.camera = e4) : e4 && e4.isOrthographicCamera ? (this.ray.origin.set(t3.x, t3.y, (e4.near + e4.far) / (e4.near - e4.far)).unproject(e4), this.ray.direction.set(0, 0, -1).transformDirection(e4.matrixWorld), this.camera = e4) : console.error("THREE.Raycaster: Unsupported camera type.");
        }, intersectObject: function(t3, e4, r3) {
          var n2 = r3 || [];
          return Lc(t3, this, n2, e4), n2.sort(Ac), n2;
        }, intersectObjects: function(t3, e4, r3) {
          var n2 = r3 || [];
          if (Array.isArray(t3) === false)
            return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n2;
          for (var i3 = 0, a3 = t3.length; i3 < a3; i3++)
            Lc(t3[i3], this, n2, e4);
          return n2.sort(Ac), n2;
        } }), Object.assign(Rc.prototype, { set: function(t3, e4, r3) {
          return this.radius = t3, this.phi = e4, this.theta = r3, this;
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          return this.radius = t3.radius, this.phi = t3.phi, this.theta = t3.theta, this;
        }, makeSafe: function() {
          return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
        }, setFromVector3: function(t3) {
          return this.setFromCartesianCoords(t3.x, t3.y, t3.z);
        }, setFromCartesianCoords: function(t3, e4, r3) {
          return this.radius = Math.sqrt(t3 * t3 + e4 * e4 + r3 * r3), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t3, r3), this.phi = Math.acos(s3.clamp(e4 / this.radius, -1, 1))), this;
        } }), Object.assign(Pc.prototype, { set: function(t3, e4, r3) {
          return this.radius = t3, this.theta = e4, this.y = r3, this;
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          return this.radius = t3.radius, this.theta = t3.theta, this.y = t3.y, this;
        }, setFromVector3: function(t3) {
          return this.setFromCartesianCoords(t3.x, t3.y, t3.z);
        }, setFromCartesianCoords: function(t3, e4, r3) {
          return this.radius = Math.sqrt(t3 * t3 + r3 * r3), this.theta = Math.atan2(t3, r3), this.y = e4, this;
        } });
        var Cc = new l3();
        function Oc(t3, e4) {
          this.min = t3 !== void 0 ? t3 : new l3(1 / 0, 1 / 0), this.max = e4 !== void 0 ? e4 : new l3(-1 / 0, -1 / 0);
        }
        Object.assign(Oc.prototype, { set: function(t3, e4) {
          return this.min.copy(t3), this.max.copy(e4), this;
        }, setFromPoints: function(t3) {
          this.makeEmpty();
          for (var e4 = 0, r3 = t3.length; e4 < r3; e4++)
            this.expandByPoint(t3[e4]);
          return this;
        }, setFromCenterAndSize: function(t3, e4) {
          var r3 = Cc.copy(e4).multiplyScalar(0.5);
          return this.min.copy(t3).sub(r3), this.max.copy(t3).add(r3), this;
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          return this.min.copy(t3.min), this.max.copy(t3.max), this;
        }, makeEmpty: function() {
          return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
        }, isEmpty: function() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }, getCenter: function(t3) {
          return t3 === void 0 && (console.warn("THREE.Box2: .getCenter() target is now required"), t3 = new l3()), this.isEmpty() ? t3.set(0, 0) : t3.addVectors(this.min, this.max).multiplyScalar(0.5);
        }, getSize: function(t3) {
          return t3 === void 0 && (console.warn("THREE.Box2: .getSize() target is now required"), t3 = new l3()), this.isEmpty() ? t3.set(0, 0) : t3.subVectors(this.max, this.min);
        }, expandByPoint: function(t3) {
          return this.min.min(t3), this.max.max(t3), this;
        }, expandByVector: function(t3) {
          return this.min.sub(t3), this.max.add(t3), this;
        }, expandByScalar: function(t3) {
          return this.min.addScalar(-t3), this.max.addScalar(t3), this;
        }, containsPoint: function(t3) {
          return !(t3.x < this.min.x || t3.x > this.max.x || t3.y < this.min.y || t3.y > this.max.y);
        }, containsBox: function(t3) {
          return this.min.x <= t3.min.x && t3.max.x <= this.max.x && this.min.y <= t3.min.y && t3.max.y <= this.max.y;
        }, getParameter: function(t3, e4) {
          return e4 === void 0 && (console.warn("THREE.Box2: .getParameter() target is now required"), e4 = new l3()), e4.set((t3.x - this.min.x) / (this.max.x - this.min.x), (t3.y - this.min.y) / (this.max.y - this.min.y));
        }, intersectsBox: function(t3) {
          return !(t3.max.x < this.min.x || t3.min.x > this.max.x || t3.max.y < this.min.y || t3.min.y > this.max.y);
        }, clampPoint: function(t3, e4) {
          return e4 === void 0 && (console.warn("THREE.Box2: .clampPoint() target is now required"), e4 = new l3()), e4.copy(t3).clamp(this.min, this.max);
        }, distanceToPoint: function(t3) {
          return Cc.copy(t3).clamp(this.min, this.max).sub(t3).length();
        }, intersect: function(t3) {
          return this.min.max(t3.min), this.max.min(t3.max), this;
        }, union: function(t3) {
          return this.min.min(t3.min), this.max.max(t3.max), this;
        }, translate: function(t3) {
          return this.min.add(t3), this.max.add(t3), this;
        }, equals: function(t3) {
          return t3.min.equals(this.min) && t3.max.equals(this.max);
        } });
        var Dc = new d2(), Nc = new d2();
        function Ic(t3, e4) {
          this.start = t3 !== void 0 ? t3 : new d2(), this.end = e4 !== void 0 ? e4 : new d2();
        }
        function zc(t3) {
          Y.call(this), this.material = t3, this.render = function() {
          };
        }
        Object.assign(Ic.prototype, { set: function(t3, e4) {
          return this.start.copy(t3), this.end.copy(e4), this;
        }, clone: function() {
          return new this.constructor().copy(this);
        }, copy: function(t3) {
          return this.start.copy(t3.start), this.end.copy(t3.end), this;
        }, getCenter: function(t3) {
          return t3 === void 0 && (console.warn("THREE.Line3: .getCenter() target is now required"), t3 = new d2()), t3.addVectors(this.start, this.end).multiplyScalar(0.5);
        }, delta: function(t3) {
          return t3 === void 0 && (console.warn("THREE.Line3: .delta() target is now required"), t3 = new d2()), t3.subVectors(this.end, this.start);
        }, distanceSq: function() {
          return this.start.distanceToSquared(this.end);
        }, distance: function() {
          return this.start.distanceTo(this.end);
        }, at: function(t3, e4) {
          return e4 === void 0 && (console.warn("THREE.Line3: .at() target is now required"), e4 = new d2()), this.delta(e4).multiplyScalar(t3).add(this.start);
        }, closestPointToPointParameter: function(t3, e4) {
          Dc.subVectors(t3, this.start), Nc.subVectors(this.end, this.start);
          var r3 = Nc.dot(Nc), n2 = Nc.dot(Dc) / r3;
          return e4 && (n2 = s3.clamp(n2, 0, 1)), n2;
        }, closestPointToPoint: function(t3, e4, r3) {
          var n2 = this.closestPointToPointParameter(t3, e4);
          return r3 === void 0 && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), r3 = new d2()), this.delta(r3).multiplyScalar(n2).add(this.start);
        }, applyMatrix4: function(t3) {
          return this.start.applyMatrix4(t3), this.end.applyMatrix4(t3), this;
        }, equals: function(t3) {
          return t3.start.equals(this.start) && t3.end.equals(this.end);
        } }), zc.prototype = Object.create(Y.prototype), zc.prototype.constructor = zc, zc.prototype.isImmediateRenderObject = true;
        var Bc = new d2(), Fc = new d2(), Gc = new m2(), Uc = ["a", "b", "c"];
        function Hc(t3, e4, r3, n2) {
          this.object = t3, this.size = e4 !== void 0 ? e4 : 1;
          var i3 = r3 !== void 0 ? r3 : 16711680, a3 = n2 !== void 0 ? n2 : 1, o5 = 0, s4 = this.object.geometry;
          s4 && s4.isGeometry ? o5 = 3 * s4.faces.length : s4 && s4.isBufferGeometry && (o5 = s4.attributes.normal.count);
          var c3 = new se(), l4 = new Zt(2 * o5 * 3, 3);
          c3.addAttribute("position", l4), Ni.call(this, c3, new Ti({ color: i3, linewidth: a3 })), this.matrixAutoUpdate = false, this.update();
        }
        Hc.prototype = Object.create(Ni.prototype), Hc.prototype.constructor = Hc, Hc.prototype.update = function() {
          this.object.updateMatrixWorld(true), Gc.getNormalMatrix(this.object.matrixWorld);
          var t3 = this.object.matrixWorld, e4 = this.geometry.attributes.position, r3 = this.object.geometry;
          if (r3 && r3.isGeometry)
            for (var n2 = r3.vertices, i3 = r3.faces, a3 = 0, o5 = 0, s4 = i3.length; o5 < s4; o5++)
              for (var c3 = i3[o5], l4 = 0, h3 = c3.vertexNormals.length; l4 < h3; l4++) {
                var u3 = n2[c3[Uc[l4]]], p3 = c3.vertexNormals[l4];
                Bc.copy(u3).applyMatrix4(t3), Fc.copy(p3).applyMatrix3(Gc).normalize().multiplyScalar(this.size).add(Bc), e4.setXYZ(a3, Bc.x, Bc.y, Bc.z), a3 += 1, e4.setXYZ(a3, Fc.x, Fc.y, Fc.z), a3 += 1;
              }
          else if (r3 && r3.isBufferGeometry) {
            var d3 = r3.attributes.position, f3 = r3.attributes.normal;
            for (a3 = 0, l4 = 0, h3 = d3.count; l4 < h3; l4++)
              Bc.set(d3.getX(l4), d3.getY(l4), d3.getZ(l4)).applyMatrix4(t3), Fc.set(f3.getX(l4), f3.getY(l4), f3.getZ(l4)), Fc.applyMatrix3(Gc).normalize().multiplyScalar(this.size).add(Bc), e4.setXYZ(a3, Bc.x, Bc.y, Bc.z), a3 += 1, e4.setXYZ(a3, Fc.x, Fc.y, Fc.z), a3 += 1;
          }
          e4.needsUpdate = true;
        };
        var Vc = new d2();
        function jc(t3, e4) {
          Y.call(this), this.light = t3, this.light.updateMatrixWorld(), this.matrix = t3.matrixWorld, this.matrixAutoUpdate = false, this.color = e4;
          for (var r3 = new se(), n2 = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i3 = 0, a3 = 1; i3 < 32; i3++, a3++) {
            var o5 = i3 / 32 * Math.PI * 2, s4 = a3 / 32 * Math.PI * 2;
            n2.push(Math.cos(o5), Math.sin(o5), 1, Math.cos(s4), Math.sin(s4), 1);
          }
          r3.addAttribute("position", new Zt(n2, 3));
          var c3 = new Ti({ fog: false });
          this.cone = new Ni(r3, c3), this.add(this.cone), this.update();
        }
        jc.prototype = Object.create(Y.prototype), jc.prototype.constructor = jc, jc.prototype.dispose = function() {
          this.cone.geometry.dispose(), this.cone.material.dispose();
        }, jc.prototype.update = function() {
          this.light.updateMatrixWorld();
          var t3 = this.light.distance ? this.light.distance : 1e3, e4 = t3 * Math.tan(this.light.angle);
          this.cone.scale.set(e4, e4, t3), Vc.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Vc), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
        };
        var kc = new d2(), Wc = new P2(), qc = new P2();
        function Xc(t3) {
          for (var e4 = function t4(e5) {
            var r4 = [];
            e5 && e5.isBone && r4.push(e5);
            for (var n3 = 0; n3 < e5.children.length; n3++)
              r4.push.apply(r4, t4(e5.children[n3]));
            return r4;
          }(t3), r3 = new se(), n2 = [], i3 = [], a3 = new Nt(0, 0, 1), o5 = new Nt(0, 1, 0), s4 = 0; s4 < e4.length; s4++) {
            var c3 = e4[s4];
            c3.parent && c3.parent.isBone && (n2.push(0, 0, 0), n2.push(0, 0, 0), i3.push(a3.r, a3.g, a3.b), i3.push(o5.r, o5.g, o5.b));
          }
          r3.addAttribute("position", new Zt(n2, 3)), r3.addAttribute("color", new Zt(i3, 3));
          var l4 = new Ti({ vertexColors: 2, depthTest: false, depthWrite: false, transparent: true });
          Ni.call(this, r3, l4), this.root = t3, this.bones = e4, this.matrix = t3.matrixWorld, this.matrixAutoUpdate = false;
        }
        function Yc(t3, e4, r3) {
          this.light = t3, this.light.updateMatrixWorld(), this.color = r3;
          var n2 = new ka(e4, 4, 2), i3 = new Ht({ wireframe: true, fog: false });
          Te.call(this, n2, i3), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update();
        }
        function Jc(t3, e4) {
          this.type = "RectAreaLightHelper", this.light = t3, this.color = e4;
          var r3 = new se();
          r3.addAttribute("position", new Zt([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), r3.computeBoundingSphere();
          var n2 = new Ti({ fog: false });
          Ci.call(this, r3, n2);
          var i3 = new se();
          i3.addAttribute("position", new Zt([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), i3.computeBoundingSphere(), this.add(new Te(i3, new Ht({ side: 1, fog: false }))), this.update();
        }
        Xc.prototype = Object.create(Ni.prototype), Xc.prototype.constructor = Xc, Xc.prototype.updateMatrixWorld = function(t3) {
          var e4 = this.bones, r3 = this.geometry, n2 = r3.getAttribute("position");
          qc.getInverse(this.root.matrixWorld);
          for (var i3 = 0, a3 = 0; i3 < e4.length; i3++) {
            var o5 = e4[i3];
            o5.parent && o5.parent.isBone && (Wc.multiplyMatrices(qc, o5.matrixWorld), kc.setFromMatrixPosition(Wc), n2.setXYZ(a3, kc.x, kc.y, kc.z), Wc.multiplyMatrices(qc, o5.parent.matrixWorld), kc.setFromMatrixPosition(Wc), n2.setXYZ(a3 + 1, kc.x, kc.y, kc.z), a3 += 2);
          }
          r3.getAttribute("position").needsUpdate = true, Y.prototype.updateMatrixWorld.call(this, t3);
        }, Yc.prototype = Object.create(Te.prototype), Yc.prototype.constructor = Yc, Yc.prototype.dispose = function() {
          this.geometry.dispose(), this.material.dispose();
        }, Yc.prototype.update = function() {
          this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
        }, Jc.prototype = Object.create(Ci.prototype), Jc.prototype.constructor = Jc, Jc.prototype.update = function() {
          if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
            this.material.color.set(this.color), this.children[0].material.color.set(this.color);
          else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            var t3 = this.material.color, e4 = Math.max(t3.r, t3.g, t3.b);
            e4 > 1 && t3.multiplyScalar(1 / e4), this.children[0].material.color.copy(this.material.color);
          }
        }, Jc.prototype.dispose = function() {
          this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
        };
        var Zc = new d2(), Qc = new Nt(), Kc = new Nt();
        function $c(t3, e4, r3) {
          Y.call(this), this.light = t3, this.light.updateMatrixWorld(), this.matrix = t3.matrixWorld, this.matrixAutoUpdate = false, this.color = r3;
          var n2 = new ea(e4);
          n2.rotateY(0.5 * Math.PI), this.material = new Ht({ wireframe: true, fog: false }), this.color === void 0 && (this.material.vertexColors = 2);
          var i3 = n2.getAttribute("position"), a3 = new Float32Array(3 * i3.count);
          n2.addAttribute("color", new Vt(a3, 3)), this.add(new Te(n2, this.material)), this.update();
        }
        function tl(t3, e4) {
          this.lightProbe = t3, this.size = e4;
          var r3 = { GAMMA_OUTPUT: "" }, n2 = new Fe({ defines: r3, uniforms: { sh: { value: this.lightProbe.sh.coefficients }, intensity: { value: this.lightProbe.intensity } }, vertexShader: ["varying vec3 vNormal;", "void main() {", "	vNormal = normalize( normalMatrix * normal );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), fragmentShader: ["#define RECIPROCAL_PI 0.318309886", "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {", "	// matrix is assumed to be orthogonal", "	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );", "}", "vec3 linearToOutput( in vec3 a ) {", "	#ifdef GAMMA_OUTPUT", "		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );", "	#else", "		return a;", "	#endif", "}", "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf", "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {", "	// normal is assumed to have unit length", "	float x = normal.x, y = normal.y, z = normal.z;", "	// band 0", "	vec3 result = shCoefficients[ 0 ] * 0.886227;", "	// band 1", "	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;", "	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;", "	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;", "	// band 2", "	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;", "	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;", "	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );", "	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;", "	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );", "	return result;", "}", "uniform vec3 sh[ 9 ]; // sh coefficients", "uniform float intensity; // light probe intensity", "varying vec3 vNormal;", "void main() {", "	vec3 normal = normalize( vNormal );", "	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );", "	vec3 irradiance = shGetIrradianceAt( worldNormal, sh );", "	vec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;", "	outgoingLight = linearToOutput( outgoingLight );", "	gl_FragColor = vec4( outgoingLight, 1.0 );", "}"].join("\n") }), i3 = new ka(1, 32, 16);
          Te.call(this, i3, n2), this.onBeforeRender();
        }
        function el(t3, e4, r3, n2) {
          t3 = t3 || 10, e4 = e4 || 10, r3 = new Nt(r3 !== void 0 ? r3 : 4473924), n2 = new Nt(n2 !== void 0 ? n2 : 8947848);
          for (var i3 = e4 / 2, a3 = t3 / e4, o5 = t3 / 2, s4 = [], c3 = [], l4 = 0, h3 = 0, u3 = -o5; l4 <= e4; l4++, u3 += a3) {
            s4.push(-o5, 0, u3, o5, 0, u3), s4.push(u3, 0, -o5, u3, 0, o5);
            var p3 = l4 === i3 ? r3 : n2;
            p3.toArray(c3, h3), h3 += 3, p3.toArray(c3, h3), h3 += 3, p3.toArray(c3, h3), h3 += 3, p3.toArray(c3, h3), h3 += 3;
          }
          var d3 = new se();
          d3.addAttribute("position", new Zt(s4, 3)), d3.addAttribute("color", new Zt(c3, 3));
          var f3 = new Ti({ vertexColors: 2 });
          Ni.call(this, d3, f3);
        }
        function rl(t3, e4, r3, n2, i3, a3) {
          t3 = t3 || 10, e4 = e4 || 16, r3 = r3 || 8, n2 = n2 || 64, i3 = new Nt(i3 !== void 0 ? i3 : 4473924), a3 = new Nt(a3 !== void 0 ? a3 : 8947848);
          var o5, s4, c3, l4, h3, u3, p3, d3 = [], f3 = [];
          for (l4 = 0; l4 <= e4; l4++)
            c3 = l4 / e4 * (2 * Math.PI), o5 = Math.sin(c3) * t3, s4 = Math.cos(c3) * t3, d3.push(0, 0, 0), d3.push(o5, 0, s4), p3 = 1 & l4 ? i3 : a3, f3.push(p3.r, p3.g, p3.b), f3.push(p3.r, p3.g, p3.b);
          for (l4 = 0; l4 <= r3; l4++)
            for (p3 = 1 & l4 ? i3 : a3, u3 = t3 - t3 / r3 * l4, h3 = 0; h3 < n2; h3++)
              c3 = h3 / n2 * (2 * Math.PI), o5 = Math.sin(c3) * u3, s4 = Math.cos(c3) * u3, d3.push(o5, 0, s4), f3.push(p3.r, p3.g, p3.b), c3 = (h3 + 1) / n2 * (2 * Math.PI), o5 = Math.sin(c3) * u3, s4 = Math.cos(c3) * u3, d3.push(o5, 0, s4), f3.push(p3.r, p3.g, p3.b);
          var m3 = new se();
          m3.addAttribute("position", new Zt(d3, 3)), m3.addAttribute("color", new Zt(f3, 3));
          var g3 = new Ti({ vertexColors: 2 });
          Ni.call(this, m3, g3);
        }
        function nl(t3, e4, r3, n2) {
          this.audio = t3, this.range = e4 || 1, this.divisionsInnerAngle = r3 || 16, this.divisionsOuterAngle = n2 || 2;
          var i3 = new se(), a3 = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle, o5 = new Float32Array(3 * (3 * a3 + 3));
          i3.addAttribute("position", new Vt(o5, 3));
          var s4 = new Ti({ color: 65280 }), c3 = new Ti({ color: 16776960 });
          Ci.call(this, i3, [c3, s4]), this.update();
        }
        $c.prototype = Object.create(Y.prototype), $c.prototype.constructor = $c, $c.prototype.dispose = function() {
          this.children[0].geometry.dispose(), this.children[0].material.dispose();
        }, $c.prototype.update = function() {
          var t3 = this.children[0];
          if (this.color !== void 0)
            this.material.color.set(this.color);
          else {
            var e4 = t3.geometry.getAttribute("color");
            Qc.copy(this.light.color), Kc.copy(this.light.groundColor);
            for (var r3 = 0, n2 = e4.count; r3 < n2; r3++) {
              var i3 = r3 < n2 / 2 ? Qc : Kc;
              e4.setXYZ(r3, i3.r, i3.g, i3.b);
            }
            e4.needsUpdate = true;
          }
          t3.lookAt(Zc.setFromMatrixPosition(this.light.matrixWorld).negate());
        }, tl.prototype = Object.create(Te.prototype), tl.prototype.constructor = tl, tl.prototype.dispose = function() {
          this.geometry.dispose(), this.material.dispose();
        }, tl.prototype.onBeforeRender = function() {
          this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity;
        }, el.prototype = Object.assign(Object.create(Ni.prototype), { constructor: el, copy: function(t3) {
          return Ni.prototype.copy.call(this, t3), this.geometry.copy(t3.geometry), this.material.copy(t3.material), this;
        }, clone: function() {
          return new this.constructor().copy(this);
        } }), rl.prototype = Object.create(Ni.prototype), rl.prototype.constructor = rl, nl.prototype = Object.create(Ci.prototype), nl.prototype.constructor = nl, nl.prototype.update = function() {
          var t3, e4, r3 = this.audio, n2 = this.range, i3 = this.divisionsInnerAngle, a3 = this.divisionsOuterAngle, o5 = s3.degToRad(r3.panner.coneInnerAngle), c3 = s3.degToRad(r3.panner.coneOuterAngle), l4 = o5 / 2, h3 = c3 / 2, u3 = 0, p3 = 0, d3 = this.geometry, f3 = d3.attributes.position;
          function m3(r4, i4, a4, o6) {
            var s4 = (i4 - r4) / a4;
            for (f3.setXYZ(u3, 0, 0, 0), p3++, t3 = r4; t3 < i4; t3 += s4)
              e4 = u3 + p3, f3.setXYZ(e4, Math.sin(t3) * n2, 0, Math.cos(t3) * n2), f3.setXYZ(e4 + 1, Math.sin(Math.min(t3 + s4, i4)) * n2, 0, Math.cos(Math.min(t3 + s4, i4)) * n2), f3.setXYZ(e4 + 2, 0, 0, 0), p3 += 3;
            d3.addGroup(u3, p3, o6), u3 += p3, p3 = 0;
          }
          d3.clearGroups(), m3(-h3, -l4, a3, 0), m3(-l4, l4, i3, 1), m3(l4, h3, a3, 0), f3.needsUpdate = true, o5 === c3 && (this.material[0].visible = false);
        }, nl.prototype.dispose = function() {
          this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose();
        };
        var il = new d2(), al = new d2(), ol = new m2();
        function sl(t3, e4, r3, n2) {
          this.object = t3, this.size = e4 !== void 0 ? e4 : 1;
          var i3 = r3 !== void 0 ? r3 : 16776960, a3 = n2 !== void 0 ? n2 : 1, o5 = 0, s4 = this.object.geometry;
          s4 && s4.isGeometry ? o5 = s4.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
          var c3 = new se(), l4 = new Zt(2 * o5 * 3, 3);
          c3.addAttribute("position", l4), Ni.call(this, c3, new Ti({ color: i3, linewidth: a3 })), this.matrixAutoUpdate = false, this.update();
        }
        sl.prototype = Object.create(Ni.prototype), sl.prototype.constructor = sl, sl.prototype.update = function() {
          this.object.updateMatrixWorld(true), ol.getNormalMatrix(this.object.matrixWorld);
          for (var t3 = this.object.matrixWorld, e4 = this.geometry.attributes.position, r3 = this.object.geometry, n2 = r3.vertices, i3 = r3.faces, a3 = 0, o5 = 0, s4 = i3.length; o5 < s4; o5++) {
            var c3 = i3[o5], l4 = c3.normal;
            il.copy(n2[c3.a]).add(n2[c3.b]).add(n2[c3.c]).divideScalar(3).applyMatrix4(t3), al.copy(l4).applyMatrix3(ol).normalize().multiplyScalar(this.size).add(il), e4.setXYZ(a3, il.x, il.y, il.z), a3 += 1, e4.setXYZ(a3, al.x, al.y, al.z), a3 += 1;
          }
          e4.needsUpdate = true;
        };
        var cl = new d2(), ll = new d2(), hl = new d2();
        function ul(t3, e4, r3) {
          Y.call(this), this.light = t3, this.light.updateMatrixWorld(), this.matrix = t3.matrixWorld, this.matrixAutoUpdate = false, this.color = r3, e4 === void 0 && (e4 = 1);
          var n2 = new se();
          n2.addAttribute("position", new Zt([-e4, e4, 0, e4, e4, 0, e4, -e4, 0, -e4, -e4, 0, -e4, e4, 0], 3));
          var i3 = new Ti({ fog: false });
          this.lightPlane = new Ci(n2, i3), this.add(this.lightPlane), (n2 = new se()).addAttribute("position", new Zt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ci(n2, i3), this.add(this.targetLine), this.update();
        }
        ul.prototype = Object.create(Y.prototype), ul.prototype.constructor = ul, ul.prototype.dispose = function() {
          this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
        }, ul.prototype.update = function() {
          cl.setFromMatrixPosition(this.light.matrixWorld), ll.setFromMatrixPosition(this.light.target.matrixWorld), hl.subVectors(ll, cl), this.lightPlane.lookAt(ll), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(ll), this.targetLine.scale.z = hl.length();
        };
        var pl = new d2(), dl = new Ge();
        function fl(t3) {
          var e4 = new se(), r3 = new Ti({ color: 16777215, vertexColors: 1 }), n2 = [], i3 = [], a3 = {}, o5 = new Nt(16755200), s4 = new Nt(16711680), c3 = new Nt(43775), l4 = new Nt(16777215), h3 = new Nt(3355443);
          function u3(t4, e5, r4) {
            p3(t4, r4), p3(e5, r4);
          }
          function p3(t4, e5) {
            n2.push(0, 0, 0), i3.push(e5.r, e5.g, e5.b), a3[t4] === void 0 && (a3[t4] = []), a3[t4].push(n2.length / 3 - 1);
          }
          u3("n1", "n2", o5), u3("n2", "n4", o5), u3("n4", "n3", o5), u3("n3", "n1", o5), u3("f1", "f2", o5), u3("f2", "f4", o5), u3("f4", "f3", o5), u3("f3", "f1", o5), u3("n1", "f1", o5), u3("n2", "f2", o5), u3("n3", "f3", o5), u3("n4", "f4", o5), u3("p", "n1", s4), u3("p", "n2", s4), u3("p", "n3", s4), u3("p", "n4", s4), u3("u1", "u2", c3), u3("u2", "u3", c3), u3("u3", "u1", c3), u3("c", "t", l4), u3("p", "c", h3), u3("cn1", "cn2", h3), u3("cn3", "cn4", h3), u3("cf1", "cf2", h3), u3("cf3", "cf4", h3), e4.addAttribute("position", new Zt(n2, 3)), e4.addAttribute("color", new Zt(i3, 3)), Ni.call(this, e4, r3), this.camera = t3, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t3.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = a3, this.update();
        }
        function ml(t3, e4, r3, n2, i3, a3, o5) {
          pl.set(i3, a3, o5).unproject(n2);
          var s4 = e4[t3];
          if (s4 !== void 0)
            for (var c3 = r3.getAttribute("position"), l4 = 0, h3 = s4.length; l4 < h3; l4++)
              c3.setXYZ(s4[l4], pl.x, pl.y, pl.z);
        }
        fl.prototype = Object.create(Ni.prototype), fl.prototype.constructor = fl, fl.prototype.update = function() {
          var t3 = this.geometry, e4 = this.pointMap;
          dl.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), ml("c", e4, t3, dl, 0, 0, -1), ml("t", e4, t3, dl, 0, 0, 1), ml("n1", e4, t3, dl, -1, -1, -1), ml("n2", e4, t3, dl, 1, -1, -1), ml("n3", e4, t3, dl, -1, 1, -1), ml("n4", e4, t3, dl, 1, 1, -1), ml("f1", e4, t3, dl, -1, -1, 1), ml("f2", e4, t3, dl, 1, -1, 1), ml("f3", e4, t3, dl, -1, 1, 1), ml("f4", e4, t3, dl, 1, 1, 1), ml("u1", e4, t3, dl, 0.7, 1.1, -1), ml("u2", e4, t3, dl, -0.7, 1.1, -1), ml("u3", e4, t3, dl, 0, 2, -1), ml("cf1", e4, t3, dl, -1, 0, 1), ml("cf2", e4, t3, dl, 1, 0, 1), ml("cf3", e4, t3, dl, 0, -1, 1), ml("cf4", e4, t3, dl, 0, 1, 1), ml("cn1", e4, t3, dl, -1, 0, -1), ml("cn2", e4, t3, dl, 1, 0, -1), ml("cn3", e4, t3, dl, 0, -1, -1), ml("cn4", e4, t3, dl, 0, 1, -1), t3.getAttribute("position").needsUpdate = true;
        };
        var gl = new ct();
        function vl(t3, e4) {
          this.object = t3, e4 === void 0 && (e4 = 16776960);
          var r3 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n2 = new Float32Array(24), i3 = new se();
          i3.setIndex(new Vt(r3, 1)), i3.addAttribute("position", new Vt(n2, 3)), Ni.call(this, i3, new Ti({ color: e4 })), this.matrixAutoUpdate = false, this.update();
        }
        function yl(t3, e4) {
          this.type = "Box3Helper", this.box = t3, e4 = e4 || 16776960;
          var r3 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n2 = new se();
          n2.setIndex(new Vt(r3, 1)), n2.addAttribute("position", new Zt([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Ni.call(this, n2, new Ti({ color: e4 })), this.geometry.computeBoundingSphere();
        }
        function xl(t3, e4, r3) {
          this.type = "PlaneHelper", this.plane = t3, this.size = e4 === void 0 ? 1 : e4;
          var n2 = r3 !== void 0 ? r3 : 16776960, i3 = new se();
          i3.addAttribute("position", new Zt([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i3.computeBoundingSphere(), Ci.call(this, i3, new Ti({ color: n2 }));
          var a3 = new se();
          a3.addAttribute("position", new Zt([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a3.computeBoundingSphere(), this.add(new Te(a3, new Ht({ color: n2, opacity: 0.2, transparent: true, depthWrite: false })));
        }
        vl.prototype = Object.create(Ni.prototype), vl.prototype.constructor = vl, vl.prototype.update = function(t3) {
          if (t3 !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && gl.setFromObject(this.object), !gl.isEmpty()) {
            var e4 = gl.min, r3 = gl.max, n2 = this.geometry.attributes.position, i3 = n2.array;
            i3[0] = r3.x, i3[1] = r3.y, i3[2] = r3.z, i3[3] = e4.x, i3[4] = r3.y, i3[5] = r3.z, i3[6] = e4.x, i3[7] = e4.y, i3[8] = r3.z, i3[9] = r3.x, i3[10] = e4.y, i3[11] = r3.z, i3[12] = r3.x, i3[13] = r3.y, i3[14] = e4.z, i3[15] = e4.x, i3[16] = r3.y, i3[17] = e4.z, i3[18] = e4.x, i3[19] = e4.y, i3[20] = e4.z, i3[21] = r3.x, i3[22] = e4.y, i3[23] = e4.z, n2.needsUpdate = true, this.geometry.computeBoundingSphere();
          }
        }, vl.prototype.setFromObject = function(t3) {
          return this.object = t3, this.update(), this;
        }, vl.prototype.copy = function(t3) {
          return Ni.prototype.copy.call(this, t3), this.object = t3.object, this;
        }, vl.prototype.clone = function() {
          return new this.constructor().copy(this);
        }, yl.prototype = Object.create(Ni.prototype), yl.prototype.constructor = yl, yl.prototype.updateMatrixWorld = function(t3) {
          var e4 = this.box;
          e4.isEmpty() || (e4.getCenter(this.position), e4.getSize(this.scale), this.scale.multiplyScalar(0.5), Y.prototype.updateMatrixWorld.call(this, t3));
        }, xl.prototype = Object.create(Ci.prototype), xl.prototype.constructor = xl, xl.prototype.updateMatrixWorld = function(t3) {
          var e4 = -this.plane.constant;
          Math.abs(e4) < 1e-8 && (e4 = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, e4), this.children[0].material.side = e4 < 0 ? 1 : 0, this.lookAt(this.plane.normal), Y.prototype.updateMatrixWorld.call(this, t3);
        };
        var bl, wl, _l = new d2();
        function Ml(t3, e4, r3, n2, i3, a3) {
          Y.call(this), t3 === void 0 && (t3 = new d2(0, 0, 1)), e4 === void 0 && (e4 = new d2(0, 0, 0)), r3 === void 0 && (r3 = 1), n2 === void 0 && (n2 = 16776960), i3 === void 0 && (i3 = 0.2 * r3), a3 === void 0 && (a3 = 0.2 * i3), bl === void 0 && ((bl = new se()).addAttribute("position", new Zt([0, 0, 0, 0, 1, 0], 3)), (wl = new to(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)), this.position.copy(e4), this.line = new Ci(bl, new Ti({ color: n2 })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new Te(wl, new Ht({ color: n2 })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(t3), this.setLength(r3, i3, a3);
        }
        function Sl(t3) {
          var e4 = [0, 0, 0, t3 = t3 || 1, 0, 0, 0, 0, 0, 0, t3, 0, 0, 0, 0, 0, 0, t3], r3 = new se();
          r3.addAttribute("position", new Zt(e4, 3)), r3.addAttribute("color", new Zt([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3));
          var n2 = new Ti({ vertexColors: 2 });
          Ni.call(this, r3, n2);
        }
        function Tl(t3) {
          console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), $o.call(this, t3), this.type = "catmullrom", this.closed = true;
        }
        function El(t3) {
          console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), $o.call(this, t3), this.type = "catmullrom";
        }
        function Al(t3) {
          console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), $o.call(this, t3), this.type = "catmullrom";
        }
        Ml.prototype = Object.create(Y.prototype), Ml.prototype.constructor = Ml, Ml.prototype.setDirection = function(t3) {
          if (t3.y > 0.99999)
            this.quaternion.set(0, 0, 0, 1);
          else if (t3.y < -0.99999)
            this.quaternion.set(1, 0, 0, 0);
          else {
            _l.set(t3.z, 0, -t3.x).normalize();
            var e4 = Math.acos(t3.y);
            this.quaternion.setFromAxisAngle(_l, e4);
          }
        }, Ml.prototype.setLength = function(t3, e4, r3) {
          e4 === void 0 && (e4 = 0.2 * t3), r3 === void 0 && (r3 = 0.2 * e4), this.line.scale.set(1, Math.max(0, t3 - e4), 1), this.line.updateMatrix(), this.cone.scale.set(r3, e4, r3), this.cone.position.y = t3, this.cone.updateMatrix();
        }, Ml.prototype.setColor = function(t3) {
          this.line.material.color.set(t3), this.cone.material.color.set(t3);
        }, Ml.prototype.copy = function(t3) {
          return Y.prototype.copy.call(this, t3, false), this.line.copy(t3.line), this.cone.copy(t3.cone), this;
        }, Ml.prototype.clone = function() {
          return new this.constructor().copy(this);
        }, Sl.prototype = Object.create(Ni.prototype), Sl.prototype.constructor = Sl, Wo.create = function(t3, e4) {
          return console.log("THREE.Curve.create() has been deprecated"), t3.prototype = Object.create(Wo.prototype), t3.prototype.constructor = t3, t3.prototype.getPoint = e4, t3;
        }, Object.assign(us.prototype, { createPointsGeometry: function(t3) {
          console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
          var e4 = this.getPoints(t3);
          return this.createGeometry(e4);
        }, createSpacedPointsGeometry: function(t3) {
          console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
          var e4 = this.getSpacedPoints(t3);
          return this.createGeometry(e4);
        }, createGeometry: function(t3) {
          console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
          for (var e4 = new Oe(), r3 = 0, n2 = t3.length; r3 < n2; r3++) {
            var i3 = t3[r3];
            e4.vertices.push(new d2(i3.x, i3.y, i3.z || 0));
          }
          return e4;
        } }), Object.assign(ps.prototype, { fromPoints: function(t3) {
          console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t3);
        } }), Tl.prototype = Object.create($o.prototype), El.prototype = Object.create($o.prototype), Al.prototype = Object.create($o.prototype), Object.assign(Al.prototype, { initFromArray: function() {
          console.error("THREE.Spline: .initFromArray() has been removed.");
        }, getControlPointsArray: function() {
          console.error("THREE.Spline: .getControlPointsArray() has been removed.");
        }, reparametrizeByArcLength: function() {
          console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
        } }), el.prototype.setColors = function() {
          console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
        }, Xc.prototype.update = function() {
          console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
        }, Object.assign(zo.prototype, { extractUrlBase: function(t3) {
          return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), As.extractUrlBase(t3);
        } }), Object.assign(Os.prototype, { setTexturePath: function(t3) {
          return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t3);
        } }), Object.assign(Oc.prototype, { center: function(t3) {
          return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t3);
        }, empty: function() {
          return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
        }, isIntersectionBox: function(t3) {
          return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t3);
        }, size: function(t3) {
          return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t3);
        } }), Object.assign(ct.prototype, { center: function(t3) {
          return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t3);
        }, empty: function() {
          return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
        }, isIntersectionBox: function(t3) {
          return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t3);
        }, isIntersectionSphere: function(t3) {
          return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t3);
        }, size: function(t3) {
          return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t3);
        } }), Ic.prototype.center = function(t3) {
          return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t3);
        }, Object.assign(s3, { random16: function() {
          return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random();
        }, nearestPowerOfTwo: function(t3) {
          return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), s3.floorPowerOfTwo(t3);
        }, nextPowerOfTwo: function(t3) {
          return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), s3.ceilPowerOfTwo(t3);
        } }), Object.assign(m2.prototype, { flattenToArrayOffset: function(t3, e4) {
          return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t3, e4);
        }, multiplyVector3: function(t3) {
          return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t3.applyMatrix3(this);
        }, multiplyVector3Array: function() {
          console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
        }, applyToBuffer: function(t3) {
          return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t3);
        }, applyToVector3Array: function() {
          console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
        } }), Object.assign(P2.prototype, { extractPosition: function(t3) {
          return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t3);
        }, flattenToArrayOffset: function(t3, e4) {
          return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t3, e4);
        }, getPosition: function() {
          return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new d2().setFromMatrixColumn(this, 3);
        }, setRotationFromQuaternion: function(t3) {
          return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t3);
        }, multiplyToArray: function() {
          console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
        }, multiplyVector3: function(t3) {
          return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t3.applyMatrix4(this);
        }, multiplyVector4: function(t3) {
          return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t3.applyMatrix4(this);
        }, multiplyVector3Array: function() {
          console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
        }, rotateAxis: function(t3) {
          console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t3.transformDirection(this);
        }, crossVector: function(t3) {
          return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t3.applyMatrix4(this);
        }, translate: function() {
          console.error("THREE.Matrix4: .translate() has been removed.");
        }, rotateX: function() {
          console.error("THREE.Matrix4: .rotateX() has been removed.");
        }, rotateY: function() {
          console.error("THREE.Matrix4: .rotateY() has been removed.");
        }, rotateZ: function() {
          console.error("THREE.Matrix4: .rotateZ() has been removed.");
        }, rotateByAxis: function() {
          console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
        }, applyToBuffer: function(t3) {
          return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t3);
        }, applyToVector3Array: function() {
          console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
        }, makeFrustum: function(t3, e4, r3, n2, i3, a3) {
          return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t3, e4, n2, r3, i3, a3);
        } }), Xe.prototype.isIntersectionLine = function(t3) {
          return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t3);
        }, h2.prototype.multiplyVector3 = function(t3) {
          return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t3.applyQuaternion(this);
        }, Object.assign(xt.prototype, { isIntersectionBox: function(t3) {
          return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t3);
        }, isIntersectionPlane: function(t3) {
          return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t3);
        }, isIntersectionSphere: function(t3) {
          return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t3);
        } }), Object.assign(Pt.prototype, { area: function() {
          return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
        }, barycoordFromPoint: function(t3, e4) {
          return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t3, e4);
        }, midpoint: function(t3) {
          return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t3);
        }, normal: function(t3) {
          return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t3);
        }, plane: function(t3) {
          return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t3);
        } }), Object.assign(Pt, { barycoordFromPoint: function(t3, e4, r3, n2, i3) {
          return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Pt.getBarycoord(t3, e4, r3, n2, i3);
        }, normal: function(t3, e4, r3, n2) {
          return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Pt.getNormal(t3, e4, r3, n2);
        } }), Object.assign(ds.prototype, { extractAllPoints: function(t3) {
          return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t3);
        }, extrude: function(t3) {
          return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Ba(this, t3);
        }, makeGeometry: function(t3) {
          return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ja(this, t3);
        } }), Object.assign(l3.prototype, { fromAttribute: function(t3, e4, r3) {
          return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t3, e4, r3);
        }, distanceToManhattan: function(t3) {
          return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t3);
        }, lengthManhattan: function() {
          return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
        } }), Object.assign(d2.prototype, { setEulerFromRotationMatrix: function() {
          console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
        }, setEulerFromQuaternion: function() {
          console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
        }, getPositionFromMatrix: function(t3) {
          return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t3);
        }, getScaleFromMatrix: function(t3) {
          return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t3);
        }, getColumnFromMatrix: function(t3, e4) {
          return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e4, t3);
        }, applyProjection: function(t3) {
          return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t3);
        }, fromAttribute: function(t3, e4, r3) {
          return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t3, e4, r3);
        }, distanceToManhattan: function(t3) {
          return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t3);
        }, lengthManhattan: function() {
          return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
        } }), Object.assign(x2.prototype, { fromAttribute: function(t3, e4, r3) {
          return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t3, e4, r3);
        }, lengthManhattan: function() {
          return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
        } }), Object.assign(Oe.prototype, { computeTangents: function() {
          console.error("THREE.Geometry: .computeTangents() has been removed.");
        }, computeLineDistances: function() {
          console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
        } }), Object.assign(Y.prototype, { getChildByName: function(t3) {
          return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t3);
        }, renderDepth: function() {
          console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
        }, translate: function(t3, e4) {
          return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e4, t3);
        }, getWorldRotation: function() {
          console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
        } }), Object.defineProperties(Y.prototype, { eulerOrder: { get: function() {
          return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
        }, set: function(t3) {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t3;
        } }, useQuaternion: { get: function() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        }, set: function() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        } } }), Object.defineProperties(xi.prototype, { objects: { get: function() {
          return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
        } } }), Object.defineProperty(Mi.prototype, "useVertexTexture", { get: function() {
          console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        }, set: function() {
          console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        } }), bi.prototype.initBones = function() {
          console.error("THREE.SkinnedMesh: initBones() has been removed.");
        }, Object.defineProperty(Wo.prototype, "__arcLengthDivisions", { get: function() {
          return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions;
        }, set: function(t3) {
          console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t3;
        } }), Ue.prototype.setLens = function(t3, e4) {
          console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), e4 !== void 0 && (this.filmGauge = e4), this.setFocalLength(t3);
        }, Object.defineProperties(fs.prototype, { onlyShadow: { set: function() {
          console.warn("THREE.Light: .onlyShadow has been removed.");
        } }, shadowCameraFov: { set: function(t3) {
          console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t3;
        } }, shadowCameraLeft: { set: function(t3) {
          console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t3;
        } }, shadowCameraRight: { set: function(t3) {
          console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t3;
        } }, shadowCameraTop: { set: function(t3) {
          console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t3;
        } }, shadowCameraBottom: { set: function(t3) {
          console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t3;
        } }, shadowCameraNear: { set: function(t3) {
          console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t3;
        } }, shadowCameraFar: { set: function(t3) {
          console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t3;
        } }, shadowCameraVisible: { set: function() {
          console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
        } }, shadowBias: { set: function(t3) {
          console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t3;
        } }, shadowDarkness: { set: function() {
          console.warn("THREE.Light: .shadowDarkness has been removed.");
        } }, shadowMapWidth: { set: function(t3) {
          console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t3;
        } }, shadowMapHeight: { set: function(t3) {
          console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t3;
        } } }), Object.defineProperties(Vt.prototype, { length: { get: function() {
          return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
        } }, copyIndicesArray: function() {
          console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
        } }), Object.assign(se.prototype, { addIndex: function(t3) {
          console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t3);
        }, addDrawCall: function(t3, e4, r3) {
          r3 !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t3, e4);
        }, clearDrawCalls: function() {
          console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
        }, computeTangents: function() {
          console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
        }, computeOffsets: function() {
          console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
        } }), Object.defineProperties(se.prototype, { drawcalls: { get: function() {
          return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
        } }, offsets: { get: function() {
          return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
        } } }), Object.assign(Fa.prototype, { getArrays: function() {
          console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
        }, addShapeList: function() {
          console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
        }, addShape: function() {
          console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
        } }), Object.defineProperties(Sc.prototype, { dynamic: { set: function() {
          console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
        } }, onUpdate: { value: function() {
          return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
        } } }), Object.defineProperties(Ut.prototype, { wrapAround: { get: function() {
          console.warn("THREE.Material: .wrapAround has been removed.");
        }, set: function() {
          console.warn("THREE.Material: .wrapAround has been removed.");
        } }, overdraw: { get: function() {
          console.warn("THREE.Material: .overdraw has been removed.");
        }, set: function() {
          console.warn("THREE.Material: .overdraw has been removed.");
        } }, wrapRGB: { get: function() {
          return console.warn("THREE.Material: .wrapRGB has been removed."), new Nt();
        } }, shading: { get: function() {
          console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        }, set: function(t3) {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t3 === 1;
        } } }), Object.defineProperties(ho.prototype, { metal: { get: function() {
          return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), false;
        }, set: function() {
          console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
        } } }), Object.defineProperties(Fe.prototype, { derivatives: { get: function() {
          return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
        }, set: function(t3) {
          console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t3;
        } } }), Object.assign(Qn.prototype, { clearTarget: function(t3, e4, r3, n2) {
          console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t3), this.clear(e4, r3, n2);
        }, animate: function(t3) {
          console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t3);
        }, getCurrentRenderTarget: function() {
          return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
        }, getMaxAnisotropy: function() {
          return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
        }, getPrecision: function() {
          return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
        }, resetGLState: function() {
          return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
        }, supportsFloatTextures: function() {
          return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
        }, supportsHalfFloatTextures: function() {
          return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
        }, supportsStandardDerivatives: function() {
          return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
        }, supportsCompressedTextureS3TC: function() {
          return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
        }, supportsCompressedTexturePVRTC: function() {
          return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
        }, supportsBlendMinMax: function() {
          return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
        }, supportsVertexTextures: function() {
          return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
        }, supportsInstancedArrays: function() {
          return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
        }, enableScissorTest: function(t3) {
          console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t3);
        }, initMaterial: function() {
          console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
        }, addPrePlugin: function() {
          console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
        }, addPostPlugin: function() {
          console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
        }, updateShadowMap: function() {
          console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
        }, setFaceCulling: function() {
          console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
        }, allocTextureUnit: function() {
          console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
        }, setTexture: function() {
          console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
        }, setTexture2D: function() {
          console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
        }, setTextureCube: function() {
          console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
        }, getActiveMipMapLevel: function() {
          return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
        } }), Object.defineProperties(Qn.prototype, { shadowMapEnabled: { get: function() {
          return this.shadowMap.enabled;
        }, set: function(t3) {
          console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t3;
        } }, shadowMapType: { get: function() {
          return this.shadowMap.type;
        }, set: function(t3) {
          console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t3;
        } }, shadowMapCullFace: { get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        }, set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        } }, context: { get: function() {
          return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
        } } }), Object.defineProperties(Gn.prototype, { cullFace: { get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        }, set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        } }, renderReverseSided: { get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        }, set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        } }, renderSingleSided: { get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        }, set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        } } }), Object.defineProperties(Ve.prototype, { activeCubeFace: { set: function() {
          console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().");
        } }, activeMipMapLevel: { set: function() {
          console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().");
        } } }), Object.defineProperties(b2.prototype, { wrapS: { get: function() {
          return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
        }, set: function(t3) {
          console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t3;
        } }, wrapT: { get: function() {
          return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
        }, set: function(t3) {
          console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t3;
        } }, magFilter: { get: function() {
          return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
        }, set: function(t3) {
          console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t3;
        } }, minFilter: { get: function() {
          return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
        }, set: function(t3) {
          console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t3;
        } }, anisotropy: { get: function() {
          return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
        }, set: function(t3) {
          console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t3;
        } }, offset: { get: function() {
          return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
        }, set: function(t3) {
          console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t3;
        } }, repeat: { get: function() {
          return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
        }, set: function(t3) {
          console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t3;
        } }, format: { get: function() {
          return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
        }, set: function(t3) {
          console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t3;
        } }, type: { get: function() {
          return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
        }, set: function(t3) {
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t3;
        } }, generateMipmaps: { get: function() {
          return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
        }, set: function(t3) {
          console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t3;
        } } }), Object.defineProperties(Jn.prototype, { standing: { set: function() {
          console.warn("THREE.WebVRManager: .standing has been removed.");
        } }, userHeight: { set: function() {
          console.warn("THREE.WebVRManager: .userHeight has been removed.");
        } } }), nc.prototype.load = function(t3) {
          console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
          var e4 = this;
          return new js().load(t3, function(t4) {
            e4.setBuffer(t4);
          }), this;
        }, lc.prototype.getData = function() {
          return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
        }, He.prototype.updateCubeMap = function(t3, e4) {
          return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t3, e4);
        };
        var Ll = { merge: function(t3, e4, r3) {
          var n2;
          console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e4.isMesh && (e4.matrixAutoUpdate && e4.updateMatrix(), n2 = e4.matrix, e4 = e4.geometry), t3.merge(e4, n2, r3);
        }, center: function(t3) {
          return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t3.center();
        } };
        g2.crossOrigin = void 0, g2.loadTexture = function(t3, e4, r3, n2) {
          console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
          var i3 = new ko();
          i3.setCrossOrigin(this.crossOrigin);
          var a3 = i3.load(t3, r3, void 0, n2);
          return e4 && (a3.mapping = e4), a3;
        }, g2.loadTextureCube = function(t3, e4, r3, n2) {
          console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
          var i3 = new jo();
          i3.setCrossOrigin(this.crossOrigin);
          var a3 = i3.load(t3, r3, void 0, n2);
          return e4 && (a3.mapping = e4), a3;
        }, g2.loadCompressedTexture = function() {
          console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
        }, g2.loadCompressedTextureCube = function() {
          console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
        };
        var Rl = { createMultiMaterialObject: function() {
          console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
        }, detach: function() {
          console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
        }, attach: function() {
          console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
        } };
        t2.ACESFilmicToneMapping = 5, t2.AddEquation = 100, t2.AddOperation = 2, t2.AdditiveBlending = 2, t2.AlphaFormat = 1021, t2.AlwaysDepth = 1, t2.AlwaysStencilFunc = 519, t2.AmbientLight = Ss, t2.AmbientLightProbe = Xs, t2.AnimationClip = Co, t2.AnimationLoader = Go, t2.AnimationMixer = Mc, t2.AnimationObjectGroup = wc, t2.AnimationUtils = yo, t2.ArcCurve = Xo, t2.ArrayCamera = kn, t2.ArrowHelper = Ml, t2.Audio = nc, t2.AudioAnalyser = lc, t2.AudioContext = Vs, t2.AudioListener = rc, t2.AudioLoader = js, t2.AxesHelper = Sl, t2.AxisHelper = function(t3) {
          return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Sl(t3);
        }, t2.BackSide = 1, t2.BasicDepthPacking = 3200, t2.BasicShadowMap = 0, t2.BinaryTextureLoader = function(t3) {
          return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Ho(t3);
        }, t2.Bone = Si, t2.BooleanKeyframeTrack = So, t2.BoundingBoxHelper = function(t3, e4) {
          return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new vl(t3, e4);
        }, t2.Box2 = Oc, t2.Box3 = ct, t2.Box3Helper = yl, t2.BoxBufferGeometry = Ne, t2.BoxGeometry = De, t2.BoxHelper = vl, t2.BufferAttribute = Vt, t2.BufferGeometry = se, t2.BufferGeometryLoader = Ps, t2.ByteType = 1010, t2.Cache = Do, t2.Camera = Ge, t2.CameraHelper = fl, t2.CanvasRenderer = function() {
          console.error("THREE.CanvasRenderer has been removed");
        }, t2.CanvasTexture = Wi, t2.CatmullRomCurve3 = $o, t2.CineonToneMapping = 4, t2.CircleBufferGeometry = io, t2.CircleGeometry = no, t2.ClampToEdgeWrapping = 1001, t2.Clock = Qs, t2.ClosedSplineCurve3 = Tl, t2.Color = Nt, t2.ColorKeyframeTrack = To, t2.CompressedTexture = ki, t2.CompressedTextureLoader = Uo, t2.ConeBufferGeometry = ro, t2.ConeGeometry = eo, t2.CubeCamera = He, t2.CubeGeometry = De, t2.CubeReflectionMapping = 301, t2.CubeRefractionMapping = 302, t2.CubeTexture = mr, t2.CubeTextureLoader = jo, t2.CubeUVReflectionMapping = 306, t2.CubeUVRefractionMapping = 307, t2.CubicBezierCurve = ns, t2.CubicBezierCurve3 = is, t2.CubicInterpolant = bo, t2.CullFaceBack = 1, t2.CullFaceFront = 2, t2.CullFaceFrontBack = 3, t2.CullFaceNone = 0, t2.Curve = Wo, t2.CurvePath = us, t2.CustomBlending = 5, t2.CylinderBufferGeometry = to, t2.CylinderGeometry = $a, t2.Cylindrical = Pc, t2.DataTexture = je, t2.DataTexture2DArray = gr, t2.DataTexture3D = vr, t2.DataTextureLoader = Ho, t2.DecrementStencilOp = 7683, t2.DecrementWrapStencilOp = 34056, t2.DefaultLoadingManager = Io, t2.DepthFormat = 1026, t2.DepthStencilFormat = 1027, t2.DepthTexture = qi, t2.DirectionalLight = Ms, t2.DirectionalLightHelper = ul, t2.DirectionalLightShadow = _s, t2.DiscreteInterpolant = _o, t2.DodecahedronBufferGeometry = aa, t2.DodecahedronGeometry = ia, t2.DoubleSide = 2, t2.DstAlphaFactor = 206, t2.DstColorFactor = 208, t2.DynamicBufferAttribute = function(t3, e4) {
          return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new Vt(t3, e4).setDynamic(true);
        }, t2.EdgesGeometry = Ka, t2.EdgesHelper = function(t3, e4) {
          return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ni(new Ka(t3.geometry), new Ti({ color: e4 !== void 0 ? e4 : 16777215 }));
        }, t2.EllipseCurve = qo, t2.EqualDepth = 4, t2.EqualStencilFunc = 514, t2.EquirectangularReflectionMapping = 303, t2.EquirectangularRefractionMapping = 304, t2.Euler = D, t2.EventDispatcher = e3, t2.ExtrudeBufferGeometry = Fa, t2.ExtrudeGeometry = Ba, t2.Face3 = Ft, t2.Face4 = function(t3, e4, r3, n2, i3, a3, o5) {
          return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new Ft(t3, e4, r3, i3, a3, o5);
        }, t2.FaceColors = 1, t2.FaceNormalsHelper = sl, t2.FileLoader = Fo, t2.FlatShading = 1, t2.Float32Attribute = function(t3, e4) {
          return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Zt(t3, e4);
        }, t2.Float32BufferAttribute = Zt, t2.Float64Attribute = function(t3, e4) {
          return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Qt(t3, e4);
        }, t2.Float64BufferAttribute = Qt, t2.FloatType = 1015, t2.Fog = $n, t2.FogExp2 = Kn, t2.Font = Gs, t2.FontLoader = Hs, t2.FrontFaceDirectionCCW = 1, t2.FrontFaceDirectionCW = 0, t2.FrontSide = 0, t2.Frustum = Ze, t2.GammaEncoding = 3007, t2.Geometry = Oe, t2.GeometryUtils = Ll, t2.GreaterDepth = 6, t2.GreaterEqualDepth = 5, t2.GreaterEqualStencilFunc = 518, t2.GreaterStencilFunc = 516, t2.GridHelper = el, t2.Group = jn, t2.HalfFloatType = 1016, t2.HemisphereLight = ms, t2.HemisphereLightHelper = $c, t2.HemisphereLightProbe = qs, t2.IcosahedronBufferGeometry = na, t2.IcosahedronGeometry = ra, t2.ImageBitmapLoader = Bs, t2.ImageLoader = Vo, t2.ImageUtils = g2, t2.ImmediateRenderObject = zc, t2.IncrementStencilOp = 7682, t2.IncrementWrapStencilOp = 34055, t2.InstancedBufferAttribute = Rs, t2.InstancedBufferGeometry = Ls, t2.InstancedInterleavedBuffer = Tc, t2.Int16Attribute = function(t3, e4) {
          return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new qt(t3, e4);
        }, t2.Int16BufferAttribute = qt, t2.Int32Attribute = function(t3, e4) {
          return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Yt(t3, e4);
        }, t2.Int32BufferAttribute = Yt, t2.Int8Attribute = function(t3, e4) {
          return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new jt(t3, e4);
        }, t2.Int8BufferAttribute = jt, t2.IntType = 1013, t2.InterleavedBuffer = ti, t2.InterleavedBufferAttribute = ei, t2.Interpolant = xo, t2.InterpolateDiscrete = 2300, t2.InterpolateLinear = 2301, t2.InterpolateSmooth = 2302, t2.InvertStencilOp = 5386, t2.JSONLoader = function() {
          console.error("THREE.JSONLoader has been removed.");
        }, t2.KeepStencilOp = 7680, t2.KeyframeTrack = Mo, t2.LOD = xi, t2.LatheBufferGeometry = Ya, t2.LatheGeometry = Xa, t2.Layers = N, t2.LensFlare = function() {
          console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js");
        }, t2.LessDepth = 2, t2.LessEqualDepth = 3, t2.LessEqualStencilFunc = 515, t2.LessStencilFunc = 513, t2.Light = fs, t2.LightProbe = Ws, t2.LightProbeHelper = tl, t2.LightShadow = gs, t2.Line = Ci, t2.Line3 = Ic, t2.LineBasicMaterial = Ti, t2.LineCurve = as, t2.LineCurve3 = os, t2.LineDashedMaterial = go, t2.LineLoop = Ii, t2.LinePieces = 1, t2.LineSegments = Ni, t2.LineStrip = 0, t2.LinearEncoding = 3e3, t2.LinearFilter = 1006, t2.LinearInterpolant = wo, t2.LinearMipMapLinearFilter = 1008, t2.LinearMipMapNearestFilter = 1007, t2.LinearMipmapLinearFilter = 1008, t2.LinearMipmapNearestFilter = 1007, t2.LinearToneMapping = 1, t2.Loader = zo, t2.LoaderUtils = As, t2.LoadingManager = No, t2.LogLuvEncoding = 3003, t2.LoopOnce = 2200, t2.LoopPingPong = 2202, t2.LoopRepeat = 2201, t2.LuminanceAlphaFormat = 1025, t2.LuminanceFormat = 1024, t2.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, t2.Material = Ut, t2.MaterialLoader = Es, t2.Math = s3, t2.Matrix3 = m2, t2.Matrix4 = P2, t2.MaxEquation = 104, t2.Mesh = Te, t2.MeshBasicMaterial = Ht, t2.MeshDepthMaterial = Bn, t2.MeshDistanceMaterial = Fn, t2.MeshFaceMaterial = function(t3) {
          return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t3;
        }, t2.MeshLambertMaterial = fo, t2.MeshMatcapMaterial = mo, t2.MeshNormalMaterial = po, t2.MeshPhongMaterial = ho, t2.MeshPhysicalMaterial = lo, t2.MeshStandardMaterial = co, t2.MeshToonMaterial = uo, t2.MinEquation = 103, t2.MirroredRepeatWrapping = 1002, t2.MixOperation = 1, t2.MultiMaterial = function(t3) {
          return t3 === void 0 && (t3 = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t3.isMultiMaterial = true, t3.materials = t3, t3.clone = function() {
            return t3.slice();
          }, t3;
        }, t2.MultiplyBlending = 4, t2.MultiplyOperation = 0, t2.NearestFilter = 1003, t2.NearestMipMapLinearFilter = 1005, t2.NearestMipMapNearestFilter = 1004, t2.NearestMipmapLinearFilter = 1005, t2.NearestMipmapNearestFilter = 1004, t2.NeverDepth = 0, t2.NeverStencilFunc = 512, t2.NoBlending = 0, t2.NoColors = 0, t2.NoToneMapping = 0, t2.NormalBlending = 1, t2.NotEqualDepth = 7, t2.NotEqualStencilFunc = 517, t2.NumberKeyframeTrack = Eo, t2.Object3D = Y, t2.ObjectLoader = Os, t2.ObjectSpaceNormalMap = 1, t2.OctahedronBufferGeometry = ea, t2.OctahedronGeometry = ta, t2.OneFactor = 201, t2.OneMinusDstAlphaFactor = 207, t2.OneMinusDstColorFactor = 209, t2.OneMinusSrcAlphaFactor = 205, t2.OneMinusSrcColorFactor = 203, t2.OrthographicCamera = ws, t2.PCFShadowMap = 1, t2.PCFSoftShadowMap = 2, t2.ParametricBufferGeometry = Ji, t2.ParametricGeometry = Yi, t2.Particle = function(t3) {
          return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new mi(t3);
        }, t2.ParticleBasicMaterial = function(t3) {
          return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new zi(t3);
        }, t2.ParticleSystem = function(t3, e4) {
          return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Hi(t3, e4);
        }, t2.ParticleSystemMaterial = function(t3) {
          return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new zi(t3);
        }, t2.Path = ps, t2.PerspectiveCamera = Ue, t2.Plane = Xe, t2.PlaneBufferGeometry = nr, t2.PlaneGeometry = rr, t2.PlaneHelper = xl, t2.PointCloud = function(t3, e4) {
          return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Hi(t3, e4);
        }, t2.PointCloudMaterial = function(t3) {
          return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new zi(t3);
        }, t2.PointLight = bs, t2.PointLightHelper = Yc, t2.Points = Hi, t2.PointsMaterial = zi, t2.PolarGridHelper = rl, t2.PolyhedronBufferGeometry = Qi, t2.PolyhedronGeometry = Zi, t2.PositionalAudio = cc, t2.PositionalAudioHelper = nl, t2.PropertyBinding = bc, t2.PropertyMixer = hc, t2.QuadraticBezierCurve = ss, t2.QuadraticBezierCurve3 = cs, t2.Quaternion = h2, t2.QuaternionKeyframeTrack = Lo, t2.QuaternionLinearInterpolant = Ao, t2.REVISION = "108", t2.RGBADepthPacking = 3201, t2.RGBAFormat = 1023, t2.RGBA_ASTC_10x10_Format = 37819, t2.RGBA_ASTC_10x5_Format = 37816, t2.RGBA_ASTC_10x6_Format = 37817, t2.RGBA_ASTC_10x8_Format = 37818, t2.RGBA_ASTC_12x10_Format = 37820, t2.RGBA_ASTC_12x12_Format = 37821, t2.RGBA_ASTC_4x4_Format = 37808, t2.RGBA_ASTC_5x4_Format = 37809, t2.RGBA_ASTC_5x5_Format = 37810, t2.RGBA_ASTC_6x5_Format = 37811, t2.RGBA_ASTC_6x6_Format = 37812, t2.RGBA_ASTC_8x5_Format = 37813, t2.RGBA_ASTC_8x6_Format = 37814, t2.RGBA_ASTC_8x8_Format = 37815, t2.RGBA_PVRTC_2BPPV1_Format = 35843, t2.RGBA_PVRTC_4BPPV1_Format = 35842, t2.RGBA_S3TC_DXT1_Format = 33777, t2.RGBA_S3TC_DXT3_Format = 33778, t2.RGBA_S3TC_DXT5_Format = 33779, t2.RGBDEncoding = 3006, t2.RGBEEncoding = 3002, t2.RGBEFormat = 1023, t2.RGBFormat = 1022, t2.RGBM16Encoding = 3005, t2.RGBM7Encoding = 3004, t2.RGB_ETC1_Format = 36196, t2.RGB_PVRTC_2BPPV1_Format = 35841, t2.RGB_PVRTC_4BPPV1_Format = 35840, t2.RGB_S3TC_DXT1_Format = 33776, t2.RawShaderMaterial = so, t2.Ray = xt, t2.Raycaster = Ec, t2.RectAreaLight = Ts, t2.RectAreaLightHelper = Jc, t2.RedFormat = 1028, t2.ReinhardToneMapping = 2, t2.RepeatWrapping = 1e3, t2.ReplaceStencilOp = 7681, t2.ReverseSubtractEquation = 102, t2.RingBufferGeometry = qa, t2.RingGeometry = Wa, t2.Scene = J, t2.SceneUtils = Rl, t2.ShaderChunk = Qe, t2.ShaderLib = $e, t2.ShaderMaterial = Fe, t2.ShadowMaterial = oo, t2.Shape = ds, t2.ShapeBufferGeometry = Za, t2.ShapeGeometry = Ja, t2.ShapePath = Fs, t2.ShapeUtils = Na, t2.ShortType = 1011, t2.Skeleton = Mi, t2.SkeletonHelper = Xc, t2.SkinnedMesh = bi, t2.SmoothShading = 2, t2.Sphere = ut, t2.SphereBufferGeometry = ka, t2.SphereGeometry = ja, t2.Spherical = Rc, t2.SphericalHarmonics3 = ks, t2.SphericalReflectionMapping = 305, t2.Spline = Al, t2.SplineCurve = ls, t2.SplineCurve3 = El, t2.SpotLight = ys, t2.SpotLightHelper = jc, t2.SpotLightShadow = vs, t2.Sprite = mi, t2.SpriteMaterial = ri, t2.SrcAlphaFactor = 204, t2.SrcAlphaSaturateFactor = 210, t2.SrcColorFactor = 202, t2.StereoCamera = Zs, t2.StringKeyframeTrack = Ro, t2.SubtractEquation = 101, t2.SubtractiveBlending = 3, t2.TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, t2.TangentSpaceNormalMap = 0, t2.TetrahedronBufferGeometry = $i, t2.TetrahedronGeometry = Ki, t2.TextBufferGeometry = Va, t2.TextGeometry = Ha, t2.Texture = y2, t2.TextureLoader = ko, t2.TorusBufferGeometry = ua, t2.TorusGeometry = ha, t2.TorusKnotBufferGeometry = la, t2.TorusKnotGeometry = ca, t2.Triangle = Pt, t2.TriangleFanDrawMode = 2, t2.TriangleStripDrawMode = 1, t2.TrianglesDrawMode = 0, t2.TubeBufferGeometry = sa, t2.TubeGeometry = oa, t2.UVMapping = 300, t2.Uint16Attribute = function(t3, e4) {
          return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Xt(t3, e4);
        }, t2.Uint16BufferAttribute = Xt, t2.Uint32Attribute = function(t3, e4) {
          return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Jt(t3, e4);
        }, t2.Uint32BufferAttribute = Jt, t2.Uint8Attribute = function(t3, e4) {
          return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new kt(t3, e4);
        }, t2.Uint8BufferAttribute = kt, t2.Uint8ClampedAttribute = function(t3, e4) {
          return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Wt(t3, e4);
        }, t2.Uint8ClampedBufferAttribute = Wt, t2.Uncharted2ToneMapping = 3, t2.Uniform = Sc, t2.UniformsLib = Ke, t2.UniformsUtils = Be, t2.UnsignedByteType = 1009, t2.UnsignedInt248Type = 1020, t2.UnsignedIntType = 1014, t2.UnsignedShort4444Type = 1017, t2.UnsignedShort5551Type = 1018, t2.UnsignedShort565Type = 1019, t2.UnsignedShortType = 1012, t2.VSMShadowMap = 3, t2.Vector2 = l3, t2.Vector3 = d2, t2.Vector4 = x2, t2.VectorKeyframeTrack = Po, t2.Vertex = function(t3, e4, r3) {
          return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new d2(t3, e4, r3);
        }, t2.VertexColors = 2, t2.VertexNormalsHelper = Hc, t2.VideoTexture = ji, t2.WebGLMultisampleRenderTarget = w2, t2.WebGLRenderTarget = b2, t2.WebGLRenderTargetCube = Ve, t2.WebGLRenderer = Qn, t2.WebGLUtils = Vn, t2.WireframeGeometry = Xi, t2.WireframeHelper = function(t3, e4) {
          return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ni(new Xi(t3.geometry), new Ti({ color: e4 !== void 0 ? e4 : 16777215 }));
        }, t2.WrapAroundEnding = 2402, t2.XHRLoader = function(t3) {
          return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Fo(t3);
        }, t2.ZeroCurvatureEnding = 2400, t2.ZeroFactor = 200, t2.ZeroSlopeEnding = 2401, t2.ZeroStencilOp = 0, t2.sRGBEncoding = 3001, Object.defineProperty(t2, "__esModule", { value: true });
      }, R(l2) === "object" && t !== void 0 ? s2(l2) : s2((o3 = o3 || self).THREE = {}), l2;
    }
    T.UNSEND = 0, T.OPENED = 1, T.HEADERS_RECEIVED = 2, T.LOADING = 3, T.DONE = 4;
  }]));
})(dist);
exports._export_sfc = _export_sfc;
exports.createSSRApp = createSSRApp;
exports.dist = dist;
exports.index = index;
exports.o = o;
exports.onMounted = onMounted;
exports.unref = unref;
